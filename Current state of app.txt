--- File: .\all files extract.py ---

import os
import logging

# --- Configuration ---
# The directory to start the search from. '.' means the current directory.
ROOT_DIRECTORY = '.'

# The name of the output file.
OUTPUT_FILENAME = 'output.txt'

# The file extensions to look for.
TARGET_EXTENSIONS = ['.py', '.jsx', '.js', '.html']

# List of directory names to exclude from the search.
EXCLUDED_DIRECTORIES = ['venv', '.git', 'node_modules', '.pytest_cache', '__pycache__']

# The name of the log file.
LOG_FILENAME = 'script.log'
# --- End of Configuration ---

def setup_logging():
    """Configures the logging for the script."""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(LOG_FILENAME),
            logging.StreamHandler()
        ]
    )

def collect_files_and_content():
    """
    Traverses subdirectories, reads specified files, and writes their
    content to an output file, skipping excluded directories.
    """
    logging.info(f"Starting the script in directory: {os.path.abspath(ROOT_DIRECTORY)}")
    logging.info(f"Looking for files with extensions: {', '.join(TARGET_EXTENSIONS)}")
    logging.info(f"Excluding directories named: {', '.join(EXCLUDED_DIRECTORIES)}")
    logging.info(f"Output will be saved to: {OUTPUT_FILENAME}")

    try:
        with open(OUTPUT_FILENAME, 'w', encoding='utf-8') as outfile:
            # os.walk recursively goes through directories.
            for dirpath, dirnames, filenames in os.walk(ROOT_DIRECTORY):
                
                # --- FILTERING LOGIC ---
                # Modify dirnames in-place to prevent os.walk from descending into them.
                # The `[:]` is crucial for modifying the list in-place. [1]
                dirnames[:] = [d for d in dirnames if d not in EXCLUDED_DIRECTORIES]
                
                logging.info(f"Scanning directory: {dirpath}")
                for filename in filenames:
                    # Check if the file has one of the target extensions.
                    if any(filename.endswith(ext) for ext in TARGET_EXTENSIONS):
                        file_path = os.path.join(dirpath, filename)
                        logging.info(f"Found matching file: {file_path}")

                        try:
                            # Write the file path to the output file.
                            outfile.write(f"--- File: {file_path} ---\n\n")
                            
                            # Open and read the content of the found file.
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as infile:
                                content = infile.read()
                                outfile.write(content)
                                outfile.write("\n\n")
                        except Exception as e:
                            logging.error(f"Could not read file {file_path}: {e}")
                            outfile.write(f"--- Error reading file: {file_path} ---\n\n")

    except IOError as e:
        logging.critical(f"Could not write to output file {OUTPUT_FILENAME}: {e}")

    logging.info("Script has finished execution.")

if __name__ == "__main__":
    setup_logging()
    collect_files_and_content()

--- File: .\direcotory generator.py ---

#!/usr/bin/env python3

import os

# â”€â”€â”€ CONFIGURE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
max_depth = 4  # Set the maximum depth to explore. 0 for root only, 1 for root + children, etc.

skip_dirs = [
    "venv",
    ".pytest_cache",
    "test",
    ".git",
    "__pycache__",
    "GCSE",
    "Primary School",
    "Sixth Form - College",
    "node_modules"
    # add more folder names here to skip
]

output_file = "directory_map.txt"
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    root_dir = os.getcwd()
    base = os.path.basename(root_dir.rstrip(os.path.sep))
    
    with open(output_file, "w", encoding="utf-8") as f:
        # We don't write the root here, os.walk will handle it on the first iteration

        for current_root, dirs, files in os.walk(root_dir):
            # relative path from root
            rel_path = os.path.relpath(current_root, root_dir)
            
            # --- DEPTH CALCULATION ---
            if rel_path == ".":
                depth = 0
            else:
                depth = len(rel_path.split(os.path.sep))
            
            # --- PRUNING LOGIC ---
            # Prune skip_dirs first
            # We iterate over a copy of dirs using list(dirs) because we modify it in the loop
            for d in list(dirs):
                if d in skip_dirs:
                    # Construct the path to show it's being skipped
                    if depth < max_depth: # Only show skipped message if within depth
                        if rel_path == ".":
                             prefix = f"/{base}"
                        else:
                             prefix = f"/{base}/{rel_path.replace(os.path.sep, '/')}"
                        skip_path = prefix + "/" + d + "/"
                        f.write(skip_path + " (skipped)\n")
                    dirs.remove(d) # Prune it from traversal

            # Now, prune based on max_depth
            if depth >= max_depth:
                dirs[:] = [] # Clear the list of directories to visit next, stopping the descent

            # --- OUTPUT GENERATION ---
            # Construct the display prefix for the current directory
            if rel_path == ".":
                prefix = f"/{base}"
            else:
                prefix = f"/{base}/{rel_path.replace(os.path.sep, '/')}"

            # write this folderâ€™s path
            f.write(prefix + "/\n")

            # list files: full path for first, shortened for the rest
            if files:
                # full path for the first file
                first_file = files[0]
                f.write(f"{prefix}/{first_file}\n")

                # for subsequent files, show only ".../<last_dir>/<filename>"
                last_dir = os.path.basename(current_root)
                for filename in files[1:]:
                    f.write(f".../{last_dir}/{filename}\n")

    print(f"Directory map written to {output_file} (up to a depth of {max_depth})")

if __name__ == "__main__":
    main()

--- File: .\ata-backend\direcotory generator.py ---

#!/usr/bin/env python3

import os

# â”€â”€â”€ CONFIGURE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
max_depth = 3  # Set the maximum depth to explore. 0 for root only, 1 for root + children, etc.

skip_dirs = [
    "venv",
    ".pytest_cache",
    "test",
    ".git",
    "__pycache__",
    "GCSE",
    "Primary School",
    "Sixth Form - College",
    "node_modules"
    # add more folder names here to skip
]

output_file = "directory_map.txt"
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    root_dir = os.getcwd()
    base = os.path.basename(root_dir.rstrip(os.path.sep))
    
    with open(output_file, "w", encoding="utf-8") as f:
        # We don't write the root here, os.walk will handle it on the first iteration

        for current_root, dirs, files in os.walk(root_dir):
            # relative path from root
            rel_path = os.path.relpath(current_root, root_dir)
            
            # --- DEPTH CALCULATION ---
            if rel_path == ".":
                depth = 0
            else:
                depth = len(rel_path.split(os.path.sep))
            
            # --- PRUNING LOGIC ---
            # Prune skip_dirs first
            # We iterate over a copy of dirs using list(dirs) because we modify it in the loop
            for d in list(dirs):
                if d in skip_dirs:
                    # Construct the path to show it's being skipped
                    if depth < max_depth: # Only show skipped message if within depth
                        if rel_path == ".":
                             prefix = f"/{base}"
                        else:
                             prefix = f"/{base}/{rel_path.replace(os.path.sep, '/')}"
                        skip_path = prefix + "/" + d + "/"
                        f.write(skip_path + " (skipped)\n")
                    dirs.remove(d) # Prune it from traversal

            # Now, prune based on max_depth
            if depth >= max_depth:
                dirs[:] = [] # Clear the list of directories to visit next, stopping the descent

            # --- OUTPUT GENERATION ---
            # Construct the display prefix for the current directory
            if rel_path == ".":
                prefix = f"/{base}"
            else:
                prefix = f"/{base}/{rel_path.replace(os.path.sep, '/')}"

            # write this folderâ€™s path
            f.write(prefix + "/\n")

            # list files: full path for first, shortened for the rest
            if files:
                # full path for the first file
                first_file = files[0]
                f.write(f"{prefix}/{first_file}\n")

                # for subsequent files, show only ".../<last_dir>/<filename>"
                last_dir = os.path.basename(current_root)
                for filename in files[1:]:
                    f.write(f".../{last_dir}/{filename}\n")

    print(f"Directory map written to {output_file} (up to a depth of {max_depth})")

if __name__ == "__main__":
    main()

--- File: .\ata-backend\alembic\env.py ---

# /ata-backend/alembic/env.py (MODIFIED AND APPROVED)

import os
import sys
from logging.config import fileConfig

# --- [CRITICAL MODIFICATION FOR .env LOADING] ---
# Import the load_dotenv function from the dotenv library.
from dotenv import load_dotenv

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# --- [CRITICAL MODIFICATION FOR .env LOADING] ---
# Explicitly load the .env file from the project's root directory.
# This ensures that the DATABASE_URL is available when Alembic runs.
load_dotenv(os.path.join(os.path.dirname(__file__), '..', '.env'))


# --- [CONFIGURATION - PART 1: MODEL PATH] ---
# This is the first critical piece. We add our project's 'app' directory
# to the Python path so Alembic can find our models.
sys.path.insert(0, os.path.realpath(os.path.join(os.path.dirname(__file__), '..')))

# Now we can import our Base from our application's code.
from app.db.base import Base

# --- [END OF PART 1] ---


# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# --- [CONFIGURATION - PART 2: DATABASE URL] ---
# This is the second critical piece. We get the DATABASE_URL from the
# environment and inject it into the Alembic config.
# This will now work because we loaded the .env file above.
database_url = os.getenv("DATABASE_URL")
if not database_url:
    raise ValueError("DATABASE_URL environment variable not set.")

config.set_main_option("sqlalchemy.url", database_url)
# --- [END OF PART 2] ---


# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# --- [CONFIGURATION - PART 3: TARGET METADATA] ---
# This is the third critical piece. We tell Alembic that our models' metadata
# is the target for the 'autogenerate' process.
target_metadata = Base.metadata
# --- [END OF PART 3] ---


# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.
    (The rest of this file is the standard Alembic template and is correct)
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.
    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

--- File: .\ata-backend\alembic\versions\004a6ff4b05e_add_admin_authentication_and_file_.py ---

"""Add admin authentication and file cleanup features

Revision ID: 004a6ff4b05e
Revises: 412835303893
Create Date: 2025-10-05 13:51:34.115168

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '004a6ff4b05e'
down_revision: Union[str, Sequence[str], None] = '412835303893'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


--- File: .\ata-backend\alembic\versions\412835303893_create_copilot_schema_for_all_tables.py ---

"""Create copilot schema for all tables

Revision ID: 412835303893
Revises: 
Create Date: 2025-10-05 01:49:24.919840

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '412835303893'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('students',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('studentId', sa.String(), nullable=False),
    sa.Column('overallGrade', sa.Integer(), nullable=True),
    sa.Column('performance_summary', sa.String(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_students_id'), 'students', ['id'], unique=False)
    op.create_index(op.f('ix_students_name'), 'students', ['name'], unique=False)
    op.create_index(op.f('ix_students_studentId'), 'students', ['studentId'], unique=True)
    op.create_table('users',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('full_name', sa.String(), nullable=True),
    sa.Column('hashed_password', sa.String(), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_full_name'), 'users', ['full_name'], unique=False)
    op.create_table('assessments',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('status', sa.String(), nullable=False),
    sa.Column('config', sa.JSON(), nullable=False),
    sa.Column('answer_sheet_paths', sa.JSON(), nullable=True),
    sa.Column('ai_summary', sa.String(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('total_pages', sa.Float(), nullable=True),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_assessments_id'), 'assessments', ['id'], unique=False)
    op.create_index(op.f('ix_assessments_status'), 'assessments', ['status'], unique=False)
    op.create_index(op.f('ix_assessments_user_id'), 'assessments', ['user_id'], unique=False)
    op.create_table('chatsessions',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_chatsessions_id'), 'chatsessions', ['id'], unique=False)
    op.create_index(op.f('ix_chatsessions_user_id'), 'chatsessions', ['user_id'], unique=False)
    op.create_table('classes',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('description', sa.String(), nullable=True),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_classes_id'), 'classes', ['id'], unique=False)
    op.create_index(op.f('ix_classes_name'), 'classes', ['name'], unique=False)
    op.create_index(op.f('ix_classes_user_id'), 'classes', ['user_id'], unique=False)
    op.create_table('generations',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('title', sa.String(), nullable=False),
    sa.Column('tool_id', sa.String(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('settings_snapshot', sa.JSON(), nullable=False),
    sa.Column('generated_content', sa.String(), nullable=False),
    sa.Column('user_id', sa.UUID(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_generations_id'), 'generations', ['id'], unique=False)
    op.create_index(op.f('ix_generations_tool_id'), 'generations', ['tool_id'], unique=False)
    op.create_index(op.f('ix_generations_user_id'), 'generations', ['user_id'], unique=False)
    op.create_table('chatmessages',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('session_id', sa.String(), nullable=False),
    sa.Column('role', sa.String(), nullable=False),
    sa.Column('content', sa.String(), nullable=False),
    sa.Column('file_id', sa.String(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['session_id'], ['chatsessions.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_chatmessages_id'), 'chatmessages', ['id'], unique=False)
    op.create_table('outsider_students',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('assessment_id', sa.String(), nullable=False),
    sa.ForeignKeyConstraint(['assessment_id'], ['assessments.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_outsider_students_assessment_id'), 'outsider_students', ['assessment_id'], unique=False)
    op.create_index(op.f('ix_outsider_students_name'), 'outsider_students', ['name'], unique=False)
    op.create_table('student_class_memberships',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('student_id', sa.String(), nullable=False),
    sa.Column('class_id', sa.String(), nullable=False),
    sa.ForeignKeyConstraint(['class_id'], ['classes.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('student_id', 'class_id', name='uq_student_class')
    )
    op.create_index(op.f('ix_student_class_memberships_class_id'), 'student_class_memberships', ['class_id'], unique=False)
    op.create_index(op.f('ix_student_class_memberships_id'), 'student_class_memberships', ['id'], unique=False)
    op.create_index(op.f('ix_student_class_memberships_student_id'), 'student_class_memberships', ['student_id'], unique=False)
    op.create_table('ai_model_runs',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('job_id', sa.String(), nullable=False),
    sa.Column('student_id', sa.String(), nullable=True),
    sa.Column('outsider_student_id', sa.String(), nullable=True),
    sa.Column('question_id', sa.String(), nullable=False),
    sa.Column('run_index', sa.SmallInteger(), nullable=False),
    sa.Column('raw_json', postgresql.JSONB(astext_type=sa.Text()), nullable=False),
    sa.Column('grade', sa.Numeric(precision=10, scale=2), nullable=True),
    sa.Column('comment', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
    sa.CheckConstraint('(student_id IS NOT NULL AND outsider_student_id IS NULL) OR (student_id IS NULL AND outsider_student_id IS NOT NULL)', name='chk_aimodelrun_student_or_outsider'),
    sa.ForeignKeyConstraint(['job_id'], ['assessments.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['outsider_student_id'], ['outsider_students.id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('job_id', 'outsider_student_id', 'question_id', 'run_index', name='_job_outsider_question_run_uc'),
    sa.UniqueConstraint('job_id', 'student_id', 'question_id', 'run_index', name='_job_student_question_run_uc')
    )
    op.create_index(op.f('ix_ai_model_runs_job_id'), 'ai_model_runs', ['job_id'], unique=False)
    op.create_index(op.f('ix_ai_model_runs_outsider_student_id'), 'ai_model_runs', ['outsider_student_id'], unique=False)
    op.create_index(op.f('ix_ai_model_runs_question_id'), 'ai_model_runs', ['question_id'], unique=False)
    op.create_index(op.f('ix_ai_model_runs_student_id'), 'ai_model_runs', ['student_id'], unique=False)
    op.create_table('results',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('job_id', sa.String(), nullable=False),
    sa.Column('student_id', sa.String(), nullable=True),
    sa.Column('outsider_student_id', sa.String(), nullable=True),
    sa.Column('question_id', sa.String(), nullable=False),
    sa.Column('grade', sa.Float(), nullable=True),
    sa.Column('feedback', sa.String(), nullable=True),
    sa.Column('extractedAnswer', sa.String(), nullable=True),
    sa.Column('status', sa.String(), nullable=False),
    sa.Column('report_token', sa.String(), nullable=True),
    sa.Column('answer_sheet_path', sa.String(), nullable=True),
    sa.Column('content_type', sa.String(), nullable=True),
    sa.Column('finalized_by', sa.Enum('AI', 'TEACHER', name='finalizedby'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.Column('ai_responses', sa.JSON(), nullable=True),
    sa.CheckConstraint('(student_id IS NOT NULL AND outsider_student_id IS NULL) OR (student_id IS NULL AND outsider_student_id IS NOT NULL)', name='chk_result_student_or_outsider'),
    sa.ForeignKeyConstraint(['job_id'], ['assessments.id'], ),
    sa.ForeignKeyConstraint(['outsider_student_id'], ['outsider_students.id'], ),
    sa.ForeignKeyConstraint(['student_id'], ['students.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_results_id'), 'results', ['id'], unique=False)
    op.create_index(op.f('ix_results_report_token'), 'results', ['report_token'], unique=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_results_report_token'), table_name='results')
    op.drop_index(op.f('ix_results_id'), table_name='results')
    op.drop_table('results')
    op.drop_index(op.f('ix_ai_model_runs_student_id'), table_name='ai_model_runs')
    op.drop_index(op.f('ix_ai_model_runs_question_id'), table_name='ai_model_runs')
    op.drop_index(op.f('ix_ai_model_runs_outsider_student_id'), table_name='ai_model_runs')
    op.drop_index(op.f('ix_ai_model_runs_job_id'), table_name='ai_model_runs')
    op.drop_table('ai_model_runs')
    op.drop_index(op.f('ix_student_class_memberships_student_id'), table_name='student_class_memberships')
    op.drop_index(op.f('ix_student_class_memberships_id'), table_name='student_class_memberships')
    op.drop_index(op.f('ix_student_class_memberships_class_id'), table_name='student_class_memberships')
    op.drop_table('student_class_memberships')
    op.drop_index(op.f('ix_outsider_students_name'), table_name='outsider_students')
    op.drop_index(op.f('ix_outsider_students_assessment_id'), table_name='outsider_students')
    op.drop_table('outsider_students')
    op.drop_index(op.f('ix_chatmessages_id'), table_name='chatmessages')
    op.drop_table('chatmessages')
    op.drop_index(op.f('ix_generations_user_id'), table_name='generations')
    op.drop_index(op.f('ix_generations_tool_id'), table_name='generations')
    op.drop_index(op.f('ix_generations_id'), table_name='generations')
    op.drop_table('generations')
    op.drop_index(op.f('ix_classes_user_id'), table_name='classes')
    op.drop_index(op.f('ix_classes_name'), table_name='classes')
    op.drop_index(op.f('ix_classes_id'), table_name='classes')
    op.drop_table('classes')
    op.drop_index(op.f('ix_chatsessions_user_id'), table_name='chatsessions')
    op.drop_index(op.f('ix_chatsessions_id'), table_name='chatsessions')
    op.drop_table('chatsessions')
    op.drop_index(op.f('ix_assessments_user_id'), table_name='assessments')
    op.drop_index(op.f('ix_assessments_status'), table_name='assessments')
    op.drop_index(op.f('ix_assessments_id'), table_name='assessments')
    op.drop_table('assessments')
    op.drop_index(op.f('ix_users_full_name'), table_name='users')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_table('users')
    op.drop_index(op.f('ix_students_studentId'), table_name='students')
    op.drop_index(op.f('ix_students_name'), table_name='students')
    op.drop_index(op.f('ix_students_id'), table_name='students')
    op.drop_table('students')
    # ### end Alembic commands ###


--- File: .\ata-backend\app\main.py ---


# /ata-backend/app/main.py (SUPERVISOR-APPROVED FLAWLESS VERSION)

"""
This module is the main entry point and central assembler for the ATA Backend FastAPI application.

It is responsible for:
1. Creating the main FastAPI application instance.
2. Configuring application-wide settings, such as CORS middleware.
3. Managing application lifecycle events (startup and shutdown) via the `lifespan` manager.
4. Importing and including all the API routers from the `app.routers` package,
   effectively building the complete API structure.
"""

# --- Core FastAPI Imports ---
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

# --- Application-specific Router Imports ---
# Import all router objects that define the various API endpoint groups.
from .routers import (
    classes_router,
    assessments_router,
    assessment_review_router,
    tools_router,
    chatbot_router,
    dashboard_router,
    library_router,
    history_router,
    public_router,
    auth_router,
    students_router,
    page_count_router,
    admin_router
)

# --- Service Imports for Startup Logic ---
from .services import library_service
from .core import scheduler

# --- Application Lifecycle Management ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    An asynchronous context manager to handle application startup and shutdown events.
    """
    # This code runs ONCE when the application starts up.
    print("INFO:     Application startup: Initializing library cache...")
    library_service.initialize_library_cache()
    print("INFO:     Library cache initialized.")

    print("INFO:     Starting background scheduler...")
    scheduler.start_scheduler()
    print("INFO:     Background scheduler started.")

    yield  # The application runs while the context manager is active.

    # This code runs ONCE when the application shuts down.
    print("INFO:     Stopping background scheduler...")
    scheduler.stop_scheduler()
    print("INFO:     Application shutdown.")

# --- FastAPI Application Instance Creation ---
# This creates the main application object. The title, description, and version
# are used for the automatic OpenAPI (Swagger) documentation.
app = FastAPI(
    title="ATA Backend API",
    description="The intelligent engine for the AI Teaching Assistant platform.",
    version="1.0.0",
    lifespan=lifespan
)

# --- Middleware Configuration ---
# Configure Cross-Origin Resource Sharing (CORS) to allow requests from any
# origin. This is suitable for development and for a public API that will be
# consumed by a Vercel-hosted frontend.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["Content-Disposition"],  # Allow frontend to read this header for file downloads
)

# --- API Router Inclusion ---
# The order of inclusion here determines the order in the API documentation.

# --- [CRITICAL MODIFICATION 2/2: INCLUDE THE AUTH ROUTER] ---
# This line activates the /register and /token endpoints, making them live.
# They are placed first as they are the entry point for users.
app.include_router(auth_router.router, prefix="/api/auth", tags=["Authentication"])

# --- Admin Routes (Super Admin Only) ---
app.include_router(admin_router.router, prefix="/api/admin", tags=["Admin"])

# --- Protected API Routes (Require Authentication) ---
# All core business logic endpoints are grouped here. They are all protected
# by the `get_current_active_user` dependency defined within their respective files.
app.include_router(dashboard_router.router, prefix="/api/dashboard", tags=["Dashboard"])
app.include_router(classes_router.router, prefix="/api/classes", tags=["Classes & Students"])
app.include_router(students_router.router, prefix="/api/students", tags=["Students"])
app.include_router(assessment_review_router.router, prefix="/api/assessments", tags=["Assessments Review"])
app.include_router(assessments_router.router, prefix="/api/assessments", tags=["Assessments"])
app.include_router(tools_router.router, prefix="/api/tools", tags=["AI Tools"])
app.include_router(chatbot_router.router, prefix="/api/chatbot", tags=["Chatbot"])
app.include_router(library_router.router, prefix="/api/library", tags=["Curriculum Library"])
app.include_router(history_router.router, prefix="/api/history", tags=["Generation History"])
app.include_router(page_count_router.router, prefix="/api/page-count", tags=["Page Counting"])

# --- Publicly Accessible Routes (Do Not Require User Login) ---
# These routes are for resources that are intentionally public, like shareable reports.
app.include_router(public_router.router, prefix="/public", tags=["Public Resources"])

# --- Root / Health Check Endpoint ---
@app.get("/", tags=["Health Check"])
async def read_root():
    """
    A simple health check endpoint to confirm that the API is online and running.
    """
    return {"status": "ATA Backend is running!", "version": app.version}



--- File: .\ata-backend\app\__init__.py ---

 


--- File: .\ata-backend\app\core\admin_auth.py ---

# /ata-backend/app/core/admin_auth.py

"""
Admin authentication with hardcoded credentials.
This is a simple authentication mechanism for the super admin dashboard.
"""

from fastapi import HTTPException, status, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.core import security

# Hardcoded admin credentials
ADMIN_EMAIL = "mehran.gharuni.admin@admin.com"
ADMIN_PASSWORD = "s202f3d8458"

security_scheme = HTTPBearer()


def authenticate_admin(email: str, password: str) -> bool:
    """
    Authenticates admin with hardcoded credentials.

    Args:
        email: Email provided during login
        password: Password provided during login

    Returns:
        True if credentials match, False otherwise
    """
    return email == ADMIN_EMAIL and password == ADMIN_PASSWORD


def create_admin_token() -> str:
    """
    Creates a special JWT token for admin access.
    Uses a special subject identifier for admin.

    Returns:
        JWT access token
    """
    return security.create_access_token(subject="ADMIN_USER")


def verify_admin_token(credentials: HTTPAuthorizationCredentials = Depends(security_scheme)) -> bool:
    """
    Dependency to verify admin token in protected routes.

    Args:
        credentials: Bearer token from request header

    Raises:
        HTTPException: If token is invalid or not an admin token

    Returns:
        True if valid admin token
    """
    token = credentials.credentials
    user_id = security.decode_token(token)

    if not user_id or user_id != "ADMIN_USER":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin access required"
        )

    return True


--- File: .\ata-backend\app\core\deps.py ---

# /ata-backend/app/core/deps.py

"""
This module centralizes all common FastAPI dependencies for the application.

The primary dependency, `get_current_user`, is the gatekeeper for our entire
protected API. It is responsible for:
1. Extracting the JWT Bearer token from the request's Authorization header.
2. Decoding and validating the token using the functions in `core.security`.
3. Fetching the corresponding user from the database via the DatabaseService.
4. Raising a 401 Unauthorized HTTPException if any step fails.
5. Returning the full, validated User database object on success.

This ensures a consistent, secure, and efficient method for protecting API endpoints.
"""

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.core import security
from app.services.database_service import DatabaseService, get_db_service
from app.db.models.user_model import User as UserModel

# --- Dependency Configuration ---

# This creates an instance of the OAuth2 password flow.
# The `tokenUrl` points to the exact API endpoint that the client will use to
# obtain a token (i.e., the login endpoint). This is crucial for the
# interactive OpenAPI/Swagger documentation.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/token")

# --- The Main Security Dependency ---

def get_current_user(
    token: str = Depends(oauth2_scheme), 
    db: DatabaseService = Depends(get_db_service)
) -> UserModel:
    """
    A FastAPI dependency that verifies the JWT token from the request header
    and returns the corresponding user object from the database.

    This is the primary security gate for all protected endpoints.

    Args:
        token: The OAuth2 bearer token, injected by FastAPI from the request.
        db: The database service instance, injected by FastAPI.

    Raises:
        HTTPException(401): If the token is invalid, expired, malformed, or the
                            user associated with it does not exist.

    Returns:
        The SQLAlchemy User object for the authenticated user.
    """
    # Define a standard exception to be raised for all authentication failures.
    # This ensures a consistent error response for the client.
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    # 1. Decode the token to get the user ID (subject).
    user_id = security.decode_token(token)
    if user_id is None:
        # If decoding fails (invalid signature, expired, etc.), `decode_token`
        # returns None. We immediately raise the exception.
        raise credentials_exception
    
    # 2. Fetch the user from the database using the ID from the token.
    user = db.get_user_by_id(user_id=user_id)
    if user is None:
        # This is a critical security check. It handles the case where a token
        # might be valid, but the user has been deleted from the system since
        # the token was issued.
        raise credentials_exception
    
    # 3. Return the fully validated user object.
    return user


def get_current_active_user(
    current_user: UserModel = Depends(get_current_user)
) -> UserModel:
    """
    A secondary dependency that layers on top of `get_current_user`.

    It first ensures the user is authenticated, then checks if their account
    is marked as active. This is useful for endpoints that should not be
    accessible by deactivated users.

    Args:
        current_user: The user object, injected by the `get_current_user` dependency.

    Raises:
        HTTPException(403): If the user's account is inactive. A 403 Forbidden
                           is more semantically correct here than a 400.

    Returns:
        The active, authenticated SQLAlchemy User object.
    """
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Inactive user")
    return current_user

--- File: .\ata-backend\app\core\logger.py ---

# /ata-backend/app/core/logger.py

"""
Centralized logging configuration for the application.
Uses Python's logging module for production-ready logging.
"""

import logging
import sys
from pathlib import Path

# Create logs directory if it doesn't exist
logs_dir = Path("logs")
logs_dir.mkdir(exist_ok=True)

# Configure logging format
LOG_FORMAT = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
DATE_FORMAT = "%Y-%m-%d %H:%M:%S"

# Create formatters
formatter = logging.Formatter(LOG_FORMAT, DATE_FORMAT)

# Configure root logger
logging.basicConfig(
    level=logging.INFO,
    format=LOG_FORMAT,
    datefmt=DATE_FORMAT,
    handlers=[
        # Console handler - outputs to stdout
        logging.StreamHandler(sys.stdout),
        # File handler - writes to file
        logging.FileHandler(logs_dir / "app.log", encoding="utf-8")
    ]
)

def get_logger(name: str) -> logging.Logger:
    """
    Get a logger instance for a module.

    Args:
        name: Usually __name__ of the calling module

    Returns:
        Logger instance
    """
    return logging.getLogger(name)


--- File: .\ata-backend\app\core\scheduler.py ---

# /ata-backend/app/core/scheduler.py

"""
Background task scheduler for periodic maintenance tasks.
Uses APScheduler to run cleanup tasks automatically.
"""

import os
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
from sqlalchemy.orm import Session

from app.db.database import SessionLocal
from app.services.file_cleanup_service import get_cleanup_service


# Global scheduler instance
scheduler = BackgroundScheduler()


def cleanup_old_files_task():
    """
    Scheduled task to clean up old assessment files.
    Runs automatically based on the configured schedule.
    """
    db: Session = SessionLocal()
    try:
        # Get hours from environment variable, default to 12 hours
        hours_after_completion = int(os.getenv("FILE_CLEANUP_HOURS", "12"))

        print(f"\nðŸ§¹ Running scheduled file cleanup (files older than {hours_after_completion}h)...")

        cleanup_service = get_cleanup_service()
        stats = cleanup_service.cleanup_old_assessments(
            db=db,
            hours_after_completion=hours_after_completion,
            dry_run=False
        )

        print(f"âœ“ Cleanup complete:")
        print(f"  - Found: {stats['total_found']} eligible assessments")
        print(f"  - Deleted: {stats['deleted_count']} folders")
        print(f"  - Failed: {stats['failed_count']} folders")
        print(f"  - Space freed: {stats['space_freed_mb']} MB\n")

    except Exception as e:
        print(f"âœ— Error during scheduled cleanup: {str(e)}")
    finally:
        db.close()


def start_scheduler():
    """
    Start the background scheduler with all scheduled tasks.
    """
    # Get schedule from environment variable, default to every 6 hours
    # Format: "0 */6 * * *" means "run at minute 0 of every 6th hour"
    cleanup_schedule = os.getenv("FILE_CLEANUP_SCHEDULE", "0 */6 * * *")

    # Add the cleanup task
    scheduler.add_job(
        cleanup_old_files_task,
        trigger=CronTrigger.from_crontab(cleanup_schedule),
        id="file_cleanup",
        name="Clean up old assessment files",
        replace_existing=True
    )

    # Start the scheduler
    scheduler.start()
    print(f"ðŸ“… Scheduler started: File cleanup will run on schedule: {cleanup_schedule}")


def stop_scheduler():
    """
    Stop the background scheduler gracefully.
    """
    if scheduler.running:
        scheduler.shutdown()
        print("ðŸ“… Scheduler stopped")


--- File: .\ata-backend\app\core\security.py ---

# /ata-backend/app/core/security.py

"""
This module serves as the cryptographic core of the application.

It is responsible for all security-critical, pure functions, including:
- Hashing and verifying user passwords.
- Creating and decoding JSON Web Tokens (JWTs) for authentication.

This module is intentionally decoupled from the database and business logic layers.
It operates solely on the data provided to it and reads its configuration
from environment variables.
"""

import os
from datetime import datetime, timedelta, timezone
from typing import Optional, Any

from jose import JWTError, jwt
from passlib.context import CryptContext

# --- Configuration Loading ---
# Load secrets and configuration from environment variables for security and flexibility.

# The secret key used to sign JWTs. This MUST be kept secret.
# A fatal error is raised if this is not set, preventing insecure deployments.
SECRET_KEY = os.getenv("SECRET_KEY")
if not SECRET_KEY:
    raise ValueError("FATAL ERROR: SECRET_KEY environment variable is not set.")

# The algorithm used for JWT signing. HS256 is a standard choice.
ALGORITHM = os.getenv("ALGORITHM", "HS256")

# The duration for which an access token is valid, in minutes.
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", 60))


# --- Password Hashing ---
# Instantiate the password hashing context, specifying bcrypt as the default scheme.
# bcrypt is a strong, industry-standard hashing algorithm that includes salting.
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verifies a plain-text password against a stored hash.

    Args:
        plain_password: The password attempt from the user.
        hashed_password: The hash stored in the database.

    Returns:
        True if the password matches the hash, False otherwise.
    """
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """
    Hashes a plain-text password using bcrypt.

    Args:
        password: The plain-text password to hash.

    Returns:
        A secure bcrypt hash of the password.
    """
    return pwd_context.hash(password)


# --- JSON Web Token (JWT) Management ---

def create_access_token(subject: str | Any, expires_delta: Optional[timedelta] = None) -> str:
    """
    Creates a new JWT access token.

    Args:
        subject: The subject of the token, typically the user's unique ID.
        expires_delta: An optional timedelta to override the default expiration time.

    Returns:
        A signed JWT string.
    """
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode = {
        "exp": expire,
        "sub": str(subject)  # 'sub' (subject) is the standard claim for the user identifier
    }
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def decode_token(token: str) -> Optional[str]:
    """
    Decodes and validates a JWT.

    Args:
        token: The JWT string to decode.

    Returns:
        The subject (user ID) from the token's payload if the token is valid
        and not expired, otherwise None.
    """
    try:
        # The `jwt.decode` function automatically handles signature verification
        # and expiration checking.
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        
        # Extract the subject claim.
        subject = payload.get("sub")
        if subject is None:
            return None
        return subject
        
    except JWTError:
        # This exception is raised if the token is expired, has an invalid
        # signature, or is otherwise malformed.
        return None

--- File: .\ata-backend\app\db\base.py ---

# /ata-backend/app/db/base.py

"""
This module acts as the central registry for all SQLAlchemy ORM models.

Its sole purpose is to import all model classes into a single namespace. This
ensures that the shared `Base.metadata` object is fully populated with all
table definitions before being inspected by Alembic for database migration
generation.

Any new SQLAlchemy model created for the application MUST be imported here.
"""

# Import the Base class that all models inherit from. This provides the
# declarative base and the metadata container.
from .base_class import Base

# --- Application-Specific Model Imports ---

# Import all existing models to register them with the Base metadata.
from .models.class_student_models import Class, Student
from .models.assessment_models import Assessment, Result
from .models.ai_model_run import AIModelRun
from .models.chat_models import ChatSession, ChatMessage
from .models.generation_models import Generation

# --- [CRITICAL MODIFICATION FOR AUTHENTICATION] ---
# Import the new User model. This is the essential change that makes Alembic
# aware of the new `users` table, allowing it to correctly generate the
# database migration script for creating the table and linking foreign keys to it.
from .models.user_model import User

--- File: .\ata-backend\app\db\base_class.py ---

# /ata-backend/app/db/base_class.py (Corrected and Final Version)

from sqlalchemy.ext.declarative import as_declarative, declared_attr

@as_declarative()
class Base:
    """
    A base class for all SQLAlchemy models.
    It automatically generates a __tablename__ for each model.
    """
    id: any
    __name__: str
    
    # This is a helper that automatically creates a table name for any class
    # that inherits from this Base. For example, a class named 'Class' will
    # get a table named 'classes'. A class named 'Student' gets 'students'.
    @declared_attr
    def __tablename__(cls) -> str:
        return cls.__name__.lower() + "s"

--- File: .\ata-backend\app\db\database.py ---

# /ata-backend/app/db/database.py

import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# Get the database URL from the environment variable we set on Railway.
# The second argument is a default value for local development.
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./test.db")

# Create the SQLAlchemy engine.
# Configure connection pooling for production PostgreSQL to handle connection timeouts
if DATABASE_URL.startswith("sqlite"):
    engine_args = {"connect_args": {"check_same_thread": False}}
else:
    # PostgreSQL/Production settings
    engine_args = {
        "pool_pre_ping": True,  # Test connections before using them (fixes EOF errors)
        "pool_size": 10,  # Maximum number of connections to keep open
        "max_overflow": 20,  # Allow up to 20 additional connections beyond pool_size
        "pool_recycle": 3600,  # Recycle connections after 1 hour (3600 seconds)
        "pool_timeout": 30,  # Wait up to 30 seconds for a connection from the pool
        "connect_args": {
            "connect_timeout": 10,  # 10 second timeout for establishing new connections
            "options": "-c statement_timeout=30000"  # 30 second query timeout
        }
    }

engine = create_engine(DATABASE_URL, **engine_args)

# Create a SessionLocal class. Each instance of this class will be a database session.
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create a Base class. Our database model classes will inherit from this.
Base = declarative_base()

# Dependency to get a DB session. This will be used in our API routers.
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

--- File: .\ata-backend\app\db\__init__.py ---



--- File: .\ata-backend\app\db\models\ai_model_run.py ---

import uuid
from sqlalchemy import Column, String, Text, SmallInteger, DateTime, ForeignKey, UniqueConstraint, Numeric, CheckConstraint
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.sql import func
from ..base_class import Base

class AIModelRun(Base):
    __tablename__ = 'ai_model_runs'

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    job_id = Column(String, ForeignKey('assessments.id', ondelete='CASCADE'), nullable=False, index=True)

    # An AI run can be linked to a rostered student OR an outsider student
    student_id = Column(String, ForeignKey('students.id', ondelete='CASCADE'), nullable=True, index=True)
    outsider_student_id = Column(String, ForeignKey('outsider_students.id', ondelete='CASCADE'), nullable=True, index=True)

    question_id = Column(String, nullable=False, index=True)
    run_index = Column(SmallInteger, nullable=False)

    raw_json = Column(JSONB, nullable=False)
    grade = Column(Numeric(10, 2), nullable=True)
    comment = Column(Text, nullable=True)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)

    __table_args__ = (
        UniqueConstraint('job_id', 'student_id', 'question_id', 'run_index', name='_job_student_question_run_uc'),
        UniqueConstraint('job_id', 'outsider_student_id', 'question_id', 'run_index', name='_job_outsider_question_run_uc'),
        CheckConstraint(
            '(student_id IS NOT NULL AND outsider_student_id IS NULL) OR '
            '(student_id IS NULL AND outsider_student_id IS NOT NULL)',
            name='chk_aimodelrun_student_or_outsider'
        ),
    )

--- File: .\ata-backend\app\db\models\assessment_models.py ---

# /ata-backend/app/db/models/assessment_models.py (MODIFIED AND APPROVED)

"""
This module defines the SQLAlchemy ORM models for the `Assessment` and `Result`
entities, which represent grading jobs and their individual outcomes, respectively.
"""

import enum
from sqlalchemy import Column, String, Float, JSON, DateTime, ForeignKey, Enum as SAEnum, CheckConstraint
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
# --- [CRITICAL MODIFICATION] ---
# Import the UUID type from SQLAlchemy's PostgreSQL dialects. This is necessary
# to ensure the `user_id` foreign key column has the exact same data type as
# the `User.id` primary key it points to.
from sqlalchemy.dialects.postgresql import UUID

from ..base_class import Base

class Assessment(Base):
    """
    SQLAlchemy model representing a top-level assessment (grading job).

    This model is now linked to a User, establishing the core ownership
    for the entire assessment feature.
    """
    id = Column(String, primary_key=True, index=True)
    status = Column(String, index=True, nullable=False)
    config = Column(JSON, nullable=False)
    answer_sheet_paths = Column(JSON, nullable=True)
    ai_summary = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    total_pages = Column(Float, nullable=True)  # Total pages across all student submissions

    # --- [CRITICAL MODIFICATION 1/2: THE PHYSICAL LINK] ---
    # This column creates the foreign key relationship to the `users` table.
    # - UUID(as_uuid=True): Ensures type compatibility with the User.id primary key.
    # - ForeignKey("users.id"): The database-level constraint.
    # - nullable=False: Guarantees every assessment has an owner.
    # - index=True: Optimizes database lookups for a user's assessments.
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)

    # --- [CRITICAL MODIFICATION 2/2: THE LOGICAL LINK] ---
    # This SQLAlchemy relationship allows for easy, object-oriented access
    # to the owning User object from an Assessment instance (e.g., `my_assessment.owner`).
    # `back_populates="assessments"` creates a two-way link with the `assessments`
    # relationship defined in the `user_model.py` file.
    owner = relationship("User", back_populates="assessments")

    # This relationship remains unchanged. When an Assessment is deleted, all its
    # child Result records are also deleted due to the cascade option.
    results = relationship("Result", back_populates="assessment", cascade="all, delete-orphan")
    outsider_students = relationship("OutsiderStudent", back_populates="assessment", cascade="all, delete-orphan")


class ResultStatus(str, enum.Enum):
    PROCESSING = "PROCESSING"
    AI_GRADED = "AI_GRADED"
    PENDING_REVIEW = "PENDING_REVIEW"
    TEACHER_GRADED = "TEACHER_GRADED"
    FAILED = "FAILED"

class FinalizedBy(str, enum.Enum):
    AI = "AI"
    TEACHER = "TEACHER"

class Result(Base):
    """
    SQLAlchemy model representing the grade and feedback for a single question
    for a single student within an Assessment.
    """
    __tablename__ = "results"
    id = Column(String, primary_key=True, index=True)
    job_id = Column(String, ForeignKey("assessments.id"), nullable=False)
    student_id = Column(String, ForeignKey("students.id"), nullable=True)  # Made nullable
    outsider_student_id = Column(String, ForeignKey("outsider_students.id"), nullable=True)  # New column
    question_id = Column(String, nullable=False)
    
    grade = Column(Float, nullable=True)
    feedback = Column(String, nullable=True)
    extractedAnswer = Column(String, nullable=True)
    status = Column(String, nullable=False, default='pending') # Will be updated by migration
    report_token = Column(String, unique=True, index=True, nullable=True)
    answer_sheet_path = Column(String, nullable=True)
    content_type = Column(String, nullable=True)
    
    # New Columns
    finalized_by = Column(SAEnum(FinalizedBy, name="finalizedby"), nullable=True)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    # Relationships
    assessment = relationship("Assessment", back_populates="results")
    student = relationship("Student")
    outsider_student = relationship("OutsiderStudent", back_populates="results")

    ai_responses = Column(JSON, nullable=True)

    __table_args__ = (
        CheckConstraint(
            '(student_id IS NOT NULL AND outsider_student_id IS NULL) OR '
            '(student_id IS NULL AND outsider_student_id IS NOT NULL)',
            name='chk_result_student_or_outsider'
        ),
    )

--- File: .\ata-backend\app\db\models\chat_models.py ---

# /ata-backend/app/db/models/chat_models.py (MODIFIED AND APPROVED)

"""
This module defines the SQLAlchemy ORM models for the `ChatSession` and
`ChatMessage` entities, which represent a user's conversation and its
individual messages, respectively.
"""

from sqlalchemy import Column, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
# --- [CRITICAL MODIFICATION] ---
# Import the UUID type from SQLAlchemy's PostgreSQL dialects. This is necessary
# to ensure the `user_id` foreign key column has the exact same data type as
# the `User.id` primary key it points to.
from sqlalchemy.dialects.postgresql import UUID

from ..base_class import Base

class ChatSession(Base):
    """
    SQLAlchemy model representing a top-level chat session.

    This model is now correctly linked to a User via a proper foreign key,
    enforcing data integrity and establishing ownership.
    """
    __tablename__ = "chatsessions" # Override automatic pluralization

    id = Column(String, primary_key=True, index=True)
    
    # --- [CRITICAL MODIFICATION 1/2: THE PHYSICAL LINK] ---
    # The original `user_id` column has been upgraded to a proper foreign key.
    # - UUID(as_uuid=True): Ensures type compatibility with the User.id primary key.
    # - ForeignKey("users.id"): The database-level constraint.
    # - nullable=False: Guarantees every chat session has an owner.
    # - index=True: Optimizes database lookups for a user's chat sessions.
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    
    name = Column(String, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # --- [CRITICAL MODIFICATION 2/2: THE LOGICAL LINK] ---
    # This SQLAlchemy relationship allows for easy, object-oriented access
    # to the owning User object from a ChatSession instance (e.g., `my_session.owner`).
    # `back_populates="chat_sessions"` creates a two-way link with the `chat_sessions`
    # relationship defined in the `user_model.py` file.
    owner = relationship("User", back_populates="chat_sessions")

    # This relationship remains unchanged. When a ChatSession is deleted, all its
    # child ChatMessage records are also deleted due to the cascade option.
    messages = relationship("ChatMessage", back_populates="session", cascade="all, delete-orphan")


# --- [NO MODIFICATIONS REQUIRED FOR CHATMESSAGE MODEL] ---
# The ChatMessage model's ownership is correctly inferred through its parent
# ChatSession. It does not need a direct link to the user.
class ChatMessage(Base):
    """
    SQLAlchemy model representing a single message within a ChatSession.
    """
    __tablename__ = "chatmessages" # Override automatic pluralization

    id = Column(String, primary_key=True, index=True)
    session_id = Column(String, ForeignKey("chatsessions.id"), nullable=False)
    role = Column(String, nullable=False) # 'user' or 'bot'
    content = Column(String, nullable=False)
    file_id = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationship to Session remains unchanged.
    session = relationship("ChatSession", back_populates="messages")

--- File: .\ata-backend\app\db\models\class_student_models.py ---

# /ata-backend/app/db/models/class_student_models.py (MODIFIED FOR MANY-TO-MANY)

"""
This module defines the SQLAlchemy ORM models for the `Class` and `Student`
entities, which represent a teacher's class roster and the individual students
within it.

Now supports many-to-many relationships through StudentClassMembership junction table.
"""

from sqlalchemy import Column, String, Integer, ForeignKey, UniqueConstraint
from sqlalchemy.orm import relationship
# --- [CRITICAL MODIFICATION] ---
# Import the UUID type from SQLAlchemy's PostgreSQL dialects. This is necessary
# to ensure the `user_id` foreign key column has the exact same data type as
# the `User.id` primary key it points to.
from sqlalchemy.dialects.postgresql import UUID

from ..base_class import Base

class Class(Base):
    """
    SQLAlchemy model representing a class or course.

    This model is now linked to a User, establishing the core ownership
    for all roster-related data. A user owns a class, and a class contains students.
    """
    __tablename__ = "classes"

    id = Column(String, primary_key=True, index=True)
    name = Column(String, index=True, nullable=False)
    description = Column(String, nullable=True)
    
    # --- [CRITICAL MODIFICATION 1/2: THE PHYSICAL LINK] ---
    # This column creates the foreign key relationship to the `users` table.
    # - UUID(as_uuid=True): Ensures type compatibility with the User.id primary key.
    # - ForeignKey("users.id"): The database-level constraint.
    # - nullable=False: Guarantees every class has an owner.
    # - index=True: Optimizes database lookups for a user's classes.
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)

    # --- [CRITICAL MODIFICATION 2/2: THE LOGICAL LINK] ---
    # This SQLAlchemy relationship allows for easy, object-oriented access
    # to the owning User object from a Class instance (e.g., `my_class.owner`).
    # `back_populates="classes"` creates a two-way link with the `classes`
    # relationship defined in the `user_model.py` file.
    owner = relationship("User", back_populates="classes")

    # Many-to-many relationship with Students through StudentClassMembership
    student_memberships = relationship("StudentClassMembership", back_populates="class_", cascade="all, delete-orphan")
    students = relationship("Student", secondary="student_class_memberships", viewonly=True)


class Student(Base):
    """
    SQLAlchemy model representing a single student.
    Can belong to multiple classes through StudentClassMembership.
    """
    __tablename__ = "students"

    id = Column(String, primary_key=True, index=True)
    name = Column(String, index=True, nullable=False)
    studentId = Column(String, unique=True, index=True, nullable=False)

    overallGrade = Column(Integer, nullable=True)
    performance_summary = Column(String, nullable=True)

    # Many-to-many relationship with Classes through StudentClassMembership
    class_memberships = relationship("StudentClassMembership", back_populates="student", cascade="all, delete-orphan")
    classes = relationship("Class", secondary="student_class_memberships", viewonly=True)


class StudentClassMembership(Base):
    """
    Junction table for the many-to-many relationship between Students and Classes.
    """
    __tablename__ = "student_class_memberships"

    id = Column(String, primary_key=True, index=True)
    student_id = Column(
        String,
        ForeignKey("students.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    class_id = Column(
        String,
        ForeignKey("classes.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )

    # Relationships
    student = relationship("Student", back_populates="class_memberships")
    class_ = relationship("Class", back_populates="student_memberships")

    # Ensure each student-class pair is unique
    __table_args__ = (
        UniqueConstraint("student_id", "class_id", name="uq_student_class"),
    )

--- File: .\ata-backend\app\db\models\generation_models.py ---

# /ata-backend/app/db/models/generation_models.py (MODIFIED AND APPROVED)

"""
This module defines the SQLAlchemy ORM model for the `Generation` entity,
which represents a saved output from one of the AI content generation tools.
"""

from sqlalchemy import Column, String, JSON, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
# --- [CRITICAL MODIFICATION] ---
# Import the UUID type from SQLAlchemy's PostgreSQL dialects. This is necessary
# to ensure the `user_id` foreign key column has the exact same data type as
# the `User.id` primary key it points to.
from sqlalchemy.dialects.postgresql import UUID

from ..base_class import Base

class Generation(Base):
    """
    SQLAlchemy model representing a single saved AI tool generation.

    This model is now linked to a User, ensuring that each piece of generated
    content in the history is privately owned.
    """
    id = Column(String, primary_key=True, index=True)
    title = Column(String, nullable=False)
    tool_id = Column(String, index=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    settings_snapshot = Column(JSON, nullable=False)
    generated_content = Column(String, nullable=False)

    # --- [CRITICAL MODIFICATION 1/2: THE PHYSICAL LINK] ---
    # This column creates the foreign key relationship to the `users` table.
    # - UUID(as_uuid=True): Ensures type compatibility with the User.id primary key.
    # - ForeignKey("users.id"): The database-level constraint.
    # - nullable=False: Guarantees every saved generation has an owner.
    # - index=True: Optimizes database lookups for a user's history.
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)

    # --- [CRITICAL MODIFICATION 2/2: THE LOGICAL LINK] ---
    # This SQLAlchemy relationship allows for easy, object-oriented access
    # to the owning User object from a Generation instance (e.g., `my_generation.owner`).
    # `back_populates="generations"` creates a two-way link with the `generations`
    # relationship defined in the `user_model.py` file.
    owner = relationship("User", back_populates="generations")

--- File: .\ata-backend\app\db\models\outsider_student.py ---

import uuid
from sqlalchemy import Column, String, ForeignKey
from sqlalchemy.orm import relationship
from app.db.base_class import Base

class OutsiderStudent(Base):
    __tablename__ = 'outsider_students'

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    name = Column(String, nullable=False, index=True)
    assessment_id = Column(String, ForeignKey('assessments.id'), nullable=False, index=True)

    assessment = relationship("Assessment", back_populates="outsider_students")
    results = relationship("Result", back_populates="outsider_student")

--- File: .\ata-backend\app\db\models\student_class_membership.py ---

# /ata-backend/app/db/models/student_class_membership.py

"""
This module defines the SQLAlchemy ORM model for the StudentClassMembership
junction table, which enables many-to-many relationships between Students and Classes.

This allows a single student to belong to multiple classes simultaneously.
"""

from sqlalchemy import Column, String, ForeignKey, UniqueConstraint
from sqlalchemy.orm import relationship

from ..base_class import Base


class StudentClassMembership(Base):
    """
    SQLAlchemy model representing the many-to-many relationship between
    Students and Classes.
    """
    __tablename__ = "student_class_memberships"

    id = Column(String, primary_key=True, index=True)
    student_id = Column(
        String,
        ForeignKey("students.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    class_id = Column(
        String,
        ForeignKey("classes.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )

    # Relationships
    student = relationship("Student", back_populates="class_memberships")
    class_ = relationship("Class", back_populates="student_memberships")

    # Ensure each student-class pair is unique
    __table_args__ = (
        UniqueConstraint("student_id", "class_id", name="uq_student_class"),
    )


--- File: .\ata-backend\app\db\models\user_model.py ---

# /ata-backend/app/db/models/user_model.py

"""
This module defines the SQLAlchemy ORM model for the `User` entity.

The User model is the cornerstone of the authentication and multi-tenancy system.
It defines the `users` table schema, which stores user credentials and profile
information. It also establishes the critical one-to-many relationships that link
a user to all the data they own within the application (e.g., Classes, Assessments).
"""

import uuid
from sqlalchemy import Column, String, Boolean, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from ..base_class import Base

class User(Base):
    """
    SQLAlchemy model representing a user in the database.
    """
    __tablename__ = "users"

    # --- Columns ---

    # The primary key, using a native database UUID type for performance and uniqueness.
    # The default value is generated by Python's uuid.uuid4 function on record creation.
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # The user's email address, which is used for logging in.
    # It is unique and indexed for fast lookups.
    email = Column(String, unique=True, index=True, nullable=False)
    
    # The user's full name, for display purposes.
    full_name = Column(String, index=True, nullable=True)
    
    # The securely hashed version of the user's password.
    # Plain-text passwords are NEVER stored.
    hashed_password = Column(String, nullable=False)
    
    # A flag to enable or disable an account without deleting it.
    is_active = Column(Boolean(), default=True, nullable=False)
    
    # Timestamps for auditing, automatically managed by the database server.
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())


    # --- Relationships ---

    # Defines the one-to-many relationship from a User to their Classes.
    # `back_populates` links this to the `owner` relationship on the `Class` model.
    # `cascade` ensures that when a user is deleted, all of their classes are also
    # deleted automatically by the database, maintaining data integrity.
    classes = relationship(
        "Class", 
        back_populates="owner", 
        cascade="all, delete-orphan"
    )

    # Defines the one-to-many relationship to a user's Assessment jobs.
    assessments = relationship(
        "Assessment",
        back_populates="owner",
        cascade="all, delete-orphan"
    )
    
    # Defines the one-to-many relationship to a user's Chat Sessions.
    chat_sessions = relationship(
        "ChatSession",
        back_populates="owner",
        cascade="all, delete-orphan"
    )

    # Defines the one-to-many relationship to a user's saved AI Tool Generations.
    generations = relationship(
        "Generation",
        back_populates="owner",
        cascade="all, delete-orphan"
    )

--- File: .\ata-backend\app\db\models\__init__.py ---

from .user_model import User
from .class_student_models import Class, Student, StudentClassMembership
from .assessment_models import Assessment, Result
from .outsider_student import OutsiderStudent
from .chat_models import ChatSession, ChatMessage
from .generation_models import Generation
from .ai_model_run import AIModelRun

--- File: .\ata-backend\app\models\assessment_model.py ---

# /ata-backend/app/models/assessment_model.py (DEFINITIVELY CORRECTED)

from pydantic import BaseModel, Field, field_validator, ConfigDict
from typing import Optional, List, Dict, Union, Any, Literal
from enum import Enum
import uuid

def to_camel(s: str) -> str:
    parts = s.split('_')
    return parts[0] + ''.join(p.capitalize() for p in parts[1:])

# --- Core Enumerations ---
class JobStatus(str, Enum):
    QUEUED = "Queued"; PROCESSING = "Processing"; SUMMARIZING = "Summarizing"
    PENDING_REVIEW = "Pending Review"; COMPLETED = "Completed"; FAILED = "Failed"
    
class ScoringMethod(str, Enum):
    PER_QUESTION = "per_question"; PER_SECTION = "per_section"; TOTAL_SCORE = "total_score"

class GradingMode(str, Enum):
    ANSWER_KEY_PROVIDED = "answer_key_provided"
    AI_AUTO_GRADE = "ai_auto_grade"
    LIBRARY = "library"

# --- API Contract Models ---

class QuestionConfig(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: str = Field(default_factory=lambda: f"q_{uuid.uuid4().hex[:8]}")
    text: str = Field(..., min_length=1)
    rubric: str = Field(..., description="The specific grading rubric for this question. Can be an empty string.")
    maxScore: int = Field(default=10, gt=0)

class AssessmentConfig(BaseModel):
    # This model is for incoming data, so it doesn't strictly need from_attributes,
    # but adding it is harmless and good for consistency.
    model_config = ConfigDict(from_attributes=True)
    assessmentName: str
    classId: str
    questions: List[QuestionConfig] = Field(..., min_length=1)
    includeImprovementTips: bool = Field(default=False)

    @field_validator('questions')
    @classmethod
    def questions_must_not_be_empty(cls, v):
        if not v: raise ValueError('Assessment must have at least one question.')
        return v

class QuestionConfigV2(QuestionConfig):
    model_config = ConfigDict(from_attributes=True)
    maxScore: Optional[int] = Field(None, gt=0)
    answer: Optional[Union[str, Dict[str, Any]]] = Field(None, description="The correct answer, which can be a string or a structured object.")

class SectionConfigV2(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: str = Field(default_factory=lambda: f"sec_{uuid.uuid4().hex[:8]}")
    title: str = Field(default="Main Section")
    total_score: Optional[int] = Field(None, gt=0)
    questions: List[QuestionConfigV2] = Field(..., min_length=1)

class AssessmentConfigV2(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    assessmentName: str
    classId: str
    scoringMethod: ScoringMethod
    totalScore: Optional[int] = Field(None, gt=0)
    sections: List[SectionConfigV2] = Field(..., min_length=1)
    includeImprovementTips: bool = Field(default=False)
    gradingMode: GradingMode = Field(default=GradingMode.ANSWER_KEY_PROVIDED)
    librarySource: Optional[str] = Field(None)

class AssessmentJobResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    jobId: str; status: JobStatus; message: str

class StudentForGrading(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: str; name: str; answerSheetPath: str

class GradingResult(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    grade: Optional[float] = None; feedback: Optional[str] = None
    extractedAnswer: Optional[str] = None; status: str

class Analytics(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    classAverage: float; medianGrade: float
    gradeDistribution: Dict[str, int]; performanceByQuestion: Dict[str, float]

class AssessmentResultsResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    jobId: str; assessmentName: str; status: JobStatus
    config: AssessmentConfigV2
    students: List[StudentForGrading]
    results: Dict[str, Dict[str, GradingResult]]
    analytics: Optional[Analytics] = None
    aiSummary: Optional[str] = None

class AssessmentJobSummary(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: str; assessmentName: str; className: str
    createdAt: str; status: JobStatus
    progress: Optional[Dict[str, int]] = None
    totalPages: Optional[float] = None

class AssessmentJobListResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    assessments: List[AssessmentJobSummary]

class AssessmentConfigResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    assessmentName: str
    questions: List[QuestionConfig]
    includeImprovementTips: bool

# --- Models for Review Workflow ---

class ReviewStatus(str, Enum):
    AI_GRADED = "AI_GRADED"
    PENDING_REVIEW = "PENDING_REVIEW"
    TEACHER_GRADED = "TEACHER_GRADED"

class FinalizedBy(str, Enum):
    AI = "AI"
    TEACHER = "TEACHER"

class StudentAIGradedSummary(BaseModel):
    model_config = ConfigDict(from_attributes=True, alias_generator=to_camel, populate_by_name=True)
    student_id: str
    name: str
    total_score: float

class StudentPendingSummary(BaseModel):
    model_config = ConfigDict(from_attributes=True, alias_generator=to_camel, populate_by_name=True)
    student_id: str
    name: str
    num_pending: int

class AssessmentResultsOverviewResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True, alias_generator=to_camel, populate_by_name=True)
    job_id: str
    assessment_name: str
    status: JobStatus
    students_ai_graded: List[StudentAIGradedSummary]
    students_pending: List[StudentPendingSummary]
    students: List['StudentResultRow'] = []

class QuestionForReview(BaseModel):
    model_config = ConfigDict(from_attributes=True, alias_generator=to_camel, populate_by_name=True)
    question_id: str
    question_text: str
    max_score: int
    student_answer: Optional[str] = None
    status: str
    grade: Optional[float] = None
    feedback: Optional[str] = None

class StudentReviewResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True, alias_generator=to_camel, populate_by_name=True)
    job_id: str
    student_id: str
    student_name: str
    assessment_name: str
    config: AssessmentConfigV2
    per_question: List[QuestionForReview]

class QuestionSaveRequest(BaseModel):
    grade: float
    feedback: str

class StudentSaveConfirmation(BaseModel):
    model_config = ConfigDict(from_attributes=True, alias_generator=to_camel, populate_by_name=True)
    student_id: str
    total_score: float
    message: str = "Changes saved successfully."

class CamelModel(BaseModel):
    model_config = ConfigDict(
        from_attributes=True,
        alias_generator=to_camel,
        populate_by_name=True,
    )

class StudentResultRow(CamelModel):
    entity_id: str  # The stable, unique DB ID for API calls
    student_id: str # The display ID, which could be 'Outsider'
    student_name: str
    status: Literal["AI_GRADED", "PENDING_REVIEW", "TEACHER_GRADED", "ABSENT", "OUTSIDER"]
    total_score: Optional[float] = None
    max_total_score: Optional[float] = None
    report_token: Optional[str] = None
    is_outsider: bool = False
    is_absent: bool = False

class ScoreDistributionRequest(BaseModel):
    config: AssessmentConfigV2
    totalMarks: int

--- File: .\ata-backend\app\models\chatbot_model.py ---

# /ata-backend/app/models/chatbot_model.py (DEFINITIVELY CORRECTED & MODERNIZED)

from pydantic import BaseModel, Field, ConfigDict
from typing import List, Optional
from datetime import datetime

class ChatMessage(BaseModel):
    # This tells Pydantic to allow creating this model from an object's attributes.
    model_config = ConfigDict(from_attributes=True)

    role: str = Field(..., description="The role of the message author, either 'user' or 'bot'.")
    content: str = Field(..., description="The text content of the message.")
    file_id: Optional[str] = Field(None, description="An optional ID for a file associated with this message.")

class ChatSessionSummary(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: str = Field(..., description="The unique ID of the chat session.")
    name: str = Field(..., description="The auto-generated name of the chat session.")
    created_at: datetime = Field(..., description="The timestamp when the session was created.")

class ChatSessionDetail(ChatSessionSummary):
    # This model inherits the config from ChatSessionSummary, so it's also covered.
    history: List[ChatMessage] = Field(..., description="The complete list of messages in the conversation.")

class NewChatSessionRequest(BaseModel):
    """
    Defines the request body for creating a new chat session.
    PURPOSE: Used by the POST /api/chat/sessions endpoint.
    """
    # --- [THE FIX IS HERE] ---
    # This is the complete and correct Pydantic V2 configuration.
    model_config = ConfigDict(
        populate_by_name=True,
        json_schema_extra={
            "example": {
                "firstMessage": "What was the class average on the Mid-Term Exam?",
                "fileId": "file_abc123"
            }
        }
    )
    # --- [END OF FIX] ---

    first_message: str = Field(..., alias="firstMessage")
    file_id: Optional[str] = Field(None, alias="fileId")

class CreateChatSessionResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    sessionId: str = Field(..., description="The unique ID of the newly created chat session.")

--- File: .\ata-backend\app\models\class_model.py ---

# /app/models/class_model.py

# --- Core Imports ---
from pydantic import BaseModel, Field
from typing import List, Optional

# --- Local Imports ---
from . import student_model

# --- Model Definitions ---

class ClassBase(BaseModel):
    """
    The base model for a Class.
    """
    name: str = Field(..., min_length=3, max_length=100, description="The user-defined name of the class.")
    description: Optional[str] = Field(default=None, max_length=500, description="An optional description for the class.")

class ClassCreate(ClassBase):
    """
    The model used for creating a new class.
    """
    pass

class Class(ClassBase):
    """
    The full representation of a Class resource, including server-generated fields.
    """
    id: str = Field(..., description="The unique, server-generated identifier for the class.")
    class Config:
        from_attributes = True

class ClassSummary(Class):
    """
    An extended model for the 'Your Classes' grid view, including student count.
    """
    studentCount: int = Field(..., description="The total number of students enrolled in this class.")
    class Config:
        from_attributes = True
    

class ClassAnalytics(BaseModel):
    """A sub-model for class-specific analytics data."""
    studentCount: int
    classAverage: int
    assessmentsGraded: int
    class Config:
        from_attributes = True

class ClassDetails(Class):
    """
    The comprehensive model for the 'Class Details' page.
    """
    students: List[student_model.Student]
    analytics: ClassAnalytics
    class Config:
        from_attributes = True

class ClassUploadResponse(BaseModel):
    """
    Defines the response contract for a successful roster file upload.
    """
    message: str
    
    # <<< CORRECTION: Simplified the field name to avoid alias issues.
    # The key in the final JSON response will now be 'class_info'.
    # The service layer will return a dictionary with a matching 'class_info' key.
    class_info: ClassSummary
    class Config:
        from_attributes = True

--- File: .\ata-backend\app\models\dashboard_model.py ---

# /app/models/dashboard_model.py (CORRECTED TO MODERN PydANTIC V2 SYNTAX)

# --- Core Imports ---
from pydantic import BaseModel, Field, ConfigDict

# --- Model Definition ---

class DashboardSummary(BaseModel):
    """
    Defines the data contract for the response of the dashboard summary endpoint.
    This model specifies the exact shape of the data that will be sent to the
    Home Page to populate its "Quick Info Cards".
    """
    # --- [THE FIX IS HERE] ---
    # The example is now part of the model_config, which is the modern syntax.
    # from_attributes is NOT needed here, as explained above.
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "classCount": 4,
                "studentCount": 112
            }
        }
    )
    # --- [END OF FIX] ---

    classCount: int = Field(
        ...,
        description="The total number of active classes for the user."
    )
    
    studentCount: int = Field(
        ...,
        description="The total number of students enrolled across all of the user's classes."
    )

--- File: .\ata-backend\app\models\history_model.py ---

# /ata-backend/app/models/history_model.py (DEFINITIVELY CORRECTED)

from pydantic import BaseModel, Field, ConfigDict
from typing import Dict, Any, List
from datetime import datetime # <<< ADD THIS IMPORT

# Import ToolId for strong validation, using our established relative import path
from .tool_model import ToolId

class GenerationRecord(BaseModel):
    """
    Defines the data contract for a single generation history record
    when it is retrieved from the database.
    """
    model_config = ConfigDict(from_attributes=True)

    id: str
    title: str
    tool_id: ToolId
    
    # --- [THE FIX IS HERE] ---
    # The data type is now correctly defined as `datetime`.
    # FastAPI will automatically serialize this to an ISO 8601 string in the JSON response.
    created_at: datetime
    # --- [END OF FIX] ---
    
    # The settings_snapshot is a dictionary, parsed from a JSON string by the service.
    settings_snapshot: Dict[str, Any] 
    generated_content: str

class HistoryResponse(BaseModel):
    """
    Defines the data contract for the GET /api/history response.
    """
    model_config = ConfigDict(from_attributes=True)

    results: List[GenerationRecord]
    total: int
    page: int
    hasNextPage: bool

class GenerationCreate(BaseModel):
    """
    Defines the contract for the data required to save a new generation.
    This model is for incoming requests and does not need to be changed.
    """
    model_config = ConfigDict(populate_by_name=True)

    tool_id: ToolId
    settings: Dict[str, Any]
    generated_content: str

--- File: .\ata-backend\app\models\student_model.py ---

# /ata-backend/app/models/student_model.py (CORRECTED WITH Pydantic V2 CONFIG)

# --- Core Imports ---
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, List
from datetime import datetime

# --- Model Definitions ---

class StudentBase(BaseModel):
    """
    The base model for a Student. Contains fields common to create and read operations.
    """
    name: str = Field(..., min_length=2, description="The full name of the student.")
    studentId: str = Field(..., description="The official, user-provided ID number for the student.")

class StudentCreate(StudentBase):
    """The model used for creating a new student. Inherits all fields from the base."""
    pass

class StudentUpdate(BaseModel):
    """
    The model for updating a student. All fields are optional to allow for
    partial updates.
    """
    # --- [THE FIX IS HERE] ---
    model_config = ConfigDict(from_attributes=True)
    # --- [END OF FIX] ---

    name: Optional[str] = Field(default=None, min_length=2)
    studentId: Optional[str] = Field(default=None)
    overallGrade: Optional[int] = Field(default=None)
    performance_summary: Optional[str] = Field(default=None)

class Student(StudentBase):
    """
    The full representation of a Student resource, as it is stored in the
    database and returned by the API.
    Note: class_id removed - students can now belong to multiple classes.
    """
    # --- [THE FIX IS HERE] ---
    model_config = ConfigDict(from_attributes=True)
    # --- [END OF FIX] ---

    id: str = Field(..., description="The unique, server-generated identifier for the student.")
    overallGrade: int = Field(
        default=0,
        description="The student's current overall grade. Defaults to 0 for new students."
    )
    performance_summary: Optional[str] = Field(
        default=None,
        description="An AI-generated summary of the student's performance (V2 feature)."
    )


# --- Student Transcript Models ---

class ClassInfo(BaseModel):
    """Information about a class the student is enrolled in."""
    model_config = ConfigDict(from_attributes=True)

    id: str
    name: str


class StudentAssessmentRow(BaseModel):
    """Represents one assessment in a student's transcript."""
    model_config = ConfigDict(from_attributes=True)

    jobId: str = Field(..., description="The assessment ID")
    assessmentName: str = Field(..., description="Name of the assessment")
    classId: str = Field(..., description="ID of the class this assessment belongs to")
    className: str = Field(..., description="Name of the class")
    createdAt: Optional[str] = Field(None, description="Date the assessment was created (ISO format)")
    totalScore: Optional[float] = Field(None, description="Student's total score")
    maxTotalScore: float = Field(..., description="Maximum possible score")
    status: str = Field(..., description="GRADED, PENDING_REVIEW, or ABSENT")
    reportUrl: Optional[str] = Field(None, description="URL to download the report")


class ClassTranscript(BaseModel):
    """Transcript data for a single class."""
    model_config = ConfigDict(from_attributes=True)

    classId: str
    className: str
    averagePercent: Optional[float] = Field(None, description="Average grade in this class")
    assessments: List[StudentAssessmentRow] = Field(default_factory=list)


class StudentTranscriptResponse(BaseModel):
    """Complete transcript response for a student across all classes."""
    model_config = ConfigDict(from_attributes=True)

    id: str
    studentId: str
    name: str
    overallAveragePercent: Optional[float] = Field(None, description="Overall average across all classes")
    classSummaries: List[ClassTranscript] = Field(default_factory=list, description="Per-class breakdown")

--- File: .\ata-backend\app\models\tool_model.py ---

# /ata-backend/app/models/tool_model.py (CORRECTED AND MODERNIZED)

# --- Core Imports ---
from pydantic import BaseModel, Field, ConfigDict
from typing import Dict, Any, List, Optional
from enum import Enum

# --- Enumerations for Tool Settings (Unchanged) ---
class QuestionDifficulty(str, Enum):
    VERY_EASY = "very easy"
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"
    VERY_HARD = "very hard"

class SlideStyle(str, Enum):
    INFORMATIVE = "informative"
    ENGAGING = "engaging"
    PROFESSIONAL = "professional"

class ToolId(str, Enum):
    QUESTION_GENERATOR = "question-generator"
    SLIDE_GENERATOR = "slide-generator"
    RUBRIC_GENERATOR = "rubric-generator"
    LESSON_PLAN_GENERATOR = "lesson-plan-generator"

# --- Models for the Question Generator ---
class QuestionTypeConfig(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    type: str
    label: str
    count: int
    difficulty: QuestionDifficulty

class QuestionGeneratorSettings(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    grade_level: str
    source_text: Optional[str] = None
    selected_chapter_paths: Optional[List[str]] = None
    question_configs: List[QuestionTypeConfig]

# --- Models for the Slide Generator ---
class SlideGeneratorSettings(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    grade_level: str
    source_text: Optional[str] = None
    selected_chapter_paths: Optional[List[str]] = None
    num_slides: int
    slide_style: SlideStyle
    include_speaker_notes: bool

# --- Models for the Rubric Generator (UPGRADED) ---
class RubricGeneratorSettings(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    grade_level: str
    
    # --- [MODERNIZED ALIAS] ---
    # The validation_alias now uses a simple list of strings.
    assignment_text: Optional[str] = Field(
        default=None,
        validation_alias='source_text' # Pydantic V2 prefers a single alias here for clarity
    )
    # --- [END OF MODERNIZED ALIAS] ---
    
    assignment_chapter_paths: Optional[List[str]] = None
    guidance_text: Optional[str] = None
    guidance_chapter_paths: Optional[List[str]] = None
    criteria: List[str] = Field(..., min_length=2)
    levels: List[str] = Field(..., min_length=2)

# --- Universal Tool Models ---
class ToolGenerationRequest(BaseModel):
    # This is an incoming request model, so it does not need from_attributes.
    tool_id: ToolId
    settings: Dict[str, Any]

class ToolGenerationResponse(BaseModel):
    # This is a response model, so it needs from_attributes.
    model_config = ConfigDict(from_attributes=True)
    generation_id: str
    tool_id: ToolId
    content: str

--- File: .\ata-backend\app\models\user_model.py ---

# /ata-backend/app/models/user_model.py (FINAL, CORRECTED, AND FLAWLESS)

import uuid
from typing import Optional
from pydantic import BaseModel, EmailStr, Field, ConfigDict
# --- [THE FIX IS HERE, STEP 1: Import the case converter] ---
from pydantic.alias_generators import to_camel

# --- User Models ---

class UserBase(BaseModel):
    """
    Base model containing shared properties for a user.
    It is now configured to automatically handle camelCase aliases for JSON.
    """
    email: EmailStr = Field(..., description="The user's unique email address.")
    full_name: Optional[str] = Field(None, description="The user's full name.")

    # --- [THE FIX IS HERE, STEP 2: ADD THE CONFIG TO THE BASE MODEL] ---
    model_config = ConfigDict(
        alias_generator=to_camel,   # Generate camelCase aliases from snake_case field names.
        populate_by_name=True,    # Allow populating fields by their name OR their alias.
    )
    # --- [END OF FIX] ---

class UserCreate(UserBase):
    """
    Pydantic model for data required to create a new user.
    This model inherits the camelCase configuration from UserBase, so it will correctly
    accept a "fullName" key from the JSON payload and map it to the "full_name" field.
    """
    password: str = Field(
        ...,
        min_length=8,
        description="The user's plain-text password (will be hashed before storage)."
    )


class User(UserBase):
    """
    Pydantic model for representing a user's data in API responses.
    This model also inherits the camelCase configuration. When FastAPI serializes
    this model to JSON, it will use the aliases, creating keys like "fullName"
    in the output, which is ideal for the JavaScript frontend.
    """
    id: uuid.UUID = Field(..., description="The unique, server-generated identifier for the user.")
    is_active: bool = Field(..., description="Indicates if the user's account is active.")
    
    # We must combine the configs. `from_attributes` is for reading from SQLAlchemy objects,
    # and the alias settings are for correctly formatting the outgoing JSON.
    model_config = ConfigDict(
        from_attributes=True,
        alias_generator=to_camel,
        populate_by_name=True,
    )

# --- Token Models (Unchanged, as their fields are standard snake_case) ---

class Token(BaseModel):
    access_token: str = Field(..., description="The JWT access token string.")
    token_type: str = Field("bearer", description="The type of the token (always 'bearer').")


class TokenData(BaseModel):
    user_id: Optional[str] = Field(None, description="The unique ID of the user (subject of the token).")

--- File: .\ata-backend\app\models\__init__.py ---

 


--- File: .\ata-backend\app\routers\admin_router.py ---

# /ata-backend/app/routers/admin_router.py

"""
Admin router for super admin dashboard.
Provides protected endpoints for admin-only operations.
"""

from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from typing import Dict, Any

from app.db.database import get_db
from app.core.admin_auth import verify_admin_token
from app.services import admin_service
from app.services.file_cleanup_service import get_cleanup_service

router = APIRouter()


@router.get("/dashboard", response_model=Dict[str, Any])
def get_admin_dashboard(
    db: Session = Depends(get_db),
    _: bool = Depends(verify_admin_token)
):
    """
    Returns comprehensive database statistics and data.
    Protected endpoint - requires admin token.

    Returns:
        Complete database statistics including:
        - Summary counts of all entities
        - Detailed data for users, classes, students, assessments, etc.
    """
    return admin_service.get_admin_dashboard_data(db)


@router.get("/cleanup/preview", response_model=Dict[str, Any])
def preview_file_cleanup(
    hours: int = Query(default=12, ge=1, le=720, description="Hours after completion"),
    db: Session = Depends(get_db),
    _: bool = Depends(verify_admin_token)
):
    """
    Preview what files would be deleted without actually deleting them.
    Protected endpoint - requires admin token.

    Args:
        hours: Number of hours after completion before files are eligible for deletion

    Returns:
        Statistics about what would be deleted (dry run)
    """
    cleanup_service = get_cleanup_service()
    return cleanup_service.get_cleanup_preview(db, hours_after_completion=hours)


@router.post("/cleanup/execute", response_model=Dict[str, Any])
def execute_file_cleanup(
    hours: int = Query(default=12, ge=1, le=720, description="Hours after completion"),
    db: Session = Depends(get_db),
    _: bool = Depends(verify_admin_token)
):
    """
    Actually delete old assessment files.
    Protected endpoint - requires admin token.

    Args:
        hours: Number of hours after completion before files are eligible for deletion

    Returns:
        Statistics about what was deleted
    """
    cleanup_service = get_cleanup_service()
    return cleanup_service.cleanup_old_assessments(
        db=db,
        hours_after_completion=hours,
        dry_run=False
    )


--- File: .\ata-backend\app\routers\assessments_router.py ---

# /app/routers/assessments_router.py (SUPERVISOR-APPROVED FLAWLESS VERSION 2.0)

"""
This module defines all API endpoints related to assessment jobs.

Every endpoint is protected and requires user authentication. The router is
responsible for injecting the authenticated user's context into every call to
the business logic layer (the AssessmentService), ensuring all operations are
securely scoped to the correct user. Authorization checks are performed at the
earliest possible point within the router itself.
"""

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form, Response, BackgroundTasks, Request
from app.core.logger import get_logger

logger = get_logger(__name__)
from typing import List, Dict, Optional
import json

# --- Application-specific Imports ---
from ..services.assessment_service import AssessmentService, get_assessment_service
from ..models import assessment_model
from ..core.deps import get_current_active_user
from ..db.models.user_model import User as UserModel

router = APIRouter()


# --- V2 Endpoints (Now Secure with Router-Level Authorization) ---

@router.post(
    "/parse-document",
    summary="[V2] Parse uploaded document(s) to structure an assessment"
)
async def parse_assessment_document(
    question_file: UploadFile = File(..., description="The main exam document with questions."),
    answer_key_file: Optional[UploadFile] = File(None, description="An optional, separate answer key or rubric file."),
    class_id: str = Form(...),
    assessment_name: str = Form(...),
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    The endpoint for the V2 wizard's interactive step.
    This protected endpoint first verifies the user owns the target class
    before proceeding with the parsing operation.
    """
    # --- [ARCHITECTURAL REFINEMENT: AUTHORIZATION CHECK IN ROUTER] ---
    # Justification: This is the "Fail Fast" principle. We check for permission
    # at the earliest possible moment. If the user doesn't own the class, we
    # reject the request immediately without engaging the more resource-intensive
    # service logic (file processing, AI calls).
    target_class = assessment_svc.db.get_class_by_id(class_id=class_id, user_id=current_user.id)
    if not target_class:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Class with ID {class_id} not found or you do not have permission to access it."
        )
    # --- [END OF REFINEMENT] ---
    
    try:
        # The service call is now simpler as it's a pure data processor.
        parsed_config_dict = await assessment_svc.parse_document_for_review(
            question_file=question_file,
            answer_key_file=answer_key_file,
            class_id=class_id,
            assessment_name=assessment_name
        )
        return parsed_config_dict
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        logger.info(f"Error during document parsing: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected error occurred while parsing the document.")


@router.post(
    "/v2",
    response_model=assessment_model.AssessmentJobResponse,
    status_code=status.HTTP_202_ACCEPTED,
    summary="[V2] Create a New Assessment Grading Job from a V2 Config"
)
async def create_assessment_job_v2(
    background_tasks: BackgroundTasks,
    config: str = Form(...),
    answer_sheets: List[UploadFile] = File(...),
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Creates a V2 assessment job and schedules it for background processing.
    This is a protected endpoint.
    """
    try:
        config_data = assessment_model.AssessmentConfigV2.model_validate_json(config)

        response = await assessment_svc.create_new_assessment_job_v2(
            config=config_data,
            answer_sheets=answer_sheets,
            user_id=current_user.id
        )

        job_id = response.get("jobId")
        if job_id:
            background_tasks.add_task(assessment_svc.process_assessment_job, job_id, current_user.id)

        return response
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")


@router.post(
    "/distribute-scores",
    response_model=assessment_model.AssessmentConfigV2,
    summary="[V2] Distribute Total Score with AI",
    description="Uses AI to intelligently distribute a total score across all questions in an assessment configuration."
)
async def distribute_scores(
    request: assessment_model.ScoreDistributionRequest,
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Takes an assessment config and a total score, and returns the config with
    maxScore populated for each question by the AI.
    This is a protected endpoint.
    """
    try:
        updated_config = await assessment_svc.distribute_scores_with_ai(
            config=request.config,
            total_marks=request.totalMarks
        )
        return updated_config
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred during score distribution: {e}")


@router.post(
    "/v2/manual",
    response_model=assessment_model.AssessmentJobResponse,
    status_code=status.HTTP_202_ACCEPTED,
    summary="[V2] Create a Job with Manual Per-Student Uploads"
)
async def create_assessment_job_with_manual_uploads(
    request: Request,
    background_tasks: BackgroundTasks,
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Creates a V2 assessment job from a configuration and manually associated
    per-student files, all in a single transaction. This endpoint handles
    multipart form data where student files are keyed dynamically.
    """
    form_data = await request.form()

    config_str = form_data.get("config")
    if not config_str:
        raise HTTPException(status_code=400, detail="Missing 'config' in form data.")

    outsider_names_str = form_data.get("outsider_names", "[]")

    try:
        config = assessment_model.AssessmentConfigV2.model_validate_json(config_str)
        outsider_names = json.loads(outsider_names_str)

        # The service layer will be responsible for parsing the dynamic file keys
        response = await assessment_svc.create_job_with_manual_uploads(
            config=config,
            form_data=form_data,
            outsider_names=outsider_names,
            user_id=current_user.id,
        )

        job_id = response.get("jobId")
        if job_id:
            background_tasks.add_task(assessment_svc.process_assessment_job, job_id, current_user.id)

        return response
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid JSON format for 'config' or 'outsider_names'.")
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")


@router.post(
    "/manual-submission",
    summary="[V2] Process a manual, per-student submission",
    status_code=status.HTTP_201_CREATED
)
async def manual_submission(
    job_id: str = Form(...),
    images: List[UploadFile] = File(...),
    student_id: Optional[str] = Form(None),
    outsider_name: Optional[str] = Form(None),
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Handles the manual upload of images for a single student or outsider.
    Compresses images, merges them into a PDF, and creates result records.
    """
    if not images:
        raise HTTPException(status_code=400, detail="No images were uploaded.")

    try:
        result = await assessment_svc.process_manual_submission(
            job_id=job_id,
            user_id=str(current_user.id),
            images=images,
            student_id=student_id,
            outsider_name=outsider_name
        )
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")


# --- V1 & General Endpoints (Now Secure) ---

@router.get(
    "",
    response_model=assessment_model.AssessmentJobListResponse,
    summary="Get All Assessment Jobs"
)
def get_all_assessment_jobs(
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Retrieves a summary list of all assessment jobs for the authenticated user."""
    return assessment_svc.get_all_assessment_jobs_summary(user_id=current_user.id)


@router.patch(
    "/{job_id}/results/{student_id}/{question_id}",
    summary="Save Teacher Overrides for a Single Question"
)
def save_teacher_overrides(
    job_id: str,
    student_id: str,
    question_id: str,
    overrides: assessment_model.GradingResult,
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Saves a teacher's final grade/feedback for a single question."""
    try:
        assessment_svc.save_overrides(
            job_id=job_id,
            student_id=student_id,
            question_id=question_id,
            overrides=overrides,
            user_id=current_user.id
        )
        return {"status": "success", "detail": f"Overrides for s:{student_id} q:{question_id} saved."}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get(
    "/{job_id}/results",
    response_model=assessment_model.AssessmentResultsResponse,
    summary="Get Full Assessment Job Results"
)
def get_assessment_job_results(
    job_id: str,
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Retrieves the complete, aggregated results for a user-owned grading job."""
    full_results = assessment_svc.get_full_job_results(job_id=job_id, user_id=current_user.id)
    if full_results is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Job {job_id} not found or access denied.")
    return full_results


@router.delete(
    "/{job_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete an Assessment Job"
)
def delete_assessment_job(
    job_id: str,
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Permanently deletes a user-owned assessment job and all its associated data."""
    was_deleted = assessment_svc.delete_assessment_job(job_id=job_id, user_id=current_user.id)
    if not was_deleted:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Job {job_id} not found or access denied.")
    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.get(
    "/{job_id}/config",
    response_model=assessment_model.AssessmentConfigResponse,
    summary="Get Assessment Configuration for Cloning"
)
def get_assessment_config(
    job_id: str,
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Fetches a previous job's settings for the 'Clone' feature."""
    try:
        config_dict = assessment_svc.get_job_config(job_id=job_id, user_id=current_user.id)
        return assessment_model.AssessmentConfigResponse(**config_dict)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get("/{job_id}/report/{student_id}", response_class=Response)
async def download_single_report(
    job_id: str,
    student_id: str,
    assessment_svc: AssessmentService = Depends(get_assessment_service),
    current_user: UserModel = Depends(get_current_active_user)
):
    """Generates and returns a single student's report as a .docx file."""
    try:
        report_bytes, filename = await assessment_svc.generate_single_report_docx(job_id, student_id, current_user.id)
        return Response(
            content=report_bytes, 
            media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document", 
            headers={"Content-Disposition": f"attachment; filename=\"{filename}\""}
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

--- File: .\ata-backend\app\routers\assessment_review_router.py ---

from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import StreamingResponse
from typing import List

from app.services.assessment_service import AssessmentService, get_assessment_service
from app.services.database_service import DatabaseService, get_db_service
from app.models import assessment_model
from app.models.user_model import User
from app.core.deps import get_current_active_user
from app.services.assessment_helpers import analytics_and_matching
from app.core.logger import get_logger

logger = get_logger(__name__)
router = APIRouter()

@router.get(
    "/{job_id}/overview",
    response_model=assessment_model.AssessmentResultsOverviewResponse,
    summary="Get Assessment Results Overview",
    description="Retrieves a summary of the assessment results, including a unified list of all students.",
)
async def get_assessment_results_overview(
    job_id: str,
    user: User = Depends(get_current_active_user),
    assessment_service: AssessmentService = Depends(get_assessment_service),
):
    try:
        # Get the unified list, which is the primary source of truth
        combined_list = await assessment_service.get_combined_overview(job_id=job_id, user_id=str(user.id))

        # Get basic job info for the response
        job = assessment_service.db.get_assessment_job(job_id=job_id, user_id=str(user.id))
        if not job:
            raise ValueError("Job not found")
        config = analytics_and_matching.normalize_config_to_v2(job)

        # Derive legacy lists for backward compatibility, ensuring other UI parts don't break
        students_ai_graded = []
        students_pending = []
        for student_row in combined_list:
            if student_row.status == "PENDING_REVIEW":
                students_pending.append(
                    assessment_model.StudentPendingSummary(
                        student_id=student_row.student_id,
                        name=student_row.student_name,
                        num_pending=1 # Placeholder count
                    )
                )
            elif student_row.status in ["AI_GRADED", "TEACHER_GRADED"] and student_row.total_score is not None:
                students_ai_graded.append(
                    assessment_model.StudentAIGradedSummary(
                        student_id=student_row.student_id,
                        name=student_row.student_name,
                        total_score=student_row.total_score
                    )
                )

        # Construct and return the final, correct response object
        return assessment_model.AssessmentResultsOverviewResponse(
            job_id=job_id,
            assessment_name=config.assessmentName,
            status=job.status,
            students_ai_graded=students_ai_graded,
            students_pending=students_pending,
            students=combined_list
        )
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))

@router.get(
    "/{job_id}/students/{entity_id}/review",
    response_model=assessment_model.StudentReviewResponse,
    summary="Get Student's Assessment for Review",
    description="Retrieves the detailed results for a single student's assessment, ready for teacher review.",
)
def get_student_assessment_for_review(
    job_id: str,
    entity_id: str,
    user: User = Depends(get_current_active_user),
    assessment_service: AssessmentService = Depends(get_assessment_service),
):
    try:
        review_data = assessment_service.get_student_assessment_for_review(
            job_id=job_id,
            entity_id=entity_id,
            user_id=str(user.id)
        )
        return review_data
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))

@router.patch(
    "/{job_id}/students/{entity_id}/questions/{question_id}",
    response_model=assessment_model.StudentSaveConfirmation,
    summary="Save Teacher's Edit for a Question",
    description="Saves a teacher's grade and feedback for a single question and returns the student's updated score.",
)
async def save_teacher_edit(
    job_id: str,
    entity_id: str,
    question_id: str,
    payload: assessment_model.QuestionSaveRequest,
    user: User = Depends(get_current_active_user),
    assessment_service: AssessmentService = Depends(get_assessment_service),
):
    try:
        confirmation = await assessment_service.apply_teacher_edit(
            job_id=job_id,
            entity_id=entity_id,
            question_id=question_id,
            grade=payload.grade,
            feedback=payload.feedback,
            user_id=str(user.id),
        )
        return confirmation
    except ValueError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")

@router.get(
    "/{job_id}/students/{entity_id}/report.docx",
    summary="Download Student Report as DOCX",
    description="Generates and downloads a DOCX report for a student based on the latest grades and feedback.",
)
async def download_student_report(
    job_id: str,
    entity_id: str,
    user: User = Depends(get_current_active_user),
    assessment_service: AssessmentService = Depends(get_assessment_service),
    db: DatabaseService = Depends(get_db_service),
):
    try:
        # Get student name for filename
        student_name = "Student"
        rostered_student = db.get_student_by_id(entity_id, str(user.id))
        if rostered_student:
            student_name = rostered_student.name.replace(" ", "_")
            logger.info(f"Found rostered student for report: {student_name}")
        else:
            outsider_student = db.get_outsider_student_by_id(entity_id, str(user.id))
            if outsider_student:
                student_name = outsider_student.name.replace(" ", "_")
                logger.info(f"Found outsider student for report: {student_name}")
            else:
                logger.warning(f"No student found for entity_id={entity_id}, using default name")

        docx_buffer = await assessment_service.build_student_report_docx(
            job_id=job_id,
            entity_id=entity_id,
            user_id=str(user.id)
        )
        filename = f"{student_name}_Report.docx"
        logger.info(f"Generating report with filename: {filename}")
        return StreamingResponse(
            docx_buffer,
            media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            headers={"Content-Disposition": f'attachment; filename="{filename}"'}
        )
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))

--- File: .\ata-backend\app\routers\auth_router.py ---

# /ata-backend/app/routers/auth_router.py

"""
This module defines the public-facing API for all authentication-related actions.

It includes endpoints for:
- User registration (`/register`)
- User login and token generation (`/token`)
- Retrieving the current user's profile (`/me`)

This router orchestrates the authentication flow by connecting the HTTP layer
with the underlying business logic in the `user_service` and the cryptographic
utilities in the `core.security` module.
"""

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session

# --- Application-specific Imports ---
from app.db.database import get_db
from app.models.user_model import User, UserCreate, Token
from app.db.models.user_model import User as UserModel
from app.services import user_service
from app.core import security
from app.core.deps import get_current_active_user, oauth2_scheme
from app.core import admin_auth
from app.services.database_service import get_db_service

# --- Router Initialization ---
router = APIRouter()


@router.post("/register", response_model=User, status_code=status.HTTP_201_CREATED)
def register_user(
    user_in: UserCreate, 
    db: Session = Depends(get_db)
):
    """
    Handles new user registration.

    Delegates the user creation logic to the user_service and handles any
    business-logic-related exceptions by converting them to HTTP exceptions.
    """
    # --- THIS IS THE ARCHITECTURAL FIX ---
    # The router does not know the business rules. It only knows how to call
    # the service and handle potential errors.
    try:
        new_user = user_service.create_user(db=db, user=user_in)
        return new_user
    except ValueError as e:
        # The user_service will raise a ValueError if the email already exists.
        # The router's job is to catch this specific business error and
        # translate it into a client-friendly HTTP 400 error.
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e),
        )


@router.post("/token", response_model=Token)
def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """
    Handles user login, compatible with the OAuth2 Password Flow.

    It authenticates the user with their email (via the 'username' field) and
    password. On success, it generates and returns a JWT access token.

    Special case: If admin credentials are provided, returns an admin token.
    """

    # Check if this is an admin login attempt
    if admin_auth.authenticate_admin(email=form_data.username, password=form_data.password):
        admin_token = admin_auth.create_admin_token()
        return Token(access_token=admin_token, token_type="bearer")

    # Otherwise, proceed with normal user authentication
    user = user_service.authenticate_user(
        db, email=form_data.username, password=form_data.password
    )
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token = security.create_access_token(
        subject=user.id
    )

    # Use the best practice from V3: return a Pydantic model instance.
    return Token(access_token=access_token, token_type="bearer")


@router.get("/me", response_model=User)
def read_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
):
    """
    Retrieves the profile information for the currently authenticated user.

    This is a protected endpoint. For admin users, returns a special admin profile.
    For regular users, returns their database profile.
    """
    # Decode the token to check if it's an admin token
    user_id = security.decode_token(token)

    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )

    # Check if this is the admin user
    if user_id == "ADMIN_USER":
        # Return a mock user object for admin
        return User(
            id="00000000-0000-0000-0000-000000000000",
            email="mehran.gharuni.admin@admin.com",
            fullName="Super Admin",
            isActive=True
        )

    # Otherwise, get the regular user from database
    user = user_service.get_user_by_email(db, email=user_id) if "@" in user_id else None

    # If email lookup failed, try by ID
    if not user:
        from uuid import UUID
        try:
            user_uuid = UUID(user_id)
            user = db.query(UserModel).filter(UserModel.id == user_uuid).first()
        except (ValueError, AttributeError):
            user = None

    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )

    return user

--- File: .\ata-backend\app\routers\chatbot_router.py ---

# /ata-backend/app/routers/chatbot_router.py (SUPERVISOR-APPROVED FLAWLESS VERSION)

"""
This module defines all API endpoints for the Chatbot feature, including both
RESTful endpoints for session management and the real-time WebSocket endpoint
for conversations.

Every endpoint in this router is now a protected resource. REST endpoints are
secured using the standard `Depends(get_current_active_user)` dependency. The
WebSocket endpoint is secured by requiring a JWT passed as a query parameter,
which is the standard practice for authenticating real-time connections.
"""

from fastapi import APIRouter, Depends, WebSocket, WebSocketDisconnect, Response, status, HTTPException, Query
from app.core.logger import get_logger

logger = get_logger(__name__)
from typing import List
import json

# --- Application-specific Imports ---
from ..services import chatbot_service
from ..services.database_service import DatabaseService, get_db_service
from ..models import chatbot_model

# --- [CRITICAL SECURITY IMPORTS] ---
# Import the dependency for protecting REST endpoints.
from app.core.deps import get_current_active_user
# Import the utility for decoding WebSocket tokens.
from app.core.security import decode_token
# Import the SQLAlchemy User model for type hinting the authenticated user.
from app.db.models.user_model import User as UserModel

router = APIRouter()

# --- REST ENDPOINTS FOR SESSION MANAGEMENT (NOW SECURE) ---

@router.get(
    "/sessions",
    response_model=List[chatbot_model.ChatSessionSummary],
    summary="Get Current User's Chat History",
    description="Retrieves a list of all past chat session summaries for the authenticated user."
)
def get_chat_sessions(
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user)  # Protect the endpoint.
):
    """
    Securely retrieves the chat session history for the currently logged-in user.
    """
    # The user's ID is passed to the database service to ensure the query is filtered.
    return db.get_chat_sessions_by_user_id(user_id=current_user.id)


@router.get(
    "/sessions/{session_id}",
    response_model=chatbot_model.ChatSessionDetail,
    summary="Get a Single Chat Session with History",
    description="Retrieves the full details and message history for a specific chat session, if owned by the user."
)
def get_chat_session_details(
    session_id: str,
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user)  # Protect the endpoint.
):
    """
    Securely retrieves the details of a single chat session, enforcing ownership.
    """
    # The user's ID is passed to the service layer for an ownership check.
    details = chatbot_service.get_chat_session_details_logic(session_id, current_user.id, db)
    if not details:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Chat session with ID {session_id} not found or access denied.",
        )
    return details


@router.post(
    "/sessions",
    response_model=chatbot_model.CreateChatSessionResponse,
    summary="Create a New Chat Session",
    description="Initiates a new chat session for the authenticated user."
)
def create_new_chat_session(
    request: chatbot_model.NewChatSessionRequest,
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user)  # Protect the endpoint.
):
    """
    Creates a new chat session, automatically assigning ownership to the authenticated user.
    """
    # The user's ID is passed to the service layer to stamp ownership on the new record.
    session_info = chatbot_service.start_new_chat_session(current_user.id, request, db)
    return session_info


@router.delete(
    "/sessions/{session_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete a Chat Session",
    description="Permanently deletes a chat session, if owned by the user."
)
def delete_chat_session(
    session_id: str,
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user)  # Protect the endpoint.
):
    """
    Securely deletes a chat session, enforcing ownership.
    """
    # The user's ID is passed to the service layer for an ownership check before deletion.
    was_deleted = chatbot_service.delete_chat_session_logic(session_id, current_user.id, db)
    if not was_deleted:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Chat session with ID {session_id} not found or access denied.",
        )
    return Response(status_code=status.HTTP_204_NO_CONTENT)


# --- REAL-TIME WEBSOCKET ENDPOINT (NOW SECURE) ---

@router.websocket("/ws/{session_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    session_id: str,
    token: str = Query(...),  # Expect the JWT as a query parameter named 'token'.
    db: DatabaseService = Depends(get_db_service)
):
    """
    Handles the real-time WebSocket connection for a chat session.

    Authentication is performed using a JWT passed as a query parameter.
    The connection is only accepted if the token is valid and the user owns
    the requested chat session.
    """
    # 1. Authenticate the user via the token from the query parameter.
    user_id = decode_token(token)
    if not user_id:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid or missing token")
        return

    # 2. Authorize access to the specific chat session.
    # This secure database call checks for both existence and ownership.
    session = db.get_chat_session_by_id(session_id=session_id, user_id=user_id)
    if not session:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Session not found or access denied")
        return

    # 3. If authentication and authorization succeed, accept the connection.
    await websocket.accept()
    
    try:
        while True:
            data = await websocket.receive_text()
            message_data = json.loads(data)

            if message_data.get("type") == "user_message":
                message_text = message_data.get("payload", {}).get("text")
                file_id = message_data.get("payload", {}).get("file_id")

                if message_text:
                    # 4. Pass the validated user_id to the service layer for processing.
                    await chatbot_service.add_new_message_to_session(
                        session_id=session_id,
                        user_id=user_id,  # Use the validated user_id.
                        message_text=message_text,
                        file_id=file_id,
                        db=db,
                        websocket=websocket
                    )
            
    except WebSocketDisconnect:
        logger.info(f"Client disconnected from chat session: {session_id}")
    except Exception as e:
        logger.info(f"An unexpected error occurred in WebSocket for session {session_id}: {e}")
        try:
            await websocket.send_json({
                "type": "error", 
                "payload": {"message": "A server error occurred. Please try reconnecting."}
            })
        except Exception:
            # The client may have already disconnected, so we ignore errors here.
            pass

--- File: .\ata-backend\app\routers\classes_router.py ---


# /ata-backend/app/routers/classes_router.py (SUPERVISOR-APPROVED FLAWLESS VERSION)

"""
This module defines the secure API endpoints for managing Class and Student data.

Every endpoint in this router is protected and requires a valid JWT Bearer token
for an active user. The router is responsible for:
1. Receiving HTTP requests for class and student operations.
2. Using the `get_current_active_user` dependency to authenticate and authorize the user.
3. Passing the authenticated user's context (`user_id`) down to the business
   logic layer (`class_service`).
4. Handling HTTP-specific concerns like status codes and exceptions.
"""

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form, Response
from fastapi.responses import StreamingResponse
from typing import List

# --- Application-specific Imports ---
from ..models import class_model, student_model
from ..services import class_service
from ..services.database_service import DatabaseService, get_db_service

# --- [CRITICAL MODIFICATION 1/2: IMPORT SECURITY DEPENDENCIES] ---
from ..core.deps import get_current_active_user
from ..db.models.user_model import User as UserModel

router = APIRouter()

# --- CLASS COLLECTION ENDPOINTS (/api/classes) ---

@router.get("", response_model=List[class_model.ClassSummary], summary="Get All Classes for Current User")
def get_all_classes(
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Dependency
):
    """
    Retrieves a summary list of all classes owned by the currently authenticated user.
    """
    # Pass the authenticated user's ID to the service layer.
    return class_service.get_all_classes_with_summary(user_id=current_user.id, db=db)

@router.post("", response_model=class_model.Class, status_code=status.HTTP_201_CREATED, summary="Create a New Class")
def create_new_class(
    class_create: class_model.ClassCreate, 
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Dependency
):
    """
    Creates a new class, automatically assigning ownership to the authenticated user.
    """
    # Pass the user's ID to the service layer to be stamped on the new record.
    return class_service.create_class(class_data=class_create, db=db, user_id=current_user.id)

@router.post("/upload", response_model=class_model.ClassUploadResponse, status_code=status.HTTP_202_ACCEPTED, summary="Create a Class via Roster Upload")
async def create_class_with_upload(
    name: str = Form(...), 
    file: UploadFile = File(...),
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Dependency
):
    """
    Creates a new class and populates its roster from an uploaded file.
    Ownership is assigned to the authenticated user.
    """
    try:
        # Pass the user's ID to the service layer for the entire secure transaction.
        result = await class_service.create_class_from_upload(name=name, file=file, db=db, user_id=current_user.id)
        return result
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"An unexpected server error occurred: {e}")

# --- INDIVIDUAL CLASS RESOURCE ENDPOINTS (/api/classes/{class_id}) ---

@router.get("/{class_id}", response_model=class_model.ClassDetails, summary="Get a Single Class by ID")
def get_class_by_id(
    class_id: str, 
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Dependency
):
    """
    Retrieves the full details of a single class, but only if it is owned by the
    authenticated user.
    """
    # Pass the user's ID to the service layer for an ownership check.
    class_details = class_service.get_class_details_by_id(class_id=class_id, user_id=current_user.id, db=db)
    if class_details is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Class with ID {class_id} not found or access denied.")
    return class_details

@router.put("/{class_id}", response_model=class_model.Class, summary="Update a Class")
def update_class_details(
    class_id: str, 
    class_update: class_model.ClassCreate, 
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Dependency
):
    """
    Updates a class's details, but only if it is owned by the authenticated user.
    """
    try:
        # Pass the user's ID to the service layer for an ownership check.
        updated_class = class_service.update_class(class_id=class_id, class_update=class_update, db=db, user_id=current_user.id)
        if updated_class is None:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Class with ID {class_id} not found or access denied.")
        return updated_class
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

@router.delete("/{class_id}", status_code=status.HTTP_204_NO_CONTENT, summary="Delete a Class")
def delete_class(
    class_id: str, 
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Dependency
):
    """
    Deletes a class and all its students, but only if it is owned by the
    authenticated user.
    """
    # Pass the user's ID to the service layer for an ownership check.
    was_deleted = class_service.delete_class_by_id(class_id=class_id, db=db, user_id=current_user.id)
    if not was_deleted:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Class with ID {class_id} not found or access denied.")
    return Response(status_code=status.HTTP_204_NO_CONTENT)

@router.get("/{class_id}/export", summary="Export Class Roster as CSV", response_class=StreamingResponse)
def export_class_roster_csv(
    class_id: str, 
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Dependency
):
    """
    Generates a CSV export of a class roster, but only if the class is owned
    by the authenticated user.
    """
    try:
        # Pass the user's ID to the service layer for an ownership check.
        csv_string = class_service.export_roster_as_csv(class_id=class_id, user_id=current_user.id, db=db)
        class_details = class_service.get_class_details_by_id(class_id, current_user.id, db)
        class_name = class_details.get('name', 'class_roster') if class_details else 'class_roster'
        file_name = f"roster_{class_name.replace(' ', '_').lower()}.csv"
        return StreamingResponse(iter([csv_string]), media_type="text/csv", headers={"Content-Disposition": f"attachment; filename={file_name}"})
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

# --- STUDENT SUB-RESOURCE ENDPOINTS ---

@router.post("/{class_id}/students", response_model=student_model.Student, status_code=status.HTTP_201_CREATED, summary="Add a Student to a Class")
def add_student(
    class_id: str, 
    student_create: student_model.StudentCreate, 
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Dependency
):
    """
    Adds a new student to a class, but only if the class is owned by the
    authenticated user.
    """
    try:
        # Pass the user's ID to the service layer for an ownership check on the parent class.
        new_student = class_service.add_student_to_class(class_id=class_id, student_data=student_create, db=db, user_id=current_user.id)
        return new_student
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

@router.put("/{class_id}/students/{student_id}", response_model=student_model.Student, summary="Update a Student")
def update_student_details(
    class_id: str, 
    student_id: str, 
    student_update: student_model.StudentUpdate, 
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Dependency
):
    """
    Updates a student's details, but only if the student belongs to a class
    owned by the authenticated user.
    """
    try:
        # Pass the user's ID to the service layer for an ownership check.
        updated_student = class_service.update_student(student_id=student_id, student_update=student_update, db=db, user_id=current_user.id)
        if updated_student is None:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Student with ID {student_id} not found or access denied.")
        return updated_student
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

@router.delete("/{class_id}/students/{student_id}", status_code=status.HTTP_204_NO_CONTENT, summary="Remove a Student from a Class")
def remove_student_from_class(
    class_id: str, 
    student_id: str, 
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Dependency
):
    """
    Removes a student from a class, but only if the class is owned by the
    authenticated user.
    """
    # Pass the user's ID to the service layer for an ownership check.
    was_deleted = class_service.delete_student_from_class(class_id=class_id, student_id=student_id, db=db, user_id=current_user.id)
    if not was_deleted:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Student with ID {student_id} not found in class {class_id} or access denied.")
    return Response(status_code=status.HTTP_204_NO_CONTENT)

--- File: .\ata-backend\app\routers\dashboard_router.py ---


# /ata-backend/app/routers/dashboard_router.py (MODIFIED AND SUPERVISOR-APPROVED - FLAWLESS VERSION)

"""
This module defines the API endpoints for the main dashboard.

It provides a single, now-protected endpoint (`/summary`) that retrieves high-level
statistics (e.g., class and student counts) for the authenticated user's
homepage dashboard view.
"""

# --- Core FastAPI Imports ---
from fastapi import APIRouter, Depends

# --- Application-specific Imports ---

# Import the business logic service that this router will use.
from app.services import dashboard_service

# Import the database service dependency provider.
from app.services.database_service import DatabaseService, get_db_service

# Import the Pydantic model to define the API's response shape.
from app.models.dashboard_model import DashboardSummary

# --- [CRITICAL SECURITY MODIFICATION 1/3: Import Security Dependencies] ---
# Import the main security dependency that enforces user authentication.
from app.core.deps import get_current_active_user
# Import the SQLAlchemy User model for type hinting the authenticated user object.
from app.db.models.user_model import User as UserModel


# --- APIRouter Instance ---
router = APIRouter()


# --- Endpoint Definition (Now Protected) ---
@router.get(
    "/summary",
    response_model=DashboardSummary,
    summary="Get Authenticated User's Dashboard Summary",
    description="Retrieves high-level statistics (class count, student count) for the currently authenticated user's main dashboard view."
)
def get_dashboard_summary(
    # FastAPI's dependency injection provides a database session.
    db: DatabaseService = Depends(get_db_service),
    # --- [CRITICAL SECURITY MODIFICATION 2/3: Inject User Dependency] ---
    # This dependency acts as a security gate. FastAPI will run `get_current_active_user`
    # before executing this function. If the user is not authenticated or not active,
    # the request will be rejected with a 401/403 error automatically.
    # On success, the authenticated user's SQLAlchemy object is injected into the
    # `current_user` variable.
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    This endpoint is now a protected "thin" router layer. Its job is to:
    1. Receive an incoming HTTP request.
    2. Ensure the user is authenticated via the `get_current_active_user` dependency.
    3. Delegate the actual work to the "thick" business logic service, now
       passing the authenticated user's context (their ID).
    4. Return the user-specific result.
    """
    
    # --- [CRITICAL SECURITY MODIFICATION 3/3: Pass User Context to Service] ---
    # Delegate immediately to the service layer, passing the authenticated user's
    # unique ID. This instructs the service to calculate the summary based only
    # on the data owned by this specific user.
    return dashboard_service.get_summary_data(db=db, user_id=current_user.id)

--- File: .\ata-backend\app\routers\history_router.py ---


# /ata-backend/app/routers/history_router.py (SUPERVISOR-APPROVED FLAWLESS VERSION)

"""
This module defines the API endpoints for managing a user's AI generation history.

As a protected resource, every endpoint in this router requires a valid JWT
for access. The `get_current_active_user` dependency is injected into each
endpoint to act as a security gate. This router is responsible for receiving
authenticated requests and passing the user's context (their unique ID) down to
the business logic layer in the `history_service`.
"""

from typing import Optional
from fastapi import APIRouter, Depends, HTTPException, status, Response
from app.core.logger import get_logger

logger = get_logger(__name__)

# --- Application-specific Imports ---

# Import the Pydantic models that define the API data contract.
from ..models import history_model

# Import the business logic service that this router will orchestrate.
from ..services import history_service
from ..services.database_service import DatabaseService, get_db_service

# --- [CRITICAL SECURITY MODIFICATION 1/3]: Import Security Dependencies ---
# `get_current_active_user` is the dependency that will protect our endpoints.
# `UserModel` is the SQLAlchemy model, imported for clear type hinting.
from ..core.deps import get_current_active_user
from ..db.models.user_model import User as UserModel

# --- Router Initialization ---
router = APIRouter()


@router.post(
    "",
    response_model=history_model.GenerationRecord,
    status_code=status.HTTP_201_CREATED,
    summary="Save a Generation to History"
)
def save_generation_record(
    payload: history_model.GenerationCreate,
    db: DatabaseService = Depends(get_db_service),
    # --- [CRITICAL SECURITY MODIFICATION 2/3]: Inject Dependency ---
    # This dependency injection is the security gate. FastAPI will execute
    # `get_current_active_user` before this function's code runs. If the token
    # is invalid, the request is rejected with a 401 error. If valid, the
    # authenticated user's SQLAlchemy object is placed in `current_user`.
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Persists a new, user-owned generation record to the database.
    This endpoint is now protected and requires authentication.
    """
    try:
        # --- [CRITICAL SECURITY MODIFICATION 3/3]: Pass User Context ---
        # We pass the authenticated user's ID down to the service layer.
        # The service will then "stamp" this ID onto the new record,
        # creating the ownership link.
        return history_service.save_generation(
            db=db,
            user_id=current_user.id,
            tool_id=payload.tool_id.value,
            settings=payload.settings,
            generated_content=payload.generated_content
        )
    except Exception as e:
        logger.info(f"ERROR saving generation record for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An error occurred while saving the generation record."
        )


@router.get(
    "",
    response_model=history_model.HistoryResponse,
    summary="Get User's Generation History"
)
def get_user_history(
    search: Optional[str] = None,
    tool_id: Optional[str] = None,
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Gate
):
    """
    Retrieves the AI generation history exclusively for the authenticated user.
    This endpoint is now protected and requires authentication.
    """
    try:
        # Pass the user's ID to the service layer, which will use it to
        # filter the database query, ensuring no data from other users is returned.
        return history_service.get_history(
            db=db, 
            user_id=current_user.id, 
            search=search, 
            tool_id=tool_id
        )
    except Exception as e:
        logger.info(f"ERROR fetching history for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An error occurred while fetching the generation history."
        )


@router.delete(
    "/{generation_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete a Generation Record from History"
)
def delete_generation_record(
    generation_id: str,
    db: DatabaseService = Depends(get_db_service),
    current_user: UserModel = Depends(get_current_active_user) # <-- Security Gate
):
    """
    Permanently deletes a single generation record from the user's history.
    This endpoint is now protected and requires authentication.
    """
    # Pass both the record ID and the user's ID to the service layer.
    # The data access layer will only delete the record if the generation_id
    # exists AND its owner_id matches the current_user.id.
    was_deleted = history_service.delete_generation(
        db=db, 
        generation_id=generation_id, 
        user_id=current_user.id
    )
    
    if not was_deleted:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Generation record with ID {generation_id} not found or you do not have permission to delete it.",
        )
    
    # On success, a 204 response has no body.
    return Response(status_code=status.HTTP_204_NO_CONTENT)




--- File: .\ata-backend\app\routers\library_router.py ---


# /ata-backend/app/routers/library_router.py (SUPERVISOR-APPROVED FLAWLESS VERSION)

"""
This module defines the API router for accessing the curriculum library.

The endpoints defined here provide access to the application's proprietary
educational content structure. As such, this entire router is protected and
requires a valid user session for access.
"""

from typing import List, Dict, Any
from fastapi import APIRouter, Depends

# --- Application-specific Imports ---

# Import the business logic service that provides the library data.
from ..services import library_service

# --- [CRITICAL MODIFICATION 1/2: IMPORT DEPENDENCIES] ---
# Import the security dependency that will act as our "gatekeeper".
from ..core.deps import get_current_active_user
# Import the SQLAlchemy model for type hinting the authenticated user object.
from ..db.models.user_model import User as UserModel


# --- Router Initialization ---
router = APIRouter()


@router.get(
    "/tree",
    response_model=List[Dict[str, Any]],
    summary="Get Book Library Structure",
    description="Retrieves the complete, hierarchical structure of the book library. This endpoint is protected and requires authentication."
)
def get_library_structure(
    # --- [CRITICAL MODIFICATION 2/2: INJECT DEPENDENCY] ---
    # This `Depends` declaration is the security enforcement mechanism.
    # Before the code inside this function is ever executed, FastAPI will first
    # run our `get_current_active_user` dependency.
    #
    # 1. If the request lacks a valid, unexpired token, the dependency will
    #    immediately raise a 401 Unauthorized error, and the request will be rejected.
    # 2. If the user's account is inactive, it will raise a 403 Forbidden error.
    # 3. Only if the user is fully authenticated and active will FastAPI proceed
    #    to run the code below.
    #
    # The `current_user` variable itself is not used in the function body, but its
    # presence in the signature is what activates the security check.
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Endpoint to retrieve the cached book library tree.

    This is a protected endpoint. It will only return a successful response if the
    request includes a valid `Authorization: Bearer <token>` header for an
    active user.
    """
    # This line is only reached if the user is authenticated.
    # The library content is the same for all users, so we do not need to pass
    # the user_id to the service.
    return library_service.get_library_tree()

--- File: .\ata-backend\app\routers\page_count_router.py ---

# /ata-backend/app/routers/page_count_router.py

"""
This module defines the API endpoint for counting pages in uploaded documents.

The endpoint accepts multiple files (PDF, DOCX, images) and returns the total
number of pages, which is used by the frontend to calculate processing time estimates.
"""

from fastapi import APIRouter, File, UploadFile, HTTPException, Depends
from typing import List
from pydantic import BaseModel

from ..services import page_count_service
from ..core.deps import get_current_active_user
from ..db.models.user_model import User as UserModel

router = APIRouter()


class PageCountResponse(BaseModel):
    """Response model for page count endpoint"""
    total_pages: int
    file_count: int
    estimated_seconds: int


@router.post(
    "/count-pages",
    response_model=PageCountResponse,
    summary="Count total pages in uploaded documents",
    description="Accepts multiple files (PDF, DOCX, images) and returns total page count for processing time estimation."
)
async def count_pages(
    files: List[UploadFile] = File(..., description="List of files to count pages from (PDF, DOCX, or images)"),
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Count the total number of pages across all uploaded files.

    - **files**: List of uploaded files (PDF, DOCX, JPG, PNG)
    - Returns: Total page count and estimated processing time (15 seconds per page)
    """
    if not files:
        raise HTTPException(status_code=400, detail="No files were uploaded.")

    try:
        total_pages = await page_count_service.count_total_pages(files)

        # Calculate estimated time: 15 seconds per page
        estimated_seconds = total_pages * 15

        return PageCountResponse(
            total_pages=total_pages,
            file_count=len(files),
            estimated_seconds=estimated_seconds
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error counting pages: {str(e)}"
        )


--- File: .\ata-backend\app\routers\public_router.py ---

# /ata-backend/app/routers/public_router.py (SUPERVISOR-APPROVED FLAWLESS VERSION)

"""
This module defines API endpoints that are intentionally accessible to the public
without requiring a standard user login session.

Security for these endpoints is managed through unique, unguessable tokens
embedded in the URL, rather than through JWT Bearer tokens.
"""

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field
from typing import Optional

# --- Application-specific Imports ---
from ..services.database_service import DatabaseService, get_db_service
from ..services.assessment_helpers import analytics_and_matching

# --- Pydantic Response Model ---

class PublicReportResponse(BaseModel):
    """
    Defines the precise data contract for a public-facing student report.
    This ensures only specific, non-sensitive information is exposed.
    """
    studentName: str = Field(..., description="The name of the student.")
    assessmentName: str = Field(..., description="The name of the assessment.")
    questionText: str = Field(..., description="The text of the specific question being reported on.")
    maxScore: Optional[int] = Field(..., description="The maximum possible score for this question.")
    grade: Optional[float] = Field(..., description="The grade the student received for this question.")
    feedback: str = Field(..., description="The feedback provided for the student's answer.")

    class Config:
        from_attributes = True

# --- Router Initialization ---
router = APIRouter()

@router.get(
    "/report/{report_token}",
    response_model=PublicReportResponse,
    summary="Get a Single Student Report via Secure Token",
    tags=["Public"]
)
def get_public_report_by_token(
    report_token: str,
    db: DatabaseService = Depends(get_db_service)
):
    """
    Retrieves the details for a single graded question via a unique, secure token.

    This endpoint is public but secure. It uses a single, efficient database query
    that joins all related tables to fetch the data only if the token is valid
    and all data relationships are intact.
    """
    # 1. Fetch all required details in a single, secure, and efficient database call.
    report_details = db.get_public_report_details_by_token(token=report_token)

    if not report_details:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Report not found. The link may be invalid or expired."
        )

    # Unpack the dictionary for clarity
    result_record = report_details["result"]
    job_record = report_details["assessment"]
    student_record = report_details["student"]

    # 2. Normalize the job's config to robustly handle both V1 and V2 formats.
    config = analytics_and_matching.normalize_config_to_v2(job_record)

    # 3. Find the specific question from the config that this result corresponds to.
    question_config = None
    for section in config.sections:
        for q in section.questions:
            if q.id == result_record.question_id:
                question_config = q
                break
        if question_config:
            break

    if not question_config:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Question details not found in assessment configuration."
        )

    # 4. Assemble the final, validated response payload.
    response_payload = {
        "studentName": student_record.name,
        "assessmentName": config.assessmentName,
        "questionText": question_config.text,
        "maxScore": question_config.maxScore,
        "grade": result_record.grade,
        "feedback": result_record.feedback or "No feedback provided.",
    }

    return response_payload

--- File: .\ata-backend\app\routers\students_router.py ---

"""
This router handles all API endpoints related to individual students,
such as fetching a student's transcript.
"""

from fastapi import APIRouter, Depends, HTTPException
from app.services.student_service import StudentService
from app.services.database_service import get_db_service, DatabaseService
from app.core.deps import get_current_active_user
from app.models.student_model import StudentTranscriptResponse
from app.db.models.user_model import User

router = APIRouter(
    tags=["students"],
    dependencies=[Depends(get_current_active_user)]
)

@router.get("/{student_id}/transcript", response_model=StudentTranscriptResponse)
def get_student_transcript(
    student_id: str,
    current_user: User = Depends(get_current_active_user),
    db: DatabaseService = Depends(get_db_service)
):
    """
    Retrieves a comprehensive transcript for a single student, including all their
    assessments, grades, and an overall average. This is a protected endpoint.
    """
    svc = StudentService(db)
    try:
        transcript = svc.get_transcript(student_id=student_id, user_id=str(current_user.id))
        return transcript
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        # Generic error handler for unexpected issues
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")

--- File: .\ata-backend\app\routers\tools_router.py ---

# /app/routers/tools_router.py (SUPERVISOR-APPROVED FLAWLESS VERSION)

"""
This module defines the API endpoints for all AI content generation tools.

Every endpoint in this router is now protected, requiring a valid JWT token
for access. The router is responsible for injecting the authenticated user's
context into the business logic layer, ensuring that all generated content is
correctly attributed and saved to the user's private history.
"""

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form
from app.core.logger import get_logger

logger = get_logger(__name__)
import json

# --- Application-specific Imports ---
from ..models import tool_model

# Import the business logic service this router delegates to.
from ..services import tool_service

# Import the DatabaseService and its dependency provider.
from ..services.database_service import DatabaseService, get_db_service

# --- [CRITICAL MODIFICATION 1/3: IMPORT DEPENDENCIES] ---
# Import the security dependency that will protect these endpoints.
from ..core.deps import get_current_active_user
# Import the SQLAlchemy User model for type hinting the authenticated user.
from ..db.models.user_model import User as UserModel


router = APIRouter()

@router.post(
    "/generate/text",
    response_model=tool_model.ToolGenerationResponse,
    summary="Generate Content from Text or Library",
    description="The primary endpoint for text-based and library-based generation, accepting a JSON body."
)
async def generate_tool_content_from_text(
    request: tool_model.ToolGenerationRequest,
    db: DatabaseService = Depends(get_db_service),
    # --- [CRITICAL MODIFICATION 2/3: INJECT DEPENDENCY] ---
    # This dependency acts as a security gate. If the user is not authenticated
    # and active, the request will be rejected with a 401 or 403 error before
    # this function's code is even executed.
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Handles generation where the source is either direct text or library paths.
    This endpoint is now protected and requires authentication.
    """
    try:
        response_data = await tool_service.generate_content_for_tool(
            settings_payload=request.model_dump(), # Use model_dump() for Pydantic v2
            source_file=None,
            db=db,
            # --- [CRITICAL MODIFICATION 3/3: PASS USER CONTEXT] ---
            # Pass the authenticated user's ID to the service layer. This is
            # essential for the service to save the result to the correct user's history.
            user_id=current_user.id
        )
        return response_data
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))
    except Exception as e:
        logger.info(f"ERROR during text generation for user {current_user.id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected error occurred.")


@router.post(
    "/generate/upload",
    response_model=tool_model.ToolGenerationResponse,
    summary="Generate Content from an Uploaded File",
    description="The specialized endpoint for file-based generation using OCR."
)
async def generate_tool_content_from_upload(
    db: DatabaseService = Depends(get_db_service),
    settings: str = Form(...),
    source_file: UploadFile = File(...),
    # --- [CRITICAL MODIFICATION 2/3: INJECT DEPENDENCY] ---
    current_user: UserModel = Depends(get_current_active_user)
):
    """
    Handles generation where the source is an uploaded file.
    This endpoint is now protected and requires authentication.
    """
    try:
        settings_data = json.loads(settings)
        response_data = await tool_service.generate_content_for_tool(
            settings_payload=settings_data,
            source_file=source_file,
            db=db,
            # --- [CRITICAL MODIFICATION 3/3: PASS USER CONTEXT] ---
            user_id=current_user.id
        )
        return response_data
    except json.JSONDecodeError:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="The 'settings' form field is not valid JSON.")
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=str(e))
    except Exception as e:
        logger.info(f"ERROR during upload generation for user {current_user.id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected error occurred.")

--- File: .\ata-backend\app\routers\__init__.py ---

# Router exports
from . import (
    classes_router,
    assessments_router,
    assessment_review_router,
    tools_router,
    chatbot_router,
    dashboard_router,
    library_router,
    history_router,
    public_router,
    auth_router,
    students_router,
    page_count_router
)


--- File: .\ata-backend\app\services\admin_service.py ---

# /ata-backend/app/services/admin_service.py

"""
Admin service to fetch comprehensive database statistics and data.
"""

from typing import Dict, List, Any
from sqlalchemy.orm import Session
from sqlalchemy import func

from app.db.models.user_model import User
from app.db.models.class_student_models import Class, Student, StudentClassMembership
from app.db.models.assessment_models import Assessment, Result
from app.db.models.outsider_student import OutsiderStudent
from app.db.models.chat_models import ChatSession, ChatMessage
from app.db.models.generation_models import Generation
from app.db.models.ai_model_run import AIModelRun


def get_admin_dashboard_data(db: Session) -> Dict[str, Any]:
    """
    Fetches comprehensive statistics and data from the entire database.

    Returns:
        Dictionary containing all database statistics and detailed data
    """

    # ==================== SUMMARY STATISTICS ====================
    total_users = db.query(func.count(User.id)).scalar()
    total_classes = db.query(func.count(Class.id)).scalar()
    total_students = db.query(func.count(Student.id)).scalar()
    total_assessments = db.query(func.count(Assessment.id)).scalar()
    total_results = db.query(func.count(Result.id)).scalar()
    total_outsider_students = db.query(func.count(OutsiderStudent.id)).scalar()
    total_chat_sessions = db.query(func.count(ChatSession.id)).scalar()
    total_chat_messages = db.query(func.count(ChatMessage.id)).scalar()
    total_generations = db.query(func.count(Generation.id)).scalar()
    total_ai_runs = db.query(func.count(AIModelRun.id)).scalar()
    total_memberships = db.query(func.count(StudentClassMembership.id)).scalar()

    # ==================== USERS DATA ====================
    users = db.query(User).all()
    users_data = []
    for user in users:
        user_classes_count = db.query(func.count(Class.id)).filter(Class.user_id == user.id).scalar()
        user_assessments_count = db.query(func.count(Assessment.id)).filter(Assessment.user_id == user.id).scalar()
        user_chat_sessions_count = db.query(func.count(ChatSession.id)).filter(ChatSession.user_id == user.id).scalar()
        user_generations_count = db.query(func.count(Generation.id)).filter(Generation.user_id == user.id).scalar()

        users_data.append({
            "id": str(user.id),
            "email": user.email,
            "full_name": user.full_name,
            "is_active": user.is_active,
            "created_at": user.created_at.isoformat() if user.created_at else None,
            "classes_count": user_classes_count,
            "assessments_count": user_assessments_count,
            "chat_sessions_count": user_chat_sessions_count,
            "generations_count": user_generations_count
        })

    # ==================== CLASSES DATA ====================
    classes = db.query(Class).all()
    classes_data = []
    for cls in classes:
        student_count = db.query(func.count(StudentClassMembership.id)).filter(
            StudentClassMembership.class_id == cls.id
        ).scalar()

        owner = db.query(User).filter(User.id == cls.user_id).first()

        classes_data.append({
            "id": cls.id,
            "name": cls.name,
            "description": cls.description,
            "owner_email": owner.email if owner else "Unknown",
            "student_count": student_count
        })

    # ==================== STUDENTS DATA ====================
    students = db.query(Student).all()
    students_data = []
    for student in students:
        classes_count = db.query(func.count(StudentClassMembership.id)).filter(
            StudentClassMembership.student_id == student.id
        ).scalar()

        classes_list = db.query(Class.name).join(
            StudentClassMembership,
            StudentClassMembership.class_id == Class.id
        ).filter(StudentClassMembership.student_id == student.id).all()

        students_data.append({
            "id": student.id,
            "name": student.name,
            "studentId": student.studentId,
            "overallGrade": student.overallGrade,
            "classes_count": classes_count,
            "classes": [cls.name for cls in classes_list]
        })

    # ==================== ASSESSMENTS DATA ====================
    assessments = db.query(Assessment).all()
    assessments_data = []
    for assessment in assessments:
        results_count = db.query(func.count(Result.id)).filter(Result.job_id == assessment.id).scalar()
        owner = db.query(User).filter(User.id == assessment.user_id).first()

        assessments_data.append({
            "id": assessment.id,
            "status": assessment.status,
            "created_at": assessment.created_at.isoformat() if assessment.created_at else None,
            "owner_email": owner.email if owner else "Unknown",
            "total_pages": assessment.total_pages,
            "results_count": results_count,
            "config": assessment.config
        })

    # ==================== RESULTS DATA ====================
    results = db.query(Result).limit(100).all()  # Limit to first 100 for performance
    results_data = []
    for result in results:
        student_name = None
        if result.student_id:
            student = db.query(Student).filter(Student.id == result.student_id).first()
            student_name = student.name if student else "Unknown"
        elif result.outsider_student_id:
            outsider = db.query(OutsiderStudent).filter(OutsiderStudent.id == result.outsider_student_id).first()
            student_name = outsider.name if outsider else "Unknown"

        results_data.append({
            "id": result.id,
            "job_id": result.job_id,
            "student_name": student_name,
            "question_id": result.question_id,
            "grade": result.grade,
            "status": result.status,
            "finalized_by": result.finalized_by.value if result.finalized_by else None
        })

    # ==================== OUTSIDER STUDENTS DATA ====================
    outsider_students = db.query(OutsiderStudent).all()
    outsider_students_data = []
    for outsider in outsider_students:
        results_count = db.query(func.count(Result.id)).filter(Result.outsider_student_id == outsider.id).scalar()

        outsider_students_data.append({
            "id": outsider.id,
            "name": outsider.name,
            "job_id": outsider.assessment_id,
            "results_count": results_count
        })

    # ==================== CHAT SESSIONS DATA ====================
    chat_sessions = db.query(ChatSession).all()
    chat_sessions_data = []
    for session in chat_sessions:
        messages_count = db.query(func.count(ChatMessage.id)).filter(ChatMessage.session_id == session.id).scalar()
        owner = db.query(User).filter(User.id == session.user_id).first()

        chat_sessions_data.append({
            "id": session.id,
            "title": session.name,
            "created_at": session.created_at.isoformat() if session.created_at else None,
            "owner_email": owner.email if owner else "Unknown",
            "messages_count": messages_count
        })

    # ==================== GENERATIONS DATA ====================
    generations = db.query(Generation).all()
    generations_data = []
    for gen in generations:
        owner = db.query(User).filter(User.id == gen.user_id).first()

        generations_data.append({
            "id": gen.id,
            "tool_type": gen.tool_id,
            "created_at": gen.created_at.isoformat() if gen.created_at else None,
            "owner_email": owner.email if owner else "Unknown"
        })

    # ==================== AI MODEL RUNS DATA ====================
    ai_runs = db.query(AIModelRun).all()
    ai_runs_data = []
    for run in ai_runs:
        ai_runs_data.append({
            "id": str(run.id),
            "job_id": run.job_id,
            "question_id": run.question_id,
            "run_index": run.run_index,
            "grade": float(run.grade) if run.grade else None,
            "created_at": run.created_at.isoformat() if run.created_at else None
        })

    # AI cost and token tracking not available in current schema
    total_ai_cost = 0.0
    total_ai_tokens = 0

    # ==================== BUILD RESPONSE ====================
    return {
        "summary": {
            "total_users": total_users,
            "total_classes": total_classes,
            "total_students": total_students,
            "total_assessments": total_assessments,
            "total_results": total_results,
            "total_outsider_students": total_outsider_students,
            "total_chat_sessions": total_chat_sessions,
            "total_chat_messages": total_chat_messages,
            "total_generations": total_generations,
            "total_ai_runs": total_ai_runs,
            "total_memberships": total_memberships,
            "total_ai_cost": round(total_ai_cost, 4),
            "total_ai_tokens": total_ai_tokens
        },
        "users": users_data,
        "classes": classes_data,
        "students": students_data,
        "assessments": assessments_data,
        "results": results_data,
        "outsider_students": outsider_students_data,
        "chat_sessions": chat_sessions_data,
        "generations": generations_data,
        "ai_runs": ai_runs_data
    }


--- File: .\ata-backend\app\services\assessment_service.py ---

# /ata-backend/app/services/assessment_service.py (REVISED AND CORRECTED)

import uuid, json, os, asyncio, shutil
from fastapi import UploadFile, Depends
from typing import List, Dict, Optional, Union, Tuple
from decimal import Decimal, InvalidOperation
from datetime import datetime, timezone
from io import BytesIO
from docx import Document

# Import all services and helpers
from . import ocr_service, gemini_service, prompt_library, report_service, zip_service, library_service, pdf_service
from .database_service import DatabaseService, get_db_service
from ..models import assessment_model
from ..db.models.assessment_models import ResultStatus, FinalizedBy
from .assessment_helpers import job_creation, grading_pipeline, data_assembly, document_parser, analytics_and_matching

ASSESSMENT_UPLOADS_DIR = "assessment_uploads"

def finalize_question(
    three_grades: List[Optional[Decimal]],
    three_comments: List[Optional[str]],
    max_score: float
) -> Dict:
    """
    Computes consensus for a single question from three AI model runs.
    This version is more robust and correctly handles edge cases.
    """
    valid_runs = [(g, c) for g, c in zip(three_grades, three_comments) if g is not None]

    if len(valid_runs) < 2:
        return {"status": ResultStatus.PENDING_REVIEW, "grade": None, "feedback": None, "finalized_by": None}

    grade_groups: Dict[int, list] = {}
    for i in range(len(valid_runs)):
        g1, c1 = valid_runs[i]
        matched = False
        for group_id, group in grade_groups.items():
            if any(abs(g1 - g_existing) <= Decimal("0.1") for g_existing, _ in group):
                grade_groups[group_id].append((g1, c1))
                matched = True
                break
        if not matched:
            grade_groups[len(grade_groups)] = [(g1, c1)]

    for group in grade_groups.values():
        if len(group) >= 2:
            # Correctly average the grades of the majority group
            total_grade = sum(g for g, c in group)
            avg_grade = total_grade / len(group)

            # Use the comment from the first member of the majority group
            final_comment = group[0][1]

            return {
                "status": ResultStatus.AI_GRADED,
                "grade": float(round(avg_grade, 2)),
                "feedback": final_comment,
                "finalized_by": FinalizedBy.AI,
            }

    return {"status": ResultStatus.PENDING_REVIEW, "grade": None, "feedback": None, "finalized_by": None}


class AssessmentService:
    def __init__(self, db: DatabaseService = Depends(get_db_service)):
        self.db = db

    async def parse_document_for_review(self, question_file: UploadFile, answer_key_file: Optional[UploadFile], class_id: str, assessment_name: str) -> Dict:
        return await document_parser.parse_document_to_config(question_file, answer_key_file, class_id, assessment_name)

    async def create_new_assessment_job_v2(
        self, config: assessment_model.AssessmentConfigV2, answer_sheets: List[UploadFile], user_id: str
    ) -> Dict:
        job_id = f"job_{uuid.uuid4().hex[:16]}"

        # Count total pages across all student submissions
        from . import page_count_service
        print(f"ðŸ” [ASSESSMENT SERVICE] Counting pages for {len(answer_sheets)} files...")
        total_pages = await page_count_service.count_total_pages(answer_sheets)
        print(f"ðŸ“Š [ASSESSMENT SERVICE] Total pages counted: {total_pages}")

        answer_sheet_data = job_creation._save_uploaded_files(job_id, answer_sheets)
        job_creation._create_initial_job_records_v2(self.db, job_id, config, answer_sheet_data, user_id, total_pages)

        response = {
            "jobId": job_id,
            "status": assessment_model.JobStatus.QUEUED.value,
            "message": "Assessment job created.",
            "totalPages": total_pages
        }
        print(f"âœ… [ASSESSMENT SERVICE] Returning response: {response}")
        return response

    async def create_job_with_manual_uploads(
        self, config: assessment_model.AssessmentConfigV2, form_data, outsider_names: List[Dict[str, str]], user_id: str
    ) -> Dict:
        """
        Creates a job, processes manually uploaded files keyed by student/outsider ID,
        and links everything in the database in a single transaction.
        """
        # 1. Create the base job and questions, but with no answer sheets yet.
        job_id = f"job_{uuid.uuid4().hex[:16]}"
        job_creation._create_initial_job_records_v2(self.db, job_id, config, [], user_id)

        # Create a map for quick lookup of outsider names by their temporary frontend ID
        outsider_name_map = {item['id']: item['name'] for item in outsider_names}

        # 2. Process each set of files from the dynamic form data
        for key, files in form_data.multi_items():
            if not key.endswith('_files'):
                continue

            # Ensure we have a list of UploadFile objects
            if not isinstance(files, list):
                files = [files]

            # Skip if no files were actually uploaded for this key
            if not files or not files[0].filename:
                continue

            parts = key.replace('_files', '').split('_')
            entity_type = parts[0] # 'student' or 'outsider'
            entity_id = '_'.join(parts[1:]) # Re-join in case the ID had underscores

            # 3. Compress, merge, and save the PDF for the entity
            try:
                compressed_images = [pdf_service.compress_image(await f.read()) for f in files]
                pdf_bytes = pdf_service.merge_images_to_pdf(compressed_images)

                job_dir = os.path.join(ASSESSMENT_UPLOADS_DIR, job_id)
                os.makedirs(job_dir, exist_ok=True)

                pdf_filename = f"manual_{entity_type}_{entity_id}.pdf"
                pdf_path = os.path.join(job_dir, pdf_filename)
                with open(pdf_path, "wb") as f:
                    f.write(pdf_bytes)

                file_info = {"path": pdf_path, "contentType": "application/pdf"}

                # 4. Create DB records (Result, AnswerSheet, and possibly OutsiderStudent)
                if entity_type == 'student':
                    analytics_and_matching._create_results_for_entity(self.db, job_id, entity_id, 'student', config, file_info, user_id)
                elif entity_type == 'outsider':
                    outsider_name = outsider_name_map.get(entity_id, "Unknown Outsider")
                    new_outsider = self.db.add_outsider_student({
                        "name": outsider_name,
                        "assessment_id": job_id
                    })
                    analytics_and_matching._create_results_for_entity(self.db, job_id, new_outsider.id, 'outsider', config, file_info, user_id)

            except Exception as e:
                print(f"Error processing files for key {key}: {e}")
                # Optionally, decide if a single failure should halt the whole process
                # For now, we'll log and continue.
                continue

        return { "jobId": job_id, "status": assessment_model.JobStatus.QUEUED.value, "message": "Assessment job with manual uploads created." }

    async def process_manual_submission(self, job_id: str, user_id: str, images: List[UploadFile], student_id: Optional[str] = None, outsider_name: Optional[str] = None) -> Dict:
        if not student_id and not outsider_name:
            raise ValueError("Either a student_id or an outsider_name must be provided.")

        # 1. Compress and merge images into a single PDF
        compressed_images = [pdf_service.compress_image(await img.read()) for img in images]
        pdf_bytes = pdf_service.merge_images_to_pdf(compressed_images)

        # 2. Save the generated PDF to a unique path
        job_dir = os.path.join(ASSESSMENT_UPLOADS_DIR, job_id)
        os.makedirs(job_dir, exist_ok=True)

        entity_identifier = student_id if student_id else f"outsider_{uuid.uuid4().hex[:8]}"
        pdf_filename = f"manual_{entity_identifier}.pdf"
        pdf_path = os.path.join(job_dir, pdf_filename)

        with open(pdf_path, "wb") as f:
            f.write(pdf_bytes)

        file_info = {"path": pdf_path, "contentType": "application/pdf"}

        # 3. Get the assessment config
        job = self.db.get_assessment_job(job_id, user_id)
        if not job:
            raise ValueError(f"Job {job_id} not found.")
        config = analytics_and_matching.normalize_config_to_v2(job)

        # 4. Create result records
        if student_id:
            # It's a rostered student
            analytics_and_matching._create_results_for_entity(self.db, job_id, student_id, 'student', config, file_info, user_id)
            return {"message": f"Submission for student {student_id} processed successfully."}
        else:
            # It's an outsider student
            new_outsider = self.db.add_outsider_student({
                "name": outsider_name,
                "assessment_id": job_id
            })
            analytics_and_matching._create_results_for_entity(self.db, job_id, new_outsider.id, 'outsider', config, file_info, user_id)
            return {"message": f"Submission for outsider {outsider_name} processed successfully."}

    def create_new_assessment_job(
        self, config: assessment_model.AssessmentConfig, answer_sheets: List[UploadFile], user_id: str
    ) -> Dict:
        job_id = f"job_{uuid.uuid4().hex[:16]}"
        answer_sheet_data = job_creation._save_uploaded_files(job_id, answer_sheets)
        job_creation._create_initial_job_records(self.db, job_id, config, answer_sheet_data, user_id)
        return { "jobId": job_id, "status": assessment_model.JobStatus.QUEUED.value, "message": "Assessment job created." }

    def delete_assessment_job(self, job_id: str, user_id: str) -> bool:
        was_deleted = self.db.delete_assessment_job(job_id=job_id, user_id=user_id)
        if not was_deleted:
            return False
        job_dir = os.path.join(ASSESSMENT_UPLOADS_DIR, job_id)
        if os.path.isdir(job_dir):
            shutil.rmtree(job_dir)
        return True

    async def _invoke_single_grading_run_vision(
        self, prompt: str, file_bytes: bytes, mime_type: str, job_id: str, entity_id: str, is_outsider: bool, run_index: int, user_id: str
    ) -> Dict:
        print(f"[RUN-START-VISION] job={job_id} entity={entity_id} is_outsider={is_outsider} run={run_index} model=gemini-2.5-flash file_size={len(file_bytes)} prompt_chars={len(prompt)}")

        all_results_for_job = self.db.get_all_results_for_job(job_id, user_id)
        if is_outsider:
            entity_results = [r for r in all_results_for_job if r.outsider_student_id == entity_id]
        else:
            entity_results = [r for r in all_results_for_job if r.student_id == entity_id]
        all_question_ids = [r.question_id for r in entity_results]

        # Get student name for logging
        student_name = "Unknown"
        if not is_outsider:
            student_obj = self.db.get_student_by_id(entity_id, user_id)
            if student_obj:
                student_name = student_obj.name
        else:
            outsider_obj = self.db.get_outsider_student_by_id(entity_id, user_id)
            if outsider_obj:
                student_name = outsider_obj.name

        try:
            # Use vision-based processing with JSON mode
            result = await gemini_service.process_file_with_vision_json(
                file_bytes=file_bytes,
                mime_type=mime_type,
                prompt=prompt,
                temperature=0.1,
                log_context=f"GRADE-STUDENT [{student_name}] Run-{run_index}"
            )
            parsed_results = result['data']
            tokens_used = result['tokens']
            print(f"[RUN-VISION-PARSED] job={job_id} entity={entity_id} run={run_index} results_count={len(parsed_results.get('results', []))}")

            # Prepare the base payload for the AI model run log
            base_payload = {
                "job_id": job_id,
                "run_index": run_index,
                "student_id": None,
                "outsider_student_id": None
            }
            if is_outsider:
                base_payload["outsider_student_id"] = entity_id
            else:
                base_payload["student_id"] = entity_id

            for result_data in parsed_results.get('results', []):
                question_id = result_data.get('question_id')
                if not question_id or question_id not in all_question_ids:
                    continue

                grade = grading_pipeline._safe_float_convert(result_data.get('grade'))
                comment = result_data.get('feedback', '')
                extracted_answer = result_data.get('extractedAnswer', '')

                print(f"[RUN-PARSED-VISION] job={job_id} entity={entity_id} run={run_index} q={question_id} grade={grade} hasExtracted={bool(extracted_answer)}")

                run_payload = {
                    **base_payload,
                    "question_id": question_id,
                    "raw_json": result_data,
                    "grade": grade,
                    "comment": comment
                }
                self.db.create_ai_model_run(**run_payload)
                print(f"[RUN-SAVE-VISION] job={job_id} entity={entity_id} run={run_index} q={question_id} grade={grade} commentChars={len(comment or '')}")

                if run_index == 0:
                    self.db.update_result_extracted_answer(job_id, entity_id, is_outsider, question_id, extracted_answer, user_id)
            return {'success': True, 'tokens': tokens_used}
        except Exception as e:
            print(f"Error in vision-based grading run {run_index} for entity {entity_id} in job {job_id}: {e}")

            error_payload = {
                "job_id": job_id,
                "run_index": run_index,
                "raw_json": {"error": str(e)},
                "grade": None,
                "comment": "Vision AI call failed",
                "student_id": None,
                "outsider_student_id": None
            }
            if is_outsider:
                error_payload["outsider_student_id"] = entity_id
            else:
                error_payload["student_id"] = entity_id

            for q_id in all_question_ids:
                self.db.create_ai_model_run(**{**error_payload, "question_id": q_id})
            return {'success': False, 'tokens': {'prompt_tokens': 0, 'completion_tokens': 0, 'total_tokens': 0}}

    async def _grade_entire_submission_for_entity(
        self, job_id: str, entity_id: str, is_outsider: bool, answer_sheet_path: str, content_type: str, config: Union[assessment_model.AssessmentConfig, assessment_model.AssessmentConfigV2], user_id: str
    ) -> Dict:
        all_questions = [q for s in config.sections for q in s.questions] if isinstance(config, assessment_model.AssessmentConfigV2) else config.questions
        try:
            # Read the answer sheet file as bytes for vision processing
            with open(answer_sheet_path, "rb") as f:
                file_bytes = f.read()

            questions_json_str = json.dumps([q.model_dump(by_alias=True) for q in all_questions], indent=2)

            print(f"[GRADE-VISION] job={job_id} entity={entity_id} is_outsider={is_outsider} file_size={len(file_bytes)} questions={len(all_questions)}")

            answer_key_context = "The correct answers are included within each question object in the JSON below. Use these as the ground truth."
            if isinstance(config, assessment_model.AssessmentConfigV2) and config.gradingMode != assessment_model.GradingMode.ANSWER_KEY_PROVIDED:
                 answer_key_context = "No answer key was provided. Grade based on general knowledge."

            prompt = prompt_library.STUDENT_CENTRIC_GRADING_PROMPT.format(questions_json=questions_json_str, answer_key_context=answer_key_context)

            grading_tasks = [self._invoke_single_grading_run_vision(prompt, file_bytes, content_type, job_id, entity_id, is_outsider, i, user_id) for i in range(3)]
            results = await asyncio.gather(*grading_tasks)

            # Accumulate tokens from all 3 runs
            student_total_tokens = {'prompt_tokens': 0, 'completion_tokens': 0, 'total_tokens': 0}
            for result in results:
                if result.get('tokens'):
                    student_total_tokens['prompt_tokens'] += result['tokens']['prompt_tokens']
                    student_total_tokens['completion_tokens'] += result['tokens']['completion_tokens']
                    student_total_tokens['total_tokens'] += result['tokens']['total_tokens']

            # Get student name for summary log
            student_name = "Unknown"
            if not is_outsider:
                student_obj = self.db.get_student_by_id(entity_id, user_id)
                if student_obj:
                    student_name = student_obj.name
            else:
                outsider_obj = self.db.get_outsider_student_by_id(entity_id, user_id)
                if outsider_obj:
                    student_name = outsider_obj.name

            print(f"[TOKEN-USAGE] STUDENT-TOTAL [{student_name}] - Prompt: {student_total_tokens['prompt_tokens']}, Completion: {student_total_tokens['completion_tokens']}, Total: {student_total_tokens['total_tokens']}")

            # Return token usage for assessment-level aggregation
            entity_tokens = student_total_tokens.copy()

            for question in all_questions:
                runs = self.db.get_ai_model_runs_for_question(job_id, entity_id, question.id, is_outsider)

                grades = [run.grade for run in runs]
                comments = [run.comment for run in runs]
                max_score = question.maxScore if question.maxScore else 10.0

                decimal_grades = [Decimal(str(g)) if g is not None else None for g in grades]
                consensus_result = finalize_question(decimal_grades, comments, max_score)

                print(f"[CONSENSUS] job={job_id} entity={entity_id} q={question.id} grades={[str(g) for g in grades]} status={consensus_result['status']} final={consensus_result.get('grade')} by={consensus_result.get('finalized_by')}")

                if is_outsider:
                    self.db.update_outsider_result_grade(
                        job_id=job_id, outsider_student_id=entity_id, question_id=question.id,
                        grade=consensus_result.get('grade'),
                        feedback=consensus_result.get('feedback'),
                        status=consensus_result['status'].value,
                        finalized_by=consensus_result.get('finalized_by'),
                        user_id=user_id
                    )
                else:
                    self.db.update_student_result_with_grade(
                        job_id=job_id, student_id=entity_id, question_id=question.id,
                        grade=consensus_result.get('grade'),
                        feedback=consensus_result.get('feedback'),
                        status=consensus_result['status'].value,
                        finalized_by=consensus_result.get('finalized_by'),
                        user_id=user_id
                    )

            return entity_tokens

        except Exception as e:
            print(f"CRITICAL ERROR processing submission for entity {entity_id} in job {job_id}: {e}")
            # for q in all_questions:
                # self.db.update_result_status(job_id, entity_id, q.id, "FAILED", user_id)
            return {'prompt_tokens': 0, 'completion_tokens': 0, 'total_tokens': 0}

    async def _grade_entity_with_semaphore(self, semaphore: asyncio.Semaphore, job_id: str, entity: Dict, config: Union[assessment_model.AssessmentConfig, assessment_model.AssessmentConfigV2], user_id: str) -> Dict:
        """A wrapper to acquire the semaphore before grading an entity."""
        async with semaphore:
            await asyncio.sleep(1) # Stagger the start of API calls
            tokens = await self._grade_entire_submission_for_entity(
                job_id,
                entity['entity_id'],
                entity['is_outsider'],
                entity['answer_sheet_path'],
                entity['content_type'],
                config,
                user_id
            )
            return tokens

    async def process_assessment_job(self, job_id: str, user_id: str):
        semaphore = asyncio.Semaphore(2)
        assessment_total_tokens = {'prompt_tokens': 0, 'completion_tokens': 0, 'total_tokens': 0}
        try:
            self.db.update_job_status(job_id, user_id, assessment_model.JobStatus.PROCESSING.value)
            await analytics_and_matching.match_files_to_students(self.db, job_id, user_id)

            job_record = self.db.get_assessment_job(job_id, user_id)
            if not job_record:
                raise ValueError(f"Job {job_id} not found for user {user_id} during processing.")

            config = analytics_and_matching.get_validated_config_from_job(job_record)
            entities_to_grade = self.db.get_entities_with_paths(job_id, user_id)

            print(f"[TOKEN-USAGE] ========== ASSESSMENT START: {config.assessmentName} (Job: {job_id}) ==========")

            grading_tasks = [
                self._grade_entity_with_semaphore(
                    semaphore, job_id, entity, config, user_id
                ) for entity in entities_to_grade
            ]
            grading_results = await asyncio.gather(*grading_tasks)

            # Accumulate tokens from all students
            for entity_tokens in grading_results:
                if entity_tokens:
                    assessment_total_tokens['prompt_tokens'] += entity_tokens.get('prompt_tokens', 0)
                    assessment_total_tokens['completion_tokens'] += entity_tokens.get('completion_tokens', 0)
                    assessment_total_tokens['total_tokens'] += entity_tokens.get('total_tokens', 0)

            print(f"[TOKEN-USAGE] ========== ASSESSMENT GRADING COMPLETE ==========")
            print(f"[TOKEN-USAGE] Total Students Graded: {len(entities_to_grade)}")
            print(f"[TOKEN-USAGE] ASSESSMENT-TOTAL - Prompt: {assessment_total_tokens['prompt_tokens']}, Completion: {assessment_total_tokens['completion_tokens']}, Total: {assessment_total_tokens['total_tokens']}")
            print(f"[TOKEN-USAGE] ========== END ASSESSMENT: {config.assessmentName} ==========")
            
            if self.db.are_any_questions_pending_review(job_id, user_id):
                self.db.update_job_status(job_id, user_id, assessment_model.JobStatus.PENDING_REVIEW.value)
            else:
                self.db.update_job_status(job_id, user_id, assessment_model.JobStatus.SUMMARIZING.value)
                await self._generate_analytic_summary(job_id, user_id)
                self.db.update_job_status(job_id, user_id, assessment_model.JobStatus.COMPLETED.value)
        except Exception as e:
            print(f"CRITICAL ERROR processing job {job_id} for user {user_id}: {e}")
            self.db.update_job_status(job_id, user_id, assessment_model.JobStatus.FAILED.value)

    def get_all_assessment_jobs_summary(self, user_id: str) -> Dict:
        all_jobs = self.db.get_all_assessment_jobs(user_id=user_id)
        all_results = self.db.get_all_results_for_user(user_id=user_id)
        all_classes_objs = self.db.get_all_classes(user_id=user_id)
        all_classes_map = {c.id: c.name for c in all_classes_objs}
        summaries = data_assembly._assemble_job_summaries(all_jobs, all_results, all_classes_map)
        return {"assessments": summaries}

    def get_full_job_results(self, job_id: str, user_id: str) -> Optional[Dict]:
        job_record = self.db.get_assessment_job(job_id=job_id, user_id=user_id)
        if not job_record:
            return None
        config_v2 = analytics_and_matching.normalize_config_to_v2(job_record)
        class_students = self.db.get_students_by_class_id(class_id=config_v2.classId, user_id=user_id)
        all_results_for_job = self.db.get_all_results_for_job(job_id=job_id, user_id=user_id)
        final_results_dict = data_assembly._build_results_dictionary(class_students, config_v2, all_results_for_job)
        students_list = [{"id": s.id, "name": s.name, "answerSheetPath": self.db.get_student_result_path(job_id, s.id, user_id)} for s in class_students]
        analytics_data = None
        if job_record.status == assessment_model.JobStatus.COMPLETED.value:
            analytics_data = analytics_and_matching.calculate_analytics(all_results_for_job, config_v2)
        return {
            "jobId": job_record.id, "assessmentName": config_v2.assessmentName,
            "status": job_record.status, "config": config_v2,
            "students": students_list, "results": final_results_dict,
            "analytics": analytics_data, "aiSummary": job_record.ai_summary
        }

    async def _generate_analytic_summary(self, job_id: str, user_id: str):
        job_results = self.get_full_job_results(job_id=job_id, user_id=user_id)
        if not job_results or not job_results.get('analytics'):
            return
        prompt = prompt_library.ANALYTICS_SUMMARY_PROMPT.format(analytics_json=json.dumps(job_results['analytics'], indent=2))
        summary_text = await gemini_service.generate_text(prompt, temperature=0.6)
        self.db.update_job_with_summary(job_id=job_id, user_id=user_id, summary=summary_text)

    def get_assessment_results_overview(self, job_id: str, user_id: str) -> assessment_model.AssessmentResultsOverviewResponse:
        job = self.db.get_assessment_job(job_id=job_id, user_id=user_id)
        if not job:
            raise ValueError(f"Job with ID {job_id} not found or access denied.")
        config = analytics_and_matching.normalize_config_to_v2(job)
        students = self.db.get_students_by_class_id(config.classId, user_id)
        results = self.db.get_all_results_for_job(job_id, user_id)
        results_by_student = {}
        for r in results:
            if r.student_id not in results_by_student:
                results_by_student[r.student_id] = []
            results_by_student[r.student_id].append(r)
        students_ai_graded = []
        students_pending = []
        for student in students:
            student_results = results_by_student.get(student.id, [])
            pending_count = sum(1 for r in student_results if r.status == ResultStatus.PENDING_REVIEW.value)
            if pending_count > 0:
                students_pending.append(assessment_model.StudentPendingSummary(
                    student_id=student.id, name=student.name, num_pending=pending_count
                ))
            else:
                total_score = sum(r.grade for r in student_results if r.grade is not None)
                students_ai_graded.append(assessment_model.StudentAIGradedSummary(
                    student_id=student.id, name=student.name, total_score=total_score
                ))
        return assessment_model.AssessmentResultsOverviewResponse(
            job_id=job.id, assessment_name=config.assessmentName, status=job.status,
            students_ai_graded=students_ai_graded, students_pending=students_pending
        )

    def get_student_assessment_for_review(self, job_id: str, entity_id: str, user_id: str) -> assessment_model.StudentReviewResponse:
        job = self.db.get_assessment_job(job_id=job_id, user_id=user_id)
        if not job:
            raise ValueError(f"Job with ID {job_id} not found or access denied.")

        # Determine if the entity is a rostered student or an outsider
        student_name = None
        student_db_id = None
        outsider_db_id = None

        rostered_student = self.db.get_student_by_id(entity_id, user_id)
        if rostered_student:
            student_name = rostered_student.name
            student_db_id = rostered_student.id
        else:
            outsider_student = self.db.get_outsider_student_by_id(entity_id, user_id)
            if not outsider_student:
                raise ValueError(f"Entity with ID {entity_id} not found.")
            student_name = outsider_student.name
            outsider_db_id = outsider_student.id

        config = analytics_and_matching.normalize_config_to_v2(job)
        all_results_for_job = self.db.get_all_results_for_job(job_id, user_id)

        # Filter results based on whether it's a rostered or outsider student
        if student_db_id:
            entity_results = [r for r in all_results_for_job if r.student_id == student_db_id]
        else:
            entity_results = [r for r in all_results_for_job if r.outsider_student_id == outsider_db_id]

        questions_for_review = []
        all_questions = [q for s in config.sections for q in s.questions]
        for question in all_questions:
            result = next((r for r in entity_results if r.question_id == question.id), None)
            if result:
                questions_for_review.append(assessment_model.QuestionForReview(
                    question_id=question.id, question_text=question.text,
                    max_score=question.maxScore or 0, student_answer=result.extractedAnswer,
                    status=result.status, grade=result.grade, feedback=result.feedback
                ))

        return assessment_model.StudentReviewResponse(
            job_id=job.id, student_id=entity_id, student_name=student_name,
            assessment_name=config.assessmentName, config=config, per_question=questions_for_review
        )

    async def get_combined_overview(self, job_id: str, user_id: str) -> List[assessment_model.StudentResultRow]:
        job = self.db.get_assessment_job(job_id=job_id, user_id=user_id)
        if not job:
            raise ValueError(f"Job with ID {job_id} not found or access denied.")

        config = analytics_and_matching.normalize_config_to_v2(job)

        # Calculate the total possible score from the config
        max_total_score = sum(q.maxScore for section in config.sections for q in section.questions if q.maxScore is not None)

        # 1. Fetch all data sources
        roster = self.db.get_students_by_class_id(config.classId, user_id)
        outsiders = self.db.get_all_outsider_students_for_job(job_id, user_id)
        all_results = self.db.get_all_results_for_job(job_id, user_id)

        # 2. Group results by entity ID
        results_by_roster_id: Dict[str, List] = {s.id: [] for s in roster}
        results_by_outsider_id: Dict[str, List] = {o.id: [] for o in outsiders}
        for r in all_results:
            if r.student_id and r.student_id in results_by_roster_id:
                results_by_roster_id[r.student_id].append(r)
            elif r.outsider_student_id and r.outsider_student_id in results_by_outsider_id:
                results_by_outsider_id[r.outsider_student_id].append(r)

        rows: List[assessment_model.StudentResultRow] = []

        # 3. Process rostered students
        for student in roster:
            student_results = results_by_roster_id.get(student.id, [])
            if not student_results:
                rows.append(assessment_model.StudentResultRow(
                    entity_id=student.id, student_id=student.studentId, student_name=student.name,
                    status="ABSENT", is_absent=True, is_outsider=False, max_total_score=max_total_score
                ))
                continue

            statuses = {res.status for res in student_results}
            any_pending = ResultStatus.PENDING_REVIEW.value in statuses
            any_teacher = any(res.finalized_by == FinalizedBy.TEACHER.value for res in student_results)

            status = "PENDING_REVIEW" if any_pending else ("TEACHER_GRADED" if any_teacher else "AI_GRADED")
            total_score = sum(float(res.grade) for res in student_results if res.grade is not None) if not any_pending else None

            rows.append(assessment_model.StudentResultRow(
                entity_id=student.id, student_id=student.studentId, student_name=student.name,
                status=status, total_score=total_score, is_outsider=False, max_total_score=max_total_score
            ))

        # 4. Process outsider students
        for outsider in outsiders:
            outsider_results = results_by_outsider_id.get(outsider.id, [])
            if not outsider_results:
                continue # Should not happen, as outsiders are created with results

            statuses = {res.status for res in outsider_results}
            any_pending = ResultStatus.PENDING_REVIEW.value in statuses
            any_teacher = any(res.finalized_by == FinalizedBy.TEACHER.value for res in outsider_results)

            status = "PENDING_REVIEW" if any_pending else ("TEACHER_GRADED" if any_teacher else "AI_GRADED")
            total_score = sum(float(res.grade) for res in outsider_results if res.grade is not None) if not any_pending else None

            rows.append(assessment_model.StudentResultRow(
                entity_id=outsider.id,
                student_id="Outsider", # Keep this for display grouping
                student_name=outsider.name, # Use the actual name from the DB
                status=status,
                total_score=total_score,
                is_outsider=True,
                max_total_score=max_total_score
            ))

        return rows

    async def apply_teacher_edit(self, job_id: str, entity_id: str, question_id: str, grade: float, feedback: str, user_id: str) -> Dict:
        job = self.db.get_assessment_job(job_id=job_id, user_id=user_id)
        if not job:
            raise ValueError(f"Job with ID {job_id} not found or access denied.")
        config = analytics_and_matching.normalize_config_to_v2(job)

        # Validate question and grade
        all_questions = [q for s in config.sections for q in s.questions]
        question_config = next((q for q in all_questions if q.id == question_id), None)
        if not question_config:
            raise ValueError(f"Question with ID {question_id} not found in assessment config.")
        max_score = question_config.maxScore if question_config.maxScore is not None else 100.0
        if grade < 0 or grade > max_score:
            raise ValueError(f"Grade must be between 0 and {max_score}")

        # Determine if entity is rostered or outsider
        rostered_student = self.db.get_student_by_id(entity_id, user_id)
        outsider_student = None if rostered_student else self.db.get_outsider_student_by_id(entity_id, user_id)

        if not rostered_student and not outsider_student:
            raise ValueError(f"Entity {entity_id} not found or not part of this job.")

        if rostered_student:
            self.db.update_student_result_with_grade(
                job_id=job_id, student_id=entity_id, question_id=question_id, grade=grade,
                feedback=feedback, status=ResultStatus.TEACHER_GRADED.value,
                finalized_by=FinalizedBy.TEACHER.value, user_id=user_id
            )
            display_id = rostered_student.studentId
        else: # Is outsider
            self.db.update_outsider_result_grade(
                job_id=job_id, outsider_student_id=entity_id, question_id=question_id, grade=grade,
                feedback=feedback, status=ResultStatus.TEACHER_GRADED.value,
                finalized_by=FinalizedBy.TEACHER.value, user_id=user_id
            )
            display_id = "Outsider"

        # After saving, check if the entire job is now complete
        if not self.db.are_any_questions_pending_review(job_id, user_id):
            self.db.update_job_status(job_id, user_id, assessment_model.JobStatus.COMPLETED.value)
            print(f"Job {job_id} status updated to COMPLETED as all reviews are done.")

        # Calculate the updated total score for the entity and return
        all_results_for_job = self.db.get_all_results_for_job(job_id, user_id)
        if rostered_student:
            entity_results = [r for r in all_results_for_job if r.student_id == entity_id]
        else:
            entity_results = [r for r in all_results_for_job if r.outsider_student_id == entity_id]

        pending_left = any(r.status == ResultStatus.PENDING_REVIEW.value for r in entity_results)
        total_score = sum(float(r.grade) for r in entity_results if r.grade is not None)

        return {"studentId": display_id, "pendingLeft": pending_left, "totalScore": total_score}

    async def build_student_report_docx(self, job_id: str, entity_id: str, user_id: str) -> BytesIO:
        job = self.db.get_assessment_job(job_id=job_id, user_id=user_id)
        if not job:
            raise ValueError(f"Job with ID {job_id} not found or access denied.")

        config = analytics_and_matching.normalize_config_to_v2(job)

        # Determine if the entity is a rostered student or an outsider
        entity_name = None
        display_id = None
        db_id = entity_id
        is_outsider = False

        rostered_student = self.db.get_student_by_id(entity_id, user_id)
        if rostered_student:
            entity_name = rostered_student.name
            display_id = rostered_student.studentId
        else:
            outsider_student = self.db.get_outsider_student_by_id(entity_id, user_id)
            if not outsider_student:
                raise ValueError(f"Entity with ID {entity_id} not found.")
            entity_name = outsider_student.name
            display_id = "Outsider"
            is_outsider = True

        all_results_for_job = self.db.get_all_results_for_job(job_id, user_id)
        if is_outsider:
            entity_results = [r for r in all_results_for_job if r.outsider_student_id == db_id]
        else:
            entity_results = [r for r in all_results_for_job if r.student_id == db_id]

        results_map = {r.question_id: r for r in entity_results}
        all_questions = [q for s in config.sections for q in s.questions]

        doc = Document()
        doc.add_heading(f"Assessment Report: {config.assessmentName}", level=1)
        doc.add_paragraph(f"Student: {entity_name} (ID: {display_id})")
        doc.add_paragraph(f"Class: {self.db.get_class_by_id(config.classId, user_id).name}\n")

        total_score = 0.0
        max_total_score = 0.0

        for i, question in enumerate(all_questions):
            doc.add_heading(f"Question {i+1}: {question.text}", level=2)
            max_score = question.maxScore or 0
            max_total_score += max_score
            doc.add_paragraph(f"Max Score: {max_score}")

            result = results_map.get(question.id)

            p_answer = doc.add_paragraph()
            p_answer.add_run("Student's Answer:\n").bold = True
            student_answer = result.extractedAnswer if result and result.extractedAnswer else "Not answered"
            p_answer.add_run(student_answer)

            p_grade = doc.add_paragraph()
            p_grade.add_run("Grade: ").bold = True
            if result and result.grade is not None:
                p_grade.add_run(f"{result.grade} / {max_score}")
                total_score += float(result.grade)
            else:
                p_grade.add_run("Pending Review")

            p_feedback = doc.add_paragraph()
            p_feedback.add_run("Feedback:\n").bold = True
            feedback = result.feedback if result and result.feedback else "No feedback provided."
            p_feedback.add_run(feedback)
            doc.add_paragraph()

        doc.add_heading(f"Final Score: {total_score} / {max_total_score}", level=2)

        buf = BytesIO()
        doc.save(buf)
        buf.seek(0)
        return buf

    async def distribute_scores_with_ai(self, config: assessment_model.AssessmentConfigV2, total_marks: int) -> assessment_model.AssessmentConfigV2:
        """
        Uses AI to distribute a total score across all questions in a configuration.
        """
        try:
            config_json_str = config.model_dump_json(by_alias=True)

            prompt = prompt_library.AI_SCORE_DISTRIBUTION_PROMPT.format(
                total_marks=total_marks,
                questions_json=config_json_str
            )

            # Use the JSON-specific generator function for a reliable response
            response_json = await gemini_service.generate_json(prompt, temperature=0.3)

            # Validate and return the updated config
            updated_config = assessment_model.AssessmentConfigV2.model_validate(response_json)
            return updated_config

        except (ValueError, json.JSONDecodeError) as e:
            print(f"Error processing AI response for score distribution: {e}")
            # In case of error, return the original config to avoid breaking the flow
            return config
        except Exception as e:
            print(f"An unexpected error occurred during AI score distribution: {e}")
            return config

def get_assessment_service(db: DatabaseService = Depends(get_db_service)):
    return AssessmentService(db=db)

--- File: .\ata-backend\app\services\chatbot_service.py ---

# /ata-backend/app/services/chatbot_service.py (SUPERVISOR-APPROVED FLAWLESS VERSION)

"""
This service module encapsulates all business logic for the chatbot feature.

It is responsible for creating and managing chat sessions, adding messages to a
conversation, and orchestrating the interaction with the AI model for generating
responses. Every function in this module is now fully "user-aware," requiring a
`user_id` for all database operations to ensure that chat sessions are private
and securely scoped to the authenticated user.
"""

from typing import Dict, Optional, List
import uuid
from fastapi import WebSocket

from .database_service import DatabaseService
from ..models import chatbot_model
from . import gemini_service, prompt_library

# --- Helper Functions (Pure Utilities) ---

def _generate_chat_name(first_message: str) -> str:
    """
    Generates a short, descriptive name for a new chat session from the first message.
    This is a pure function with no side effects.
    """
    return " ".join(first_message.split()[:5]) + ("..." if len(first_message.split()) > 5 else "")

def _format_chat_history(messages: List) -> str:
    """
    Formats a list of SQLAlchemy ChatMessage objects into a simple, readable
    string for the AI prompt. This is a pure function.
    """
    if not messages:
        return "No previous conversation history."
    
    formatted_history = []
    for msg in messages:
        # Use attribute access (msg.role, msg.content) on the SQLAlchemy objects.
        role = "Teacher" if msg.role == 'user' else "Assistant"
        formatted_history.append(f"{role}: {msg.content}")
    
    return "\n".join(formatted_history)


# --- Public Service Functions ---

def start_new_chat_session(user_id: str, request: chatbot_model.NewChatSessionRequest, db: DatabaseService) -> Dict:
    """
    Creates a new chat session AND saves the user's first message.
    This is an atomic operation that correctly stamps the new session with the owner's ID.
    """
    session_id = f"session_{uuid.uuid4().hex[:12]}"
    session_name = _generate_chat_name(request.first_message)
    
    # 1. Create the session record, including the owner's user_id.
    session_record = { "id": session_id, "user_id": user_id, "name": session_name }
    db.create_chat_session(session_record)
    
    # 2. Create and save the user's first message record.
    user_message_record = {
        "id": f"msg_{uuid.uuid4().hex[:12]}", 
        "session_id": session_id, 
        "role": "user", 
        "content": request.first_message, 
        "file_id": request.file_id
    }
    db.add_chat_message(user_message_record)
    
    return {"sessionId": session_id}


async def add_new_message_to_session(session_id: str, user_id: str, message_text: str, file_id: Optional[str], db: DatabaseService, websocket: WebSocket):
    """
    Handles a new user message by saving it, securely retrieving the full
    conversation history, and orchestrating the AI's streamed response.
    """
    # 1. Save the user's new message to the database. This operation is implicitly
    # secure because the session_id links it to a user-owned session.
    user_message_record = {
        "id": f"msg_{uuid.uuid4().hex[:12]}", 
        "session_id": session_id, 
        "role": "user", 
        "content": message_text, 
        "file_id": file_id
    }
    db.add_chat_message(user_message_record)
    
    bot_response_text = ""
    try:
        # --- [CRITICAL SECURITY FIX] ---
        # 2. Securely retrieve the full conversation history.
        # This call now requires both session_id and user_id, ensuring that
        # we only fetch history for a conversation the user actually owns.
        full_history_objects = db.get_messages_by_session_id(session_id=session_id, user_id=user_id)
        
        # 3. Format the now-secure history for the prompt.
        formatted_history = _format_chat_history(full_history_objects)
        
        # 4. Create the final prompt.
        prompt = prompt_library.CONVERSATIONAL_CHATBOT_PROMPT.format(
            chat_history=formatted_history,
            user_message=message_text
        )
        
        # 5. Call the Gemini service to get a streamed response.
        bot_response_text = await gemini_service.generate_text_streaming(prompt, websocket)

    except Exception as e:
        print(f"Error in conversational loop for session {session_id}: {e}")
        error_message = "Sorry, I encountered an error and could not process your message."
        await websocket.send_json({"type": "error", "payload": {"message": error_message}})
        bot_response_text = f"Conversational Loop Error: {e}"
        
    # 6. Save the bot's final response to the database.
    if bot_response_text:
        bot_message_record = {
            "id": f"msg_{uuid.uuid4().hex[:12]}", 
            "session_id": session_id, 
            "role": "bot", 
            "content": bot_response_text, 
            "file_id": None
        }
        db.add_chat_message(bot_message_record)


def delete_chat_session_logic(session_id: str, user_id: str, db: DatabaseService) -> bool:
    """
    Business logic to safely delete a chat session.
    This function now uses the secure, user-scoped database method.
    """
    # --- [CRITICAL SECURITY FIX] ---
    # The call to the database now requires both session_id and user_id.
    # The database service will only return True if a session with that ID
    # belonging to that user was found and deleted.
    was_deleted = db.delete_chat_session(session_id=session_id, user_id=user_id)
    return was_deleted


def get_chat_session_details_logic(session_id: str, user_id: str, db: DatabaseService) -> Optional[Dict]:
    """
    Business logic to get the full details of a chat session.
    This function now uses secure, user-scoped database methods for all lookups.
    """
    # --- [CRITICAL SECURITY FIX 1/2] ---
    # Securely fetch the parent session object. This will return None if the
    # session does not exist OR if it does not belong to the current user.
    session = db.get_chat_session_by_id(session_id=session_id, user_id=user_id)
    
    if not session:
        return None

    # --- [CRITICAL SECURITY FIX 2/2] ---
    # Securely fetch the messages for the session, again requiring the user_id.
    # This is a defense-in-depth measure.
    messages = db.get_messages_by_session_id(session_id=session_id, user_id=user_id)
    
    # Assemble the final response dictionary using the secure data.
    session_details = {
        "id": session.id,
        "name": session.name,
        "created_at": session.created_at,
        "history": messages 
    }
    return session_details



#################################################################
##
##
##         Following code have sandbox that will use for code generating and data analysis
##
##

# # /ata-backend/app/services/chatbot_service.py (FINAL, HARDENED, AND DEFINITIVELY CORRECTED)

# from typing import Dict, Optional, List
# from datetime import datetime
# import uuid
# import json
# import asyncio
# from fastapi import WebSocket

# from .database_service import DatabaseService
# from ..models import chatbot_model
# from . import gemini_service, prompt_library

# from RestrictedPython import compile_restricted, safe_globals

# # --- [THE FIX IS HERE: THE CORRECT PRINT COLLECTOR CLASS] ---
# class PrintCollector:
#     """
#     A safe, custom object that conforms to RestrictedPython's printing protocol.
#     It is a callable object that also has the required _call_print method.
#     """
#     def __init__(self):
#         self.captured_output = []

#     # This makes the INSTANCE of the class callable, e.g., print_collector("hello")
#     def __call__(self, *args):
#         line = " ".join(map(str, args))
#         self.captured_output.append(line)

#     # This is the specific method that RestrictedPython's rewritten code calls.
#     # We simply delegate it to our main __call__ method for consistency.
#     def _call_print(self, *args):
#         self.__call__(*args)

#     def get_output(self) -> str:
#         """Returns the full captured output as a single string."""
#         return "\n".join(self.captured_output).strip()
# # --- [END OF FIX] ---


# def _generate_chat_name(first_message: str) -> str:
#     return " ".join(first_message.split()[:5]) + ("..." if len(first_message.split()) > 5 else "")


# async def _generate_code_plan(user_id: str, query_text: str, db: DatabaseService) -> str:
#     """Step 1 of the agentic loop: Generate a Python script based on a schema of lists of dictionaries."""
#     classes_list = db.get_classes_for_chatbot(user_id=user_id)
#     students_list = db.get_students_for_chatbot(user_id=user_id)
#     assessments_list = db.get_assessments_for_chatbot(user_id=user_id)
    
#     schema = f"""
# - `classes`: A list of dictionaries. Each dictionary has keys: {list(classes_list[0].keys()) if classes_list else ['id', 'name', 'description']}
# - `students`: A list of dictionaries. Each dictionary has keys: {list(students_list[0].keys()) if students_list else ['id', 'name', 'studentId', 'class_id', 'overallGrade']}
# - `assessments`: A list of dictionaries. Each dictionary has keys: {list(assessments_list[0].keys()) if assessments_list else ['id', 'job_id', 'student_id', 'grade', 'feedback']}
# """
#     prompt = prompt_library.CODE_GENERATION_PROMPT.format(schema=schema, query=query_text)
#     try:
#         response_json = await gemini_service.generate_json(prompt, temperature=0.1)
#         return response_json["code"]
#     except (KeyError, ValueError) as e:
#         raise ValueError(f"AI failed to generate a valid code plan. Error: {e}")

# async def _execute_code_in_sandbox(user_id: str, code_to_execute: str, db: DatabaseService) -> str:
#     """Step 2 of the agentic loop: Securely execute the AI-generated code."""
    
#     def sync_execute():
#         classes_list = db.get_classes_for_chatbot(user_id=user_id)
#         students_list = db.get_students_for_chatbot(user_id=user_id)
#         assessments_list = db.get_assessments_for_chatbot(user_id=user_id)

#         # This function now uses the corrected, callable PrintCollector class
#         print_collector = PrintCollector()

#         restricted_globals = safe_globals.copy()
#         restricted_globals['classes'] = classes_list
#         restricted_globals['students'] = students_list
#         restricted_globals['assessments'] = assessments_list
#         restricted_globals['_print_'] = print_collector
#         restricted_globals['_getitem_'] = lambda obj, key: obj[key]
        
#         modified_code = code_to_execute

#         try:
#             byte_code = compile_restricted(modified_code, '<string>', 'exec')
#             exec(byte_code, restricted_globals, None)
#             raw_result = print_collector.get_output()
#         except Exception as e:
#             print("--- FAILING AI-GENERATED CODE (Original) ---")
#             print(code_to_execute)
#             print("------------------------------------------")
#             raise ValueError(f"The analysis plan failed during execution: {e}")

#         if not raw_result:
#             return "The analysis ran successfully but produced no output."
            
#         return raw_result
    
#     return await asyncio.to_thread(sync_execute)


# async def _synthesize_natural_language_response(query_text: str, raw_result: str, websocket: WebSocket) -> str:
#     """Step 3 of the agentic loop: Convert the raw result into a natural language response."""
#     prompt = prompt_library.NATURAL_LANGUAGE_SYNTHESIS_PROMPT.format(query=query_text, data=raw_result)
#     return await gemini_service.generate_text_streaming(prompt, websocket)


# # --- Public Service Functions ---
# def start_new_chat_session(user_id: str, request: chatbot_model.NewChatSessionRequest, db: DatabaseService) -> Dict:
#     """Creates a new chat session record in the database."""
#     session_id = f"session_{uuid.uuid4().hex[:12]}"
#     session_name = _generate_chat_name(request.first_message)
#     session_record = {"id": session_id, "user_id": user_id, "name": session_name}
#     db.create_chat_session(session_record)
#     return {"sessionId": session_id}

# async def add_new_message_to_session(session_id: str, user_id: str, message_text: str, file_id: Optional[str], db: DatabaseService, websocket: WebSocket):
#     """Orchestrates the full agentic loop for a single user message."""
#     user_message_record = {"id": f"msg_{uuid.uuid4().hex[:12]}", "session_id": session_id, "role": "user", "content": message_text, "file_id": file_id}
#     db.add_chat_message(user_message_record)
    
#     bot_response_text = ""
#     try:
#         code_plan = await _generate_code_plan(user_id, message_text, db)
#         raw_result = await _execute_code_in_sandbox(user_id, code_plan, db)
#         bot_response_text = await _synthesize_natural_language_response(message_text, raw_result, websocket)
#     except Exception as e:
#         print(f"Error in agentic loop for session {session_id}: {e}")
#         error_message = f"Sorry, I encountered an error and could not answer your question."
#         await websocket.send_json({"type": "error", "payload": {"message": error_message}})
#         bot_response_text = f"Agentic Loop Error: {e}"
        
#     if bot_response_text:
#         bot_message_record = {"id": f"msg_{uuid.uuid4().hex[:12]}", "session_id": session_id, "role": "bot", "content": bot_response_text, "file_id": None}
#         db.add_chat_message(bot_message_record)

# def delete_chat_session_logic(session_id: str, user_id: str, db: DatabaseService) -> bool:
#     """Business logic to safely delete a chat session."""
#     session = db.get_chat_session_by_id(session_id)
#     if not session or session.user_id != user_id:
#         return False
#     return db.delete_chat_session(session_id)

# def get_chat_session_details_logic(session_id: str, user_id: str, db: DatabaseService) -> Optional[Dict]:
#     """Business logic to get the full details of a chat session."""
#     session = db.get_chat_session_by_id(session_id)
#     if not session or session.user_id != user_id:
#         return None

#     messages = db.get_messages_by_session_id(session_id)
    
#     session_details = {
#         "id": session.id,
#         "name": session.name,
#         "created_at": session.created_at,
#         "history": messages 
#     }
#     return session_details

--- File: .\ata-backend\app\services\class_service.py ---

# /ata-backend/app/services/class_service.py (SUPERVISOR-APPROVED FLAWLESS VERSION)

"""
This service module acts as the primary business logic layer for all operations
related to classes and students.

It serves as a facade, orchestrating calls to lower-level specialist helpers
(like `crud` and `roster_ingestion`) and the `DatabaseService`. Every function
in this module has been made "user-aware," requiring a `user_id` to ensure
that all operations are securely scoped to the authenticated user. This module
is the critical link between the API routers and the data access layer.
"""

import pandas as pd
from typing import List, Dict, Optional
from fastapi import UploadFile

from ..models import class_model, student_model
from .database_service import DatabaseService

# Import the specialist helper modules this service orchestrates.
from .class_helpers import roster_ingestion, crud


# --- Facade Methods for CRUD Operations ---

def create_class(
    class_data: class_model.ClassCreate, 
    db: DatabaseService, 
    user_id: str
):
    """
    Business logic to create a new class for the authenticated user.

    This function "stamps" the owner's user_id onto the new class record
    before passing it to the low-level CRUD helper for persistence.
    """
    # Create a dictionary from the Pydantic model and add the owner's ID.
    class_record = {"user_id": user_id, **class_data.model_dump()}
    
    # Delegate the actual database insertion to the CRUD helper.
    return crud.create_class(class_record=class_record, db=db)


def update_class(
    class_id: str, 
    class_update: class_model.ClassCreate, 
    db: DatabaseService, 
    user_id: str
):
    """
    Business logic to update a class, ensuring the user has ownership.
    The user_id is passed down to the CRUD helper for security validation.
    """
    return crud.update_class(
        class_id=class_id, 
        class_update=class_update, 
        db=db, 
        user_id=user_id
    )


def delete_class_by_id(class_id: str, db: DatabaseService, user_id: str) -> bool:
    """
    Business logic to delete a class, ensuring the user has ownership.
    The user_id is passed down to the CRUD helper for security validation.
    """
    return crud.delete_class_by_id(class_id=class_id, db=db, user_id=user_id)


def add_student_to_class(
    class_id: str, 
    student_data: student_model.StudentCreate, 
    db: DatabaseService, 
    user_id: str
):
    """
    Business logic to add a student to a class, ensuring the user owns the class.
    The user_id is passed down to the CRUD helper for security validation.
    """
    return crud.add_student_to_class(
        class_id=class_id, 
        student_data=student_data, 
        db=db, 
        user_id=user_id
    )


def update_student(
    student_id: str, 
    student_update: student_model.StudentUpdate, 
    db: DatabaseService, 
    user_id: str
):
    """
    Business logic to update a student, ensuring the user owns the student's class.
    The user_id is passed down to the CRUD helper for security validation.
    """
    return crud.update_student(
        student_id=student_id, 
        student_update=student_update, 
        db=db, 
        user_id=user_id
    )


def delete_student_from_class(
    class_id: str,
    student_id: str, 
    db: DatabaseService, 
    user_id: str
) -> bool:
    """
    Business logic to delete a student, ensuring the user has ownership of the
    parent class.

    Now removes the student from the class via the membership table,
    but does NOT delete the student record itself (keeps them in assessments).
    """
    # Remove the student from this specific class (removes membership only)
    return db.remove_student_from_class(student_id=student_id, class_id=class_id)


async def create_class_from_upload(
    name: str, 
    file: UploadFile, 
    db: DatabaseService, 
    user_id: str
) -> Dict:
    """
    Business logic to orchestrate class creation from a file upload.
    The user_id is passed down to the ingestion helper to ensure the entire
    process is securely scoped to the authenticated user.
    """
    return await roster_ingestion.create_class_from_upload(
        name=name, 
        file=file, 
        db=db, 
        user_id=user_id
    )


# --- Data Assembly & Export Logic ---

def get_all_classes_with_summary(user_id: str, db: DatabaseService) -> List[Dict]:
    """
    Business logic to retrieve all classes for a user and enrich them with student counts.
    """
    # Securely fetch only the classes belonging to the authenticated user.
    all_classes = db.get_all_classes(user_id=user_id)
    if not all_classes:
        return []

    # Calculate student counts per class using the new junction table
    summary_list = []
    for cls in all_classes:
        # Get students for this specific class
        students_in_class = db.get_students_by_class_id(class_id=cls.id, user_id=user_id)

        summary_data = {
            "id": cls.id,
            "name": cls.name,
            "description": cls.description,
            "studentCount": len(students_in_class)
        }
        summary_list.append(summary_data)
    return summary_list


def get_class_details_by_id(class_id: str, user_id: str, db: DatabaseService) -> Optional[Dict]:
    """
    Business logic to assemble the full details for the Class Details page,
    ensuring the user has ownership of the requested class.
    """
    from ..db.models.assessment_models import ResultStatus
    from ..services.assessment_helpers.analytics_and_matching import normalize_config_to_v2

    # Securely fetch the class, ensuring it belongs to the user.
    class_info = db.get_class_by_id(class_id=class_id, user_id=user_id)
    if not class_info:
        return None

    # Securely fetch the students for that class.
    students_in_class = db.get_students_by_class_id(class_id=class_id, user_id=user_id)

    # Get all assessments for this class
    assessments = db.get_assessments_for_class(class_id=class_id, user_id=user_id)

    # Calculate student grades and class statistics
    student_grades = {}  # {student_id: {"total_earned": X, "total_possible": Y}}
    completed_assessments = 0

    for assessment in assessments:
        # Check if assessment is completed/graded
        if assessment.status == "Completed":
            completed_assessments += 1

        # Get config to calculate max score
        cfg = normalize_config_to_v2(assessment)
        max_total_score = sum(q.maxScore for s in cfg.sections for q in s.questions if q.maxScore is not None)

        # Get all results for this assessment
        for student in students_in_class:
            results = db.get_results_for_student_and_job(
                student_id=student.id,
                job_id=assessment.id,
                user_id=user_id
            )

            if results:
                # Check if all results are graded (not pending)
                all_graded = all(r.status != ResultStatus.PENDING_REVIEW.value for r in results)

                if all_graded:
                    # Calculate student's score for this assessment
                    student_score = sum(float(r.grade) for r in results if r.grade is not None)

                    # Initialize student entry if needed
                    if student.id not in student_grades:
                        student_grades[student.id] = {"total_earned": 0.0, "total_possible": 0.0}

                    student_grades[student.id]["total_earned"] += student_score
                    student_grades[student.id]["total_possible"] += max_total_score

    # Calculate each student's overall grade percentage
    students_with_grades = []
    class_total_earned = 0.0
    class_total_possible = 0.0

    for student in students_in_class:
        student_dict = {
            "id": student.id,
            "name": student.name,
            "studentId": student.studentId,
            "overallGrade": 0,
            "performance_summary": student.performance_summary
        }

        if student.id in student_grades:
            earned = student_grades[student.id]["total_earned"]
            possible = student_grades[student.id]["total_possible"]

            if possible > 0:
                grade_percent = round((earned / possible) * 100)
                student_dict["overallGrade"] = grade_percent

                # Add to class totals
                class_total_earned += earned
                class_total_possible += possible

        students_with_grades.append(student_dict)

    # Calculate class average
    class_average = 0
    if class_total_possible > 0:
        class_average = round((class_total_earned / class_total_possible) * 100)

    analytics_data = {
        "studentCount": len(students_in_class),
        "classAverage": class_average,
        "assessmentsGraded": completed_assessments
    }

    return {
        "id": class_info.id,
        "name": class_info.name,
        "description": class_info.description,
        "students": students_with_grades,
        "analytics": analytics_data
    }


def export_roster_as_csv(class_id: str, user_id: str, db: DatabaseService) -> str:
    """
    Business logic to generate a CSV export for a single class roster,
    ensuring the user has ownership of the class.
    """
    # Securely fetch the class details.
    class_details = db.get_class_by_id(class_id=class_id, user_id=user_id)
    if not class_details:
        raise ValueError(f"Class with ID {class_id} not found or access denied.")
        
    # Securely fetch the students for that class.
    students_in_class = db.get_students_by_class_id(class_id=class_id, user_id=user_id)
    
    export_data = [
        {
            'Student Name': s.name, 
            'Student ID': s.studentId, 
            'Overall Grade': s.overallGrade if s.overallGrade is not None else "N/A", 
            'Class Name': class_details.name
        } for s in students_in_class
    ]
    
    df = pd.DataFrame(export_data) if export_data else pd.DataFrame(columns=['Student Name', 'Student ID', 'Overall Grade', 'Class Name'])
    
    return df.to_csv(index=False)

--- File: .\ata-backend\app\services\dashboard_service.py ---

# /app/services/dashboard_service.py (MODIFIED AND SUPERVISOR-APPROVED - FLAWLESS VERSION)

"""
This service module contains the business logic for calculating the summary
statistics (e.g., class count, student count) displayed on the main
dashboard page.

It has been made "user-aware," ensuring that all calculations are performed
exclusively on the data belonging to the currently authenticated user.
"""

# --- Core Imports ---
from ..models.dashboard_model import DashboardSummary
from .database_service import DatabaseService

# --- Core Public Function ---

def get_summary_data(db: DatabaseService, user_id: str) -> DashboardSummary:
    """
    Calculates the dashboard summary statistics for a specific user.

    This function is the "thick" service layer that contains the business logic.
    It securely retrieves data from the database service using the provided
    `user_id` and performs the necessary aggregations.

    Args:
        db: An instance of the DatabaseService, provided by dependency injection.
        user_id: The unique ID of the currently authenticated user, passed down
                 from the API router.
        
    Returns:
        A DashboardSummary Pydantic object containing the calculated counts
        scoped to the specific user.
    """
    try:
        # --- [CRITICAL MODIFICATION 1/2: SECURE DATA RETRIEVAL] ---
        # Delegate data retrieval to the data access layer, now passing the
        # `user_id` to ensure the queries are securely filtered.

        # This call now uses the secure, user-scoped method to fetch classes.
        user_classes = db.get_all_classes(user_id=user_id)
        
        # To get the student count, we use the secure chatbot helper which
        # correctly performs a join between students and classes and filters by
        # the user's ID. This is the most efficient and secure way to get this count.
        user_students = db.get_students_for_chatbot(user_id=user_id)


        # --- [CRITICAL MODIFICATION 2/2: USER-SPECIFIC LOGIC] ---
        # The business logic itself (counting items) remains the same, but it
        # now operates on securely filtered data.
        class_count = len(user_classes)
        student_count = len(user_students)

        # --- CONSTRUCT & VALIDATE ---
        # Return the data structured according to our Pydantic model.
        # These counts now accurately reflect only the data owned by the user.
        return DashboardSummary(
            classCount=class_count,
            studentCount=student_count
        )
        
    except Exception as e:
        # In a real app, we would add structured logging here.
        print(f"ERROR calculating summary data for user {user_id}: {e}")
        # Re-raise the exception to be handled as a 500 error in the router layer.
        raise

--- File: .\ata-backend\app\services\database_service.py ---

# /ata-backend/app/services/database_service.py (SUPERVISOR-APPROVED FLAWLESS VERSION)

"""
This module defines the DatabaseService, which acts as the central facade
for all data access operations within the application.

It abstracts away the underlying data storage mechanism (now exclusively SQL)
and provides a unified, user-aware interface for higher-level business services.
Every method that interacts with user-owned data now requires a `user_id`,
ensuring strict data isolation and security.
"""

from typing import List, Dict, Optional, Generator
from sqlalchemy.orm import Session
from fastapi import Depends

# --- Core Database Setup ---
from app.db.database import get_db

# --- SQL Repository Imports ---
from .database_helpers.class_student_repository_sql import ClassStudentRepositorySQL
from .database_helpers.assessment_repository_sql import AssessmentRepositorySQL
from .database_helpers.chat_repository_sql import ChatRepositorySQL
from .database_helpers.generation_repository_sql import GenerationRepositorySQL

# --- Import SQLAlchemy Models for Accurate Type Hinting ---
from app.db.models.user_model import User
from app.db.models.class_student_models import Class, Student
from app.db.models.assessment_models import Assessment, Result, ResultStatus, FinalizedBy
from app.db.models.ai_model_run import AIModelRun
from app.db.models.chat_models import ChatSession, ChatMessage
from app.db.models.generation_models import Generation
from app.db.models.outsider_student import OutsiderStudent


class DatabaseService:
    """
    The main facade for all database operations. It ensures that all calls
    are directed to the correct, secure repository methods.
    """
    def __init__(self, db_session: Session):
        """
        Initializes the DatabaseService with a mandatory database session
        and instantiates all necessary SQL repositories.
        """
        self.class_student_repo = ClassStudentRepositorySQL(db_session)
        self.assessment_repo = AssessmentRepositorySQL(db_session)
        self.chat_repo = ChatRepositorySQL(db_session)
        self.generation_repo = GenerationRepositorySQL(db_session)

    # --- NEW: User Management Methods ---
    def get_user_by_id(self, user_id: str) -> Optional[User]:
        return self.class_student_repo.get_user_by_id(user_id=user_id)

    def get_user_by_email(self, email: str) -> Optional[User]:
        return self.class_student_repo.get_user_by_email(email=email)

    def create_user(self, user_data: Dict) -> User:
        return self.class_student_repo.add_user(record=user_data)

    # --- MODIFIED: Class & Student Methods (User-Scoped with Correct Types) ---
    def get_all_classes(self, user_id: str) -> List[Class]:
        return self.class_student_repo.get_all_classes(user_id=user_id)

    def get_class_by_id(self, class_id: str, user_id: str) -> Optional[Class]:
        return self.class_student_repo.get_class_by_id(class_id=class_id, user_id=user_id)

    def add_class(self, class_record: Dict) -> Class:
        return self.class_student_repo.add_class(class_record)

    def update_class(self, class_id: str, user_id: str, class_update_data: Dict) -> Optional[Class]:
        return self.class_student_repo.update_class(class_id=class_id, user_id=user_id, data=class_update_data)

    def delete_class(self, class_id: str, user_id: str) -> bool:
        return self.class_student_repo.delete_class(class_id=class_id, user_id=user_id)

    def get_students_by_class_id(self, class_id: str, user_id: str) -> List[Student]:
        return self.class_student_repo.get_students_by_class_id(class_id=class_id, user_id=user_id)

    def add_student(self, student_record: Dict) -> Student:
        return self.class_student_repo.add_student(student_record)

    def add_outsider_student(self, student_record: Dict) -> OutsiderStudent:
        return self.class_student_repo.add_outsider_student(student_record)

    def update_student(self, student_id: str, user_id: str, student_update_data: Dict) -> Optional[Student]:
        return self.class_student_repo.update_student(student_id=student_id, user_id=user_id, data=student_update_data)

    def delete_student(self, student_id: str, user_id: str) -> bool:
        return self.class_student_repo.delete_student(student_id=student_id, user_id=user_id)
    
    def get_student_by_student_id(self, student_id: str) -> Optional[Student]:
        return self.class_student_repo.get_student_by_student_id(student_id=student_id)

    def get_student_by_id(self, student_id: str, user_id: str) -> Optional[Student]:
        return self.class_student_repo.get_student_by_id(student_id=student_id, user_id=user_id)

    # --- NEW: Student Membership Methods ---
    def get_class_memberships_for_student(self, student_id: str, user_id: str) -> List:
        return self.class_student_repo.get_class_memberships_for_student(student_id=student_id, user_id=user_id)

    def add_student_to_class(self, student_id: str, class_id: str) -> bool:
        return self.class_student_repo.add_student_to_class(student_id=student_id, class_id=class_id)

    def remove_student_from_class(self, student_id: str, class_id: str) -> bool:
        return self.class_student_repo.remove_student_from_class(student_id=student_id, class_id=class_id)

    # --- NEW: Assessment Methods for Student Transcript ---
    def get_assessments_for_class(self, class_id: str, user_id: str) -> List[Assessment]:
        return self.assessment_repo.get_assessments_for_class(class_id=class_id, user_id=user_id)

    def get_results_for_student_and_job(self, student_id: str, job_id: str, user_id: str) -> List[Result]:
        return self.assessment_repo.get_results_for_student_and_job(student_id=student_id, job_id=job_id, user_id=user_id)

    # --- MODIFIED: Generation History Methods ---
    def get_all_generations(self, user_id: str) -> List[Generation]:
        return self.generation_repo.get_all_generations(user_id=user_id)

    def add_generation_record(self, history_record: Dict) -> Generation:
        return self.generation_repo.add_generation_record(history_record)
    
    def delete_generation_record(self, generation_id: str, user_id: str) -> bool:
        return self.generation_repo.delete_generation_record(generation_id=generation_id, user_id=user_id)
    
    # --- MODIFIED: Chat History Methods ---
    def create_chat_session(self, session_record: Dict) -> ChatSession:
        return self.chat_repo.create_session(session_record)

    def get_chat_sessions_by_user_id(self, user_id: str) -> List[ChatSession]:
        return self.chat_repo.get_sessions_by_user_id(user_id)

    def get_chat_session_by_id(self, session_id: str, user_id: str) -> Optional[ChatSession]:
        return self.chat_repo.get_session_by_id(session_id, user_id)

    def add_chat_message(self, message_record: Dict) -> ChatMessage:
        return self.chat_repo.add_message(message_record)

    def get_messages_by_session_id(self, session_id: str, user_id: str) -> List[ChatMessage]:
        return self.chat_repo.get_messages_by_session_id(session_id, user_id)

    def delete_chat_session(self, session_id: str, user_id: str) -> bool:
        return self.chat_repo.delete_session_by_id(session_id, user_id)

    # --- MODIFIED: Assessment Job & Result Methods ---
    def add_assessment_job(self, job_record: Dict) -> Assessment:
        return self.assessment_repo.add_job(job_record)

    def get_assessment_job(self, job_id: str, user_id: str) -> Optional[Assessment]:
        return self.assessment_repo.get_job(job_id, user_id)

    def get_all_assessment_jobs(self, user_id: str) -> List[Assessment]:
        return self.assessment_repo.get_all_jobs(user_id)

    def update_job_status(self, job_id: str, user_id: str, status: str):
        return self.assessment_repo.update_job_status(job_id, user_id, status)

    def update_job_with_summary(self, job_id: str, user_id: str, summary: str):
        return self.assessment_repo.update_job_summary(job_id, user_id, summary)

    def delete_assessment_job(self, job_id: str, user_id: str) -> bool:
        return self.assessment_repo.delete_job(job_id, user_id)

    def create_ai_model_run(self, **kwargs) -> AIModelRun:
        return self.assessment_repo.add_ai_model_run(kwargs)

    def get_ai_model_runs_for_question(self, job_id: str, entity_id: str, question_id: str, is_outsider: bool) -> List[AIModelRun]:
        return self.assessment_repo.get_ai_model_runs_for_question(job_id, entity_id, question_id, is_outsider)

    def update_result_extracted_answer(self, job_id: str, entity_id: str, is_outsider: bool, question_id: str, extracted_answer: str, user_id: str):
        return self.assessment_repo.update_result_extracted_answer(job_id, entity_id, is_outsider, question_id, extracted_answer, user_id)

    def are_any_questions_pending_review(self, job_id: str, user_id: str) -> bool:
        return self.assessment_repo.are_any_questions_pending_review(job_id, user_id)

    def save_student_grade_result(self, result_record: Dict) -> Result:
        return self.assessment_repo.add_result(result_record)

    def get_all_results_for_job(self, job_id: str, user_id: str) -> List[Result]:
        return self.assessment_repo.get_all_results_for_job(job_id, user_id)

    def get_result_by_token(self, token: str) -> Optional[Result]:
        return self.assessment_repo.get_result_by_token(token)

    def update_student_result_with_grade(self, job_id: str, student_id: str, question_id: str, grade: Optional[float], feedback: str, status: str, finalized_by: Optional[str], user_id: str):
        return self.assessment_repo.update_result_grade(job_id, student_id, question_id, grade, feedback, status, finalized_by, user_id)

    def update_outsider_result_grade(self, job_id: str, outsider_student_id: str, question_id: str, grade: Optional[float], feedback: str, status: str, finalized_by: Optional[str], user_id: str):
        return self.assessment_repo.update_outsider_result_grade(job_id, outsider_student_id, question_id, grade, feedback, status, finalized_by, user_id)

    def update_student_result_path(self, job_id: str, student_id: str, path: str, content_type: str, user_id: str):
        return self.assessment_repo.update_result_path(job_id, student_id, path, content_type, user_id)

    def get_entities_with_paths(self, job_id: str, user_id: str) -> List[Dict]:
        return self.assessment_repo.get_entities_with_paths(job_id, user_id)

    def get_outsider_student_by_id(self, outsider_student_id: str, user_id: str) -> Optional[OutsiderStudent]:
        return self.assessment_repo.get_outsider_student_by_id(outsider_student_id, user_id)

    def get_all_outsider_students_for_job(self, job_id: str, user_id: str) -> List[OutsiderStudent]:
        return self.assessment_repo.get_all_outsider_students_for_job(job_id, user_id)

    # --- MODIFIED: Chatbot Helper Methods ---
    def get_classes_for_chatbot(self, user_id: str) -> List[Dict]:
        return self.class_student_repo.get_classes_for_chatbot(user_id=user_id)

    def get_students_for_chatbot(self, user_id: str) -> List[Dict]:
        return self.class_student_repo.get_students_for_chatbot(user_id=user_id)

    def get_assessments_for_chatbot(self, user_id: str) -> List[Dict]:
        return self.assessment_repo.get_assessments_for_chatbot(user_id=user_id)
    
    def get_all_results_for_user(self, user_id: str) -> List[Result]:
        """Pass-through method to get all results for a user."""
        return self.assessment_repo.get_all_results_for_user(user_id=user_id)

        # Add this new method to database_service.py
    def get_public_report_details_by_token(self, token: str) -> Optional[Dict]:
        """Pass-through for the secure public report details query."""
        return self.assessment_repo.get_public_report_details_by_token(token=token)
    
    def get_student_result_path(self, job_id: str, student_id: str, user_id: str) -> Optional[str]:
        """
        Pass-through method to securely retrieve a student's answer sheet path
        for a specific job.
        """
        return self.assessment_repo.get_student_result_path(
            job_id=job_id, 
            student_id=student_id, 
            user_id=user_id
        )
        # Add this inside the DatabaseService class
    def update_result_status(self, job_id: str, student_id: str, question_id: str, status: str, user_id: str):
        """
        Pass-through method to securely update a single result's status.
        """
        return self.assessment_repo.update_result_status(
            job_id=job_id,
            student_id=student_id,
            question_id=question_id,
            status=status,
            user_id=user_id
        )

# --- SIMPLIFIED DEPENDENCY PROVIDER ---
def get_db_service(db: Session = Depends(get_db)) -> Generator[DatabaseService, None, None]:
    """
    FastAPI dependency that provides a DatabaseService instance.
    This simplified version is for a SQL-only production environment.
    """
    yield DatabaseService(db_session=db)

--- File: .\ata-backend\app\services\file_cleanup_service.py ---

# /ata-backend/app/services/file_cleanup_service.py

"""
Service for cleaning up old assessment upload files.
Removes files from completed assessments after a specified time period.
"""

import os
import shutil
from datetime import datetime, timedelta, timezone
from pathlib import Path
from sqlalchemy.orm import Session
from typing import List, Dict

from app.db.models.assessment_models import Assessment
from app.models.assessment_model import JobStatus


class FileCleanupService:
    """
    Service responsible for cleaning up old assessment files.
    """

    def __init__(self, upload_directory: str = "assessment_uploads"):
        """
        Initialize the cleanup service.

        Args:
            upload_directory: Path to the assessment uploads directory
        """
        self.upload_directory = Path(upload_directory)

    def cleanup_old_assessments(
        self,
        db: Session,
        hours_after_completion: int = 12,
        dry_run: bool = False
    ) -> Dict[str, any]:
        """
        Clean up files from assessments completed more than X hours ago.

        Args:
            db: Database session
            hours_after_completion: Hours to wait after completion before deleting files
            dry_run: If True, only report what would be deleted without actually deleting

        Returns:
            Dictionary with cleanup statistics
        """
        # Calculate the cutoff time
        cutoff_time = datetime.now(timezone.utc) - timedelta(hours=hours_after_completion)

        # Find completed assessments older than cutoff
        old_assessments = db.query(Assessment).filter(
            Assessment.status == JobStatus.COMPLETED.value,
            Assessment.created_at < cutoff_time
        ).all()

        stats = {
            "total_found": len(old_assessments),
            "deleted_count": 0,
            "failed_count": 0,
            "space_freed_mb": 0,
            "deleted_jobs": [],
            "failed_jobs": [],
            "dry_run": dry_run
        }

        for assessment in old_assessments:
            job_dir = self.upload_directory / f"job_{assessment.id}"

            # Check if directory exists
            if not job_dir.exists():
                continue

            # Calculate directory size
            dir_size = self._get_directory_size(job_dir)

            if dry_run:
                # In dry run mode, just report what would be deleted
                stats["deleted_jobs"].append({
                    "job_id": assessment.id,
                    "created_at": assessment.created_at.isoformat(),
                    "size_mb": round(dir_size / (1024 * 1024), 2)
                })
                stats["space_freed_mb"] += dir_size / (1024 * 1024)
                stats["deleted_count"] += 1
            else:
                # Actually delete the directory
                try:
                    shutil.rmtree(job_dir)
                    stats["deleted_jobs"].append({
                        "job_id": assessment.id,
                        "created_at": assessment.created_at.isoformat(),
                        "size_mb": round(dir_size / (1024 * 1024), 2)
                    })
                    stats["space_freed_mb"] += dir_size / (1024 * 1024)
                    stats["deleted_count"] += 1
                    print(f"âœ“ Deleted: job_{assessment.id} ({round(dir_size / (1024 * 1024), 2)} MB)")
                except Exception as e:
                    stats["failed_jobs"].append({
                        "job_id": assessment.id,
                        "error": str(e)
                    })
                    stats["failed_count"] += 1
                    print(f"âœ— Failed to delete job_{assessment.id}: {str(e)}")

        stats["space_freed_mb"] = round(stats["space_freed_mb"], 2)
        return stats

    def _get_directory_size(self, directory: Path) -> int:
        """
        Calculate total size of a directory in bytes.

        Args:
            directory: Path to directory

        Returns:
            Total size in bytes
        """
        total_size = 0
        try:
            for dirpath, dirnames, filenames in os.walk(directory):
                for filename in filenames:
                    filepath = Path(dirpath) / filename
                    if filepath.exists():
                        total_size += filepath.stat().st_size
        except Exception as e:
            print(f"Error calculating size for {directory}: {str(e)}")
        return total_size

    def get_cleanup_preview(self, db: Session, hours_after_completion: int = 12) -> Dict:
        """
        Get a preview of what would be cleaned up without actually deleting.

        Args:
            db: Database session
            hours_after_completion: Hours threshold

        Returns:
            Preview statistics
        """
        return self.cleanup_old_assessments(db, hours_after_completion, dry_run=True)


# Singleton instance
_cleanup_service = FileCleanupService()


def get_cleanup_service() -> FileCleanupService:
    """Get the global cleanup service instance."""
    return _cleanup_service


--- File: .\ata-backend\app\services\gemini_service.py ---

# /app/services/gemini_service.py (CLEANED AND FINAL VERSION)

import os
import io
from dotenv import load_dotenv
from typing import List, Dict
import json
import google.generativeai as genai
from google.generativeai.types import GenerationConfig
from PIL import Image
from fastapi import WebSocket

# --- Local Imports ---
from .prompt_library import GEMINI_OCR_PROMPT

# --- CONFIGURATION (STABLE) ---
load_dotenv()
API_KEY = os.getenv("GOOGLE_API_KEY")
if not API_KEY:
    raise ValueError("FATAL ERROR: GOOGLE_API_KEY environment variable is not set.")

GEMINI_PRO_MODEL = 'gemini-2.5-flash' # Correct model for multi-modal
GEMINI_FLASH_MODEL = 'gemini-2.5-flash'
genai.configure(api_key=API_KEY)


# --- CORE GENERATIVE FUNCTIONS ---

async def generate_text(prompt: str, temperature: float = 0.5) -> str:
    """The workhorse for text-only, non-streaming tasks."""
    try:
        model = genai.GenerativeModel(GEMINI_FLASH_MODEL)
        config = GenerationConfig(temperature=temperature)
        response = await model.generate_content_async(prompt, generation_config=config)
        if not response.parts:
            raise ValueError("AI model returned an empty response.")
        return response.text
    except Exception as e:
        print(f"ERROR in generate_text with Gemini API: {e}")
        raise

async def generate_multimodal_response(prompt: str, images: List[Image.Image]) -> str:
    """
    The specialist for multi-modal requests. It accepts a LIST of Pillow Image objects.
    """
    try:
        model = genai.GenerativeModel(GEMINI_PRO_MODEL)
        content = [prompt, *images]
        response = await model.generate_content_async(content)
        if not response.parts:
            raise ValueError("AI model returned an empty response for the multi-modal request.")
        return response.text
    except Exception as e:
        print(f"ERROR in generate_multimodal_response with Gemini API ({len(images)} images): {e}")
        raise

async def generate_text_streaming(prompt: str, websocket: WebSocket) -> str:
    """
    Generates text, streams the response token-by-token over a WebSocket,
    AND returns the final, complete string for persistence.
    """
    full_response = []
    try:
        model = genai.GenerativeModel(GEMINI_FLASH_MODEL)
        stream = await model.generate_content_async(prompt, stream=True)
        
        is_stream_started = False
        async for chunk in stream:
            if chunk.text:
                full_response.append(chunk.text)
                if not is_stream_started:
                    await websocket.send_json({"type": "stream_start", "payload": {}})
                    is_stream_started = True
                await websocket.send_json({"type": "stream_token", "payload": {"token": chunk.text}})

        if is_stream_started:
            await websocket.send_json({"type": "stream_end", "payload": {}})

    except Exception as e:
        print(f"ERROR during streaming generation: {e}")
        try:
            await websocket.send_json({
                "type": "error", 
                "payload": {"message": "Sorry, an error occurred while generating the response."}
            })
        except Exception as ws_error:
            print(f"Failed to send streaming error over WebSocket: {ws_error}")
    
    return "".join(full_response)

async def generate_json(prompt: str, temperature: float = 0.1) -> Dict:
    """
    Generates a response and GUARANTEES the output is a parsable JSON object
    by using the Gemini API's JSON Mode.
    """
    try:
        model = genai.GenerativeModel(GEMINI_FLASH_MODEL)
        config = GenerationConfig(
            temperature=temperature,
            response_mime_type="application/json"
        )
        response = await model.generate_content_async(prompt, generation_config=config)
        if not response.text:
            raise ValueError("AI model returned an empty response.")
        return json.loads(response.text)
    except Exception as e:
        print(f"ERROR in generate_json with Gemini API: {e}")
        raise ValueError(f"Failed to get a valid JSON response from the AI. Error: {e}")

async def generate_multimodal_json(prompt: str, images: List[Image.Image]) -> Dict:
    """
    Generates a JSON response from a multimodal request (text + images),
    guaranteeing a parsable JSON object by using the Gemini API's JSON Mode.
    """
    try:
        model = genai.GenerativeModel(GEMINI_PRO_MODEL)
        config = GenerationConfig(
            temperature=0.1,
            response_mime_type="application/json"
        )
        content = [prompt, *images]
        response = await model.generate_content_async(content, generation_config=config)
        if not response.text:
            raise ValueError("AI model returned an empty response.")
        return json.loads(response.text)
    except Exception as e:
        print(f"ERROR in generate_multimodal_json with Gemini API: {e}")
        raise ValueError(f"Failed to get a valid JSON response from the multimodal AI. Error: {e}")

async def process_file_with_vision(file_bytes: bytes, mime_type: str, prompt: str, temperature: float = 0.1) -> str:
    """
    Processes a file (PDF or image) using Gemini's vision capabilities.
    The AI will OCR, analyze, and respond according to the prompt.
    This replaces traditional OCR with AI vision for better handwriting recognition.
    """
    import tempfile
    temp_file_path = None
    try:
        # Create a temporary file to upload to Gemini
        with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf' if 'pdf' in mime_type else '.png') as temp_file:
            temp_file.write(file_bytes)
            temp_file_path = temp_file.name

        # Upload file to Gemini File API for processing
        uploaded_file = genai.upload_file(
            path=temp_file_path,
            display_name="vision_temp_file",
            mime_type=mime_type
        )

        model = genai.GenerativeModel(GEMINI_FLASH_MODEL)
        config = GenerationConfig(temperature=temperature)

        # Send both the prompt and the file to the AI
        response = await model.generate_content_async(
            [prompt, uploaded_file],
            generation_config=config
        )

        if not response.text:
            raise ValueError("AI model returned an empty response.")

        return response.text
    except Exception as e:
        print(f"ERROR in process_file_with_vision: {e}")
        raise
    finally:
        # Clean up temporary file
        if temp_file_path and os.path.exists(temp_file_path):
            try:
                os.unlink(temp_file_path)
            except Exception:
                pass

async def process_file_with_vision_json(file_bytes: bytes, mime_type: str, prompt: str, temperature: float = 0.1, log_context: str = "") -> Dict:
    """
    Processes a file (PDF or image) using Gemini's vision capabilities and returns JSON.
    The AI will OCR, analyze, and structure the response as JSON according to the prompt.

    Args:
        file_bytes: The file content as bytes
        mime_type: The MIME type of the file
        prompt: The prompt to send to the AI
        temperature: Temperature setting for the AI
        log_context: Optional context string for token logging (e.g., "PARSE-QUESTION", "GRADE-STUDENT")

    Returns:
        Dict with two keys: 'data' (the parsed JSON) and 'tokens' (usage metadata)
    """
    import tempfile
    temp_file_path = None
    try:
        # Create a temporary file to upload to Gemini
        with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf' if 'pdf' in mime_type else '.png') as temp_file:
            temp_file.write(file_bytes)
            temp_file_path = temp_file.name

        # Upload file to Gemini File API for processing
        uploaded_file = genai.upload_file(
            path=temp_file_path,
            display_name="vision_json_temp_file",
            mime_type=mime_type
        )

        model = genai.GenerativeModel(GEMINI_FLASH_MODEL)
        config = GenerationConfig(
            temperature=temperature,
            response_mime_type="application/json"
        )

        # Send both the prompt and the file to the AI with JSON mode
        response = await model.generate_content_async(
            [prompt, uploaded_file],
            generation_config=config
        )

        if not response.text:
            raise ValueError("AI model returned an empty response.")

        # Extract token usage data
        tokens_used = {
            'prompt_tokens': 0,
            'completion_tokens': 0,
            'total_tokens': 0
        }

        if hasattr(response, 'usage_metadata') and response.usage_metadata:
            tokens_used['prompt_tokens'] = getattr(response.usage_metadata, 'prompt_token_count', 0)
            tokens_used['completion_tokens'] = getattr(response.usage_metadata, 'candidates_token_count', 0)
            tokens_used['total_tokens'] = getattr(response.usage_metadata, 'total_token_count', 0)

            # Log token usage
            if log_context:
                print(f"[TOKEN-USAGE] {log_context} - Prompt: {tokens_used['prompt_tokens']}, Completion: {tokens_used['completion_tokens']}, Total: {tokens_used['total_tokens']}")

        return {
            'data': json.loads(response.text),
            'tokens': tokens_used
        }
    except Exception as e:
        print(f"ERROR in process_file_with_vision_json: {e}")
        raise ValueError(f"Failed to get a valid JSON response from the vision AI. Error: {e}")
    finally:
        # Clean up temporary file
        if temp_file_path and os.path.exists(temp_file_path):
            try:
                os.unlink(temp_file_path)
            except Exception:
                pass
    





async def generate_text_streaming(prompt: str, websocket: WebSocket) -> str:
    """
    Generates text, streams the response token-by-token over a WebSocket,
    AND returns the final, complete string for persistence.
    """
    full_response = []
    try:
        model = genai.GenerativeModel(GEMINI_FLASH_MODEL)
        stream = await model.generate_content_async(prompt, stream=True)
        
        is_stream_started = False
        async for chunk in stream:
            if chunk.text:
                full_response.append(chunk.text)
                if not is_stream_started:
                    # Send a start message the moment the first token arrives
                    await websocket.send_json({"type": "stream_start", "payload": {}})
                    is_stream_started = True
                await websocket.send_json({"type": "stream_token", "payload": {"token": chunk.text}})

        if is_stream_started:
            # Always send an end message if the stream was started
            await websocket.send_json({"type": "stream_end", "payload": {}})

    except Exception as e:
        print(f"ERROR during streaming generation: {e}")
        try:
            await websocket.send_json({
                "type": "error", 
                "payload": {"message": "Sorry, an error occurred while generating the response."}
            })
        except Exception as ws_error:
            print(f"Failed to send streaming error over WebSocket: {ws_error}")
    
    return "".join(full_response)

--- File: .\ata-backend\app\services\history_service.py ---


# /ata-backend/app/services/history_service.py (MODIFIED AND APPROVED - FLAWLESS VERSION)

"""
This service module encapsulates all business logic for managing a user's
AI tool generation history.

Every function in this module has been refactored to be "user-aware." It now
requires a `user_id` for all its operations, ensuring that a user can only
create, view, and delete their own history records. This service acts as the
secure intermediary between the `history_router` and the `DatabaseService`.
"""

import uuid
import json
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional
import os

from .database_service import DatabaseService
from ..models.history_model import GenerationRecord, HistoryResponse

# --- HELPER FUNCTION (This is a pure utility and requires no changes) ---
def _generate_title_from_settings(settings: Dict[str, Any], source_filename: Optional[str] = None) -> str:
    """
    Intelligently generates a concise title for a history record based on its settings.
    """
    now = datetime.now(timezone.utc)
    date_str = now.strftime("%Y-%m-%d")
    source_preview = "Untitled Generation"
    if source_filename:
        source_preview = source_filename
    elif settings.get("selected_chapter_paths"):
        try:
            # Safely access parts of the path
            path_parts = settings["selected_chapter_paths"][0].split(os.path.sep)
            if len(path_parts) >= 2:
                source_preview = path_parts[-2]
            else:
                source_preview = "Library Selection"
        except (IndexError, TypeError):
            source_preview = "Library Selection"
    elif settings.get("source_text"):
        source_preview = ' '.join(settings["source_text"].split()[:5])
        if len(settings["source_text"].split()) > 5:
            source_preview += "..."
    if len(source_preview) > 50:
        source_preview = source_preview[:47] + "..."
    return f"{date_str}: {source_preview}"


# --- PUBLIC SERVICE FUNCTIONS (MODIFIED AND SECURE) ---

def save_generation(
    db: DatabaseService,
    user_id: str,  # <-- CRITICAL MODIFICATION: Added user_id
    tool_id: str,
    settings: Dict[str, Any],
    generated_content: str,
    source_filename: Optional[str] = None
) -> GenerationRecord:
    """
    Constructs and persists a new, user-owned history record.

    This function is now secure. It receives the authenticated user's ID and
    "stamps" it onto the new record before saving, ensuring correct ownership.

    Args:
        db: The DatabaseService instance.
        user_id: The ID of the authenticated user who owns this record.
        tool_id: The identifier of the AI tool used.
        settings: A snapshot of the settings used for the generation.
        generated_content: The resulting content from the AI.
        source_filename: The name of the file used as a source, if any.

    Returns:
        A Pydantic `GenerationRecord` model of the newly created record.
    """
    title = _generate_title_from_settings(settings, source_filename)

    history_record_data = {
        "id": f"gen_{uuid.uuid4().hex[:16]}",
        "title": title,
        "tool_id": tool_id,
        "settings_snapshot": settings,
        "generated_content": generated_content,
        "user_id": user_id,  # <-- CRITICAL MODIFICATION: Stamping the owner's ID
    }
    
    # The DatabaseService now persists the record with the correct owner.
    new_generation_obj = db.add_generation_record(history_record_data)
    
    # `model_validate` creates a Pydantic model from the SQLAlchemy object.
    return GenerationRecord.model_validate(new_generation_obj)


def delete_generation(db: DatabaseService, generation_id: str, user_id: str) -> bool:
    """
    Deletes a generation record, but only if it belongs to the specified user.

    This function is now secure. It passes both the record ID and the user's ID
    to the data access layer, which will enforce ownership before deletion.

    Args:
        db: The DatabaseService instance.
        generation_id: The ID of the history record to delete.
        user_id: The ID of the authenticated user attempting the deletion.

    Returns:
        True if the record was found and deleted, False otherwise.
    """
    # Delegate the secure deletion to the DatabaseService.
    was_deleted = db.delete_generation_record(generation_id=generation_id, user_id=user_id)
    return was_deleted


def get_history(
    db: DatabaseService,
    user_id: str,  # <-- CRITICAL MODIFICATION: Added user_id
    search: Optional[str] = None,
    tool_id: Optional[str] = None
) -> HistoryResponse:
    """
    Retrieves the AI generation history exclusively for the authenticated user.

    This function is now secure. It passes the user's ID to the data access
    layer, ensuring that the query only returns records owned by that user,
    preventing any data leakage.

    Args:
        db: The DatabaseService instance.
        user_id: The ID of the authenticated user whose history is being requested.
        search: An optional search term to filter results.
        tool_id: An optional tool ID to filter results.

    Returns:
        A Pydantic `HistoryResponse` object containing the user's filtered history.
    """
    # This call is now secure and will only fetch records for the given user_id.
    all_history_objects = db.get_all_generations(user_id=user_id)
    
    processed_records = []
    for record_obj in all_history_objects:
        try:
            pydantic_record = GenerationRecord.model_validate(record_obj)
            
            # This logic robustly handles cases where the JSON might be stored as a string.
            if isinstance(pydantic_record.settings_snapshot, str):
                pydantic_record.settings_snapshot = json.loads(pydantic_record.settings_snapshot)
            
            processed_records.append(pydantic_record)

        except Exception as e:
            print(f"Skipping corrupted history record: {getattr(record_obj, 'id', 'N/A')}. Error: {e}")
            continue

    # The filtering logic remains the same but now operates on a secure subset of data.
    filtered_results = processed_records
    if tool_id:
        filtered_results = [r for r in filtered_results if r.tool_id.value == tool_id]
    if search:
        search_lower = search.lower()
        filtered_results = [
            r for r in filtered_results 
            if search_lower in r.generated_content.lower() or search_lower in r.title.lower()
        ]
    
    # Sorting also remains the same.
    filtered_results.sort(key=lambda r: r.created_at, reverse=True)
    
    return HistoryResponse(
        results=filtered_results,
        total=len(filtered_results),
        page=1,
        hasNextPage=False
    )



--- File: .\ata-backend\app\services\library_service.py ---

# /app/services/library_service.py

import os
import json
from typing import List, Dict, Any
from pathlib import Path

# --- [START] HARDENED PATH LOGIC ---

# Get the directory where this very file (library_service.py) is located.
# e.g., /path/to/project/ata-backend/app/services
SERVICE_FILE_DIR = Path(__file__).parent.resolve()

# Construct an absolute path to the project's root directory
# by going up two levels (from /services to /app to /).
PROJECT_ROOT_DIR = SERVICE_FILE_DIR.parent.parent

# Construct a robust, absolute path to the Books directory.
BOOKS_ROOT_DIR = PROJECT_ROOT_DIR / "Books"

# --- [END] HARDENED PATH LOGIC ---


# In-memory cache for the library tree.
_library_cache: List[Dict[str, Any]] = []

def _scan_directory_and_build_tree(path: Path) -> List[Dict[str, Any]]:
    """
    Recursively scans a directory and builds a nested list of dictionaries
    representing the folder and file structure. Now uses pathlib.Path.
    """
    items = []
    try:
        # os.scandir works fine with Path objects
        for entry in sorted(os.scandir(path), key=lambda e: e.name):
            # For chapters, we only include .txt files
            if entry.is_file() and not entry.name.endswith('.txt'):
                continue
            
            # Use pathlib for cleaner path joining
            entry_path = Path(entry.path)
            
            item_data = {
                "id": str(entry_path),
                "name": entry_path.name.replace('.txt', ''),
                "path": str(entry_path),
                "children": _scan_directory_and_build_tree(entry_path) if entry_path.is_dir() else None
            }
            items.append(item_data)
    except FileNotFoundError:
        print(f"WARNING: Directory not found during library scan: {path}")
    except Exception as e:
        print(f"ERROR scanning library directory {path}: {e}")
        
    return items

def initialize_library_cache():
    """
    Initializes the in-memory library cache by scanning the root books directory.
    This function is intended to be called once when the FastAPI application starts up.
    """
    global _library_cache
    print("INFO: Scanning book library directory...")
    # Use the robustly constructed absolute path
    if BOOKS_ROOT_DIR.is_dir():
        _library_cache = _scan_directory_and_build_tree(BOOKS_ROOT_DIR)
        print(f"INFO: Book library scan complete. Found {len(_library_cache)} top-level items.")
    else:
        print(f"WARNING: Root books directory '{str(BOOKS_ROOT_DIR)}' not found. Library will be empty.")
        _library_cache = []

def get_library_tree() -> List[Dict[str, Any]]:
    """
    Returns the cached library tree structure.
    """
    return _library_cache

--- File: .\ata-backend\app\services\ocr_service - 2 (use Gemini 2.5 flash lite) but slow.py ---

# /app/services/ocr_service.py (FINAL & ROBUST - MULTIPROCESSING BRIDGE)

# --- Core Imports ---
import io
import asyncio
from multiprocessing import Process, Manager # Import multiprocessing tools

# --- Third-Party Library Imports ---
import docx

# --- Local Service Imports ---
# NOTE: We cannot pass the gemini_service module to the new process.
# The new process must initialize it itself.

# This function will be run in a completely separate process.
def _run_ocr_in_process(file_bytes, mime_type, return_dict):
    """
    This function initializes its own Gemini client and runs the OCR task
    in total isolation to prevent any state/loop conflicts.
    """
    # We must import and configure services INSIDE the new process.
    from . import gemini_service
    
    async def ocr_task():
        return await gemini_service.ocr_file_with_gemini(file_bytes, mime_type)

    try:
        result = asyncio.run(ocr_task())
        return_dict['result'] = result
    except Exception as e:
        return_dict['error'] = str(e) # Pass error message as a string


# --- The Core Function (Synchronous Wrapper using a Process) ---
def extract_text_from_file(file_bytes: bytes, content_type: str) -> str:
    """
    Extracts raw text by calling the Gemini service in a separate, isolated
    process. This is the most robust way to call async code from a sync
    context within a running async application, preventing all state conflicts.
    """
    # --- Logic for Gemini-supported files (PDFs and Images) ---
    if content_type == 'application/pdf' or content_type.startswith('image/'):
        # A Manager dictionary is a special type that can be shared between processes.
        with Manager() as manager:
            return_dict = manager.dict()

            # Create and start a new process.
            p = Process(
                target=_run_ocr_in_process,
                args=(file_bytes, content_type, return_dict)
            )
            p.start()
            p.join() # The main application waits here for the process to finish.

            if 'error' in return_dict:
                print(f"ERROR: OCR task in separate process failed. Upstream error: {return_dict['error']}")
                return ""
            
            return return_dict.get('result', "")

    # --- Logic for DOCX Files (Unchanged) ---
    elif content_type == 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
        try:
            doc = docx.Document(io.BytesIO(file_bytes))
            full_text = [para.text for para in doc.paragraphs]
            text = '\n'.join(full_text)
            return text.strip()
        except Exception as e:
            print(f"ERROR processing .docx file locally: {e}")
            return ""

    # --- Logic for Unsupported Files ---
    else:
        error_message = f"Unsupported file type for processing: '{content_type}'"
        raise ValueError(error_message)

--- File: .\ata-backend\app\services\ocr_service.py ---

# /app/services/ocr_service.py

# --- Core Imports ---
import io

# --- Third-Party Library Imports for OCR ---
import fitz  # PyMuPDF for handling PDFs
import pytesseract
from PIL import Image
import docx # <<< NEW IMPORT for handling .docx files

# --- The Core Function (Upgraded) ---
def extract_text_from_file(file_bytes: bytes, content_type: str) -> str:
    """
    Extracts raw text from a file (PDF, image, or .docx). This upgraded version
    can handle text-based PDFs, image-based (scanned) PDFs, and Word documents.
    """
    text = ""
    
    # --- Logic Branch for PDF Files (Unchanged) ---
    if content_type == 'application/pdf':
        try:
            doc = fitz.open(stream=file_bytes, filetype="pdf")
            
            for page in doc:
                text += page.get_text() + "\n"
            
            if len(text.strip()) < 100:
                print("INFO: Low text yield from PDF. Attempting image-based OCR on each page.")
                scanned_text = ""
                for page_num in range(len(doc)):
                    page = doc.load_page(page_num)
                    pix = page.get_pixmap(dpi=300) 
                    img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                    scanned_text += pytesseract.image_to_string(img) + "\n"
                
                if len(scanned_text.strip()) > len(text.strip()):
                    text = scanned_text

            doc.close()
            return text.strip()
        except Exception as e:
            print(f"ERROR processing PDF with PyMuPDF/Tesseract: {e}")
            return ""

    # --- Logic Branch for Image Files (Unchanged) ---
    elif content_type.startswith('image/'):
        try:
            image = Image.open(io.BytesIO(file_bytes))
            text = pytesseract.image_to_string(image)
            return text.strip()
        except Exception as e:
            print(f"ERROR processing image with Tesseract: {e}")
            return ""

    # --- [START] NEW Logic Branch for DOCX Files ---
    elif content_type == 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
        try:
            # Open the .docx file from the in-memory bytes
            doc = docx.Document(io.BytesIO(file_bytes))
            
            # Extract text from each paragraph in the document
            full_text = [para.text for para in doc.paragraphs]
            text = '\n'.join(full_text)
            return text.strip()
        except Exception as e:
            print(f"ERROR processing .docx file: {e}")
            return ""
    # --- [END] NEW Logic Branch ---

    # --- Logic Branch for Unsupported Files (Updated) ---
    else:
        error_message = f"Unsupported file type for OCR: '{content_type}'"
        raise ValueError(error_message)

--- File: .\ata-backend\app\services\page_count_service.py ---

# /ata-backend/app/services/page_count_service.py

"""
This service provides functionality to count the total number of pages
across multiple uploaded files (PDF, DOCX, and images).

For PDFs: Counts actual pages in the document.
For DOCX: Counts pages (approximation based on page breaks and content).
For Images: Each image counts as 1 page.
"""

import fitz  # PyMuPDF
from docx import Document
from fastapi import UploadFile
from typing import List
from io import BytesIO


async def count_pages_in_file(file: UploadFile) -> int:
    """
    Count the number of pages in a single file based on its type.

    Args:
        file: The uploaded file (PDF, DOCX, or image)

    Returns:
        int: Number of pages in the file

    Raises:
        ValueError: If the file type is not supported
    """
    file_content = await file.read()
    file_type = file.content_type.lower() if file.content_type else ""
    filename_lower = file.filename.lower() if file.filename else ""

    # Reset file pointer for potential reuse
    await file.seek(0)

    # Handle PDF files
    if "pdf" in file_type or filename_lower.endswith(".pdf"):
        try:
            pdf_document = fitz.open(stream=file_content, filetype="pdf")
            page_count = pdf_document.page_count
            pdf_document.close()
            return page_count
        except Exception as e:
            raise ValueError(f"Error reading PDF file '{file.filename}': {str(e)}")

    # Handle DOCX files
    elif "wordprocessingml" in file_type or filename_lower.endswith(".docx"):
        try:
            doc = Document(BytesIO(file_content))
            # Count pages based on explicit page breaks
            page_count = 1  # Start with 1 page
            for paragraph in doc.paragraphs:
                # Check if paragraph contains a page break
                if '\f' in paragraph.text or '\x0c' in paragraph.text:
                    page_count += 1
                # Check for page break in runs
                for run in paragraph.runs:
                    if run._element.xml.find('w:br') != -1 and 'w:type="page"' in run._element.xml:
                        page_count += 1

            # If no explicit page breaks found, estimate based on content
            if page_count == 1 and len(doc.paragraphs) > 0:
                # Rough estimation: ~45 lines per page, ~2 paragraphs per line on average
                estimated_lines = sum(1 for p in doc.paragraphs if p.text.strip())
                page_count = max(1, estimated_lines // 45)

            return page_count
        except Exception as e:
            raise ValueError(f"Error reading DOCX file '{file.filename}': {str(e)}")

    # Handle image files (JPEG, PNG, etc.)
    elif any(img_type in file_type for img_type in ["image/jpeg", "image/png", "image/jpg"]) or \
         any(filename_lower.endswith(ext) for ext in [".jpg", ".jpeg", ".png"]):
        # Each image counts as 1 page
        return 1

    else:
        raise ValueError(f"Unsupported file type: {file.filename} ({file_type})")


async def count_total_pages(files: List[UploadFile]) -> int:
    """
    Count the total number of pages across all uploaded files.

    Args:
        files: List of uploaded files (can be PDFs, DOCX, or images)

    Returns:
        int: Total number of pages across all files
    """
    total_pages = 0

    for file in files:
        try:
            pages = await count_pages_in_file(file)
            total_pages += pages
        except ValueError as e:
            # Log the error but continue processing other files
            print(f"Warning: {str(e)}")
            # Assume 1 page for files that can't be processed
            total_pages += 1

    return total_pages


--- File: .\ata-backend\app\services\pdf_service.py ---

import io
from PIL import Image

def compress_image(image_bytes: bytes, max_size_kb: int = 150) -> bytes:
    """
    Compresses an image to be under a specified size in kilobytes.
    Converts the image to JPEG for effective compression.
    """
    img = Image.open(io.BytesIO(image_bytes)).convert("RGB")

    # Start with high quality and decrease until the size is acceptable
    quality = 95
    # Use a buffer to hold the compressed image data in memory
    buffer = io.BytesIO()

    while quality > 10:
        buffer.seek(0)
        buffer.truncate()
        img.save(buffer, format="JPEG", quality=quality, optimize=True)
        if len(buffer.getvalue()) / 1024 <= max_size_kb:
            return buffer.getvalue()
        quality -= 5
        
    return buffer.getvalue()

def merge_images_to_pdf(image_bytes_list: list[bytes]) -> bytes:
    """
    Merges a list of image bytes into a single PDF file in memory.
    """
    if not image_bytes_list:
        raise ValueError("Cannot create a PDF from an empty list of images.")

    # Convert image bytes to PIL Image objects
    try:
        images = [Image.open(io.BytesIO(img_bytes)).convert("RGB") for img_bytes in image_bytes_list]
    except Exception as e:
        raise ValueError(f"Failed to read one of the images. Error: {e}")

    # Get the first image to use as the base for the PDF
    first_image = images[0]
    other_images = images[1:]

    pdf_buffer = io.BytesIO()
    try:
        first_image.save(
            pdf_buffer,
            format="PDF",
            save_all=True,
            append_images=other_images
        )
    except Exception as e:
        raise IOError(f"Failed to save images to PDF. Error: {e}")

    return pdf_buffer.getvalue()

--- File: .\ata-backend\app\services\prompt_library.py ---

# /app/services/prompt_library.py

"""
This file is the central, version-controlled library for all master prompts
used by the application's AI services. Treating prompts as code and
centralizing them here is a core architectural principle.
"""

ROSTER_EXTRACTION_PROMPT = """
You are an expert data extraction assistant. Your task is to parse the following raw text extracted from a class roster document and convert it into a structured JSON object.

**--- RULES ---**

1.  **IDENTIFY STUDENTS:** Your primary goal is to identify each distinct student in the text.
2.  **EXTRACT NAME & ID:** For each student, you MUST extract their full name and their student ID number.
3.  **CRITICAL NAME RULE:** DO NOT abbreviate, truncate, shorten, or return only the first name. You MUST return the complete full name as you find it (e.g., "First Name Last Name").
4.  **STANDARDIZE FORMAT:** If a name is in "Last, First" format, you must standardize it to "First Name Last Name".
5.  **IGNORE EXTRA TEXT:** Ignore all other text like headers, footers, course names, or page numbers.
6.  **JSON STRUCTURE:** Your output MUST be a valid JSON object with a single key "students". The value must be an array of objects, where each object has two keys: "name" (string) and "studentId" (string).
7.  **EMPTY ROSTER:** If you cannot find any students, return an empty students array.
8.  **CRITICAL FORMATTING:** Your entire response must be ONLY the JSON object. Do not include any introductory text or wrap the JSON in markdown backticks like ```json ... ```.

**--- RAW TEXT TO PARSE ---**
{raw_ocr_text}
---
"""
# --- [END OF FIX] ---


# --- [THE FINAL FIX IS HERE: HARDENED MULTI-MODAL PROMPT] ---
MULTIMODAL_ROSTER_EXTRACTION_PROMPT = """
You are an expert data extraction assistant with advanced optical character recognition capabilities. Your task is to analyze the provided IMAGE of a class roster and convert it into a structured JSON object.

**--- PRIMARY DIRECTIVE & RULES ---**

1.  **IMAGE IS TRUTH:** The provided IMAGE is your primary source of evidence. Use the "Extracted OCR Text" as a helpful guide, but you MUST prioritize the text visible in the IMAGE.
2.  **IDENTIFY STUDENTS:** Your goal is to identify each distinct student on the roster.
3.  **EXTRACT NAME & ID:** For each student, you must extract their full name and their student ID number.
4.  **CRITICAL NAME RULE:** DO NOT abbreviate, truncate, shorten, or return only the first name. You MUST return the complete full name you see in the image.
5.  **IGNORE EXTRA TEXT:** You must ignore all other text on the page, such as headers, course titles, or page numbers.
6.  **CRITICAL OUTPUT FORMAT:** Your entire output MUST be a single, valid JSON object, perfectly matching the structure in the provided `example_json`. Do not include any introductory text or markdown backticks.
7.  **EMPTY ROSTER:** If you cannot confidently identify any students in the image, you MUST return a JSON object with an empty students array.

**--- CONTEXT ---**

*   **Extracted OCR Text (For Reference Only):**
    ---
    {raw_ocr_text}
    ---

*   **Example of Required JSON Structure:**
    ---
    {example_json}
    ---

**--- REQUIRED OUTPUT (VALID JSON OBJECT ONLY) ---**

Analyze the provided IMAGE now and generate the JSON output.
"""
# --- [END OF FIX] ---

# --- [START] UPGRADED V2 Question Generator Prompt ---
QUESTION_GENERATOR_PROMPT_V2 = """
You are an expert educational content creator and a seasoned teacher's assistant, specializing in crafting high-quality assessment materials. Your tone is professional, clear, and focused on pedagogical value.

Your task is to generate a set of questions based on the provided "Source Text" and a detailed "Question Generation Plan". You MUST adhere to all rules with absolute precision.

**--- RULES & CONSTRAINTS ---**

1.  **Target Audience:** All questions MUST be aligned with the specified **Grade Level**: `{grade_level}`.
2.  **Source Material:** All questions MUST be derived directly from the **Source Text**.
3.  **[CRITICAL] Pedagogical Focus:** All questions MUST assess understanding of the core educational concepts within the source text. You are strictly forbidden from generating trivial questions about the text's formatting, publication details, or any "meta" content. For example, DO NOT ask questions like "What is the access code for this book?" or "On which page is the glossary?". Focus ONLY on the learning material.
4.  **EXECUTE THE PLAN:** You have been given a **Question Generation Plan** detailing the exact types, counts, and difficulty levels of questions to create. You MUST follow this plan exactly.
5.  **DIFFICULTY:** You MUST adjust the complexity, cognitive demand, and nuance of each question to match its specified difficulty level.
6.  **Answer Key:** You MUST provide a separate "Answer Key" section at the very end of your output, formatted with a `## Answer Key` header.
7.  **Question Formatting:** The question number (e.g., 1., 2.) and the question text MUST be on the same line. Do not put a newline between them.
8.  **Multiple-Choice Formatting:** For every multiple-choice question, each option (A, B, C, D, etc.) MUST be on its own new line.
9.  **Question Stem Formatting:** The main text of the question itself (the "stem") MUST be formatted in bold using double asterisks (`**text**`). The options (A, B, C, D) should NOT be bold.
10. **Matching Question Formatting:** If generating "Matching questions," you MUST format them as a Markdown table with three columns: the first for the items to be matched, a blank middle column for the student to write in, and the third column for the options.
11. **Answer Distribution:** You MUST ensure a balanced and random distribution of correct answers for objective questions. For multiple-choice, the correct option (A, B, C, D) should be varied. For True/False, the number of true and false statements should be approximately equal.

**--- TASK PARAMETERS ---**

*   **Grade Level:** `{grade_level}`
*   **Source Text:**
    ---
    {source_text}
    ---
*   **Question Generation Plan:**
    ---
    {generation_plan_string}
    ---

**--- EXAMPLE OF REQUIRED FORMATTING ---**

## Multiple-choice questions

**1. What is the capital of France?**
A. Berlin
B. Madrid
C. Paris
D. Rome

## Short-answer questions

**2. Explain the process of photosynthesis.**

## Answer Key
1. C
2. Photosynthesis is the process...

**--- REQUIRED OUTPUT ---**

Begin your generation now.
"""
# --- [END] UPGRADED V2 Question Generator Prompt ---



# --- Question Generator Prompt (Chapter 6) ---
QUESTION_GENERATOR_PROMPT = """
You are an expert educational content creator and a seasoned teacher's assistant, specializing in crafting high-quality assessment materials. Your tone is professional, clear, and focused on pedagogical value.

Your task is to generate a set of questions based on the provided "Source Text". You MUST adhere to the following rules and constraints with absolute precision.

**--- RULES & CONSTRAINTS ---**

1.  **Target Audience:** The complexity, vocabulary, and cognitive demand of the questions MUST be perfectly aligned with the specified **Grade Level**: `{grade_level}`.
2.  **Source Material:** All questions MUST be derived directly from the provided **Source Text**. Do not introduce external information or concepts not present in the text.
3.  **Question Types:** You MUST generate ONLY the question types specified in the **Requested Question Types** list. If a type is not requested, do not generate it.
4.  **Number of Questions:** You MUST generate exactly the specified **Number of Questions**. Distribute the questions as evenly as possible among the requested types.
5.  **Clarity and Brevity:** Each question must be grammatically correct, unambiguous, and concise.
6.  **Answer Key (For Multiple Choice):** For every multiple-choice question, you MUST provide an answer key that clearly indicates the correct option.
7.  **Output Format:** Your final output MUST be a single, continuous block of text formatted using simple Markdown. Do not wrap your response in JSON, code blocks, or any other format. Use Markdown headers (`##`) to delineate question types. 

**--- TASK PARAMETERS ---**

*   **Grade Level:** `{grade_level}`
*   **Requested Question Types:** `{question_types_string}`
*   **Number of Questions:** `{num_questions}`

**--- SOURCE TEXT ---**

{source_text}

**--- REQUIRED OUTPUT ---**

Begin your generation now.
"""

# --- Slide Generator Prompt (Chapter 6) ---
SLIDE_GENERATOR_PROMPT = """
You are a professional instructional designer and an expert presentation creator. You excel at distilling complex information into clear, concise, and engaging presentation outlines for an educational setting.

Your task is to create a presentation outline based on the provided "Source Text" or "Topic". You MUST adhere to the following rules and formatting instructions with absolute precision.

**--- RULES & CONSTRAINTS ---**

1.  **Audience Level:** The vocabulary, depth of content, and complexity of the concepts MUST be strictly aligned with the specified **Grade Level**: `{grade_level}`.
2.  **Content Source:** The content for the slides MUST be derived exclusively from the provided **Source Text**. Do not introduce external facts, figures, or concepts.
3.  **Logical Structure:** The presentation must have a clear narrative flow: an introduction, a body, and a conclusion.
4.  **Slide Format:** Each slide must be clearly delineated.
    *   Every slide MUST begin with a title formatted as a Markdown header (`## Slide Title`).
    *   The content of each slide MUST be a series of concise bullet points, each starting with a hyphen (`-`).
    *   Bullet points should be brief and summarize key ideas; they should not be full paragraphs.
5.  **Slide Delimiter:** This is the most important rule. You MUST separate every single slide with a unique delimiter on its own line: `---SLIDE---`. This includes the space between the title slide and the first content slide.
6.  **Number of Slides:** You MUST generate approximately the specified **Number of Slides**. A deviation of +/- 1 slide is acceptable to maintain logical flow. The total number MUST include a title slide and a summary slide.
7.  **Output Format:** Your entire response MUST be a single, continuous block of plain text formatted with simple Markdown. Do not wrap your response in JSON, code blocks, or any other format.

**--- TASK PARAMETERS ---**

*   **Grade Level:** `{grade_level}`
*   **Approximate Number of Slides:** `{num_slides}`
*   **Source Text / Topic:** `{source_text}`

**--- EXAMPLE OUTPUT STRUCTURE ---**

## Title of the Presentation
- Key Subtitle or Presenter's Name

---SLIDE---

## Slide 2: Introduction
- Brief overview of the topic.
- What the audience will learn.

---SLIDE---

## Slide 3: Key Concept A
- Supporting point 1.
- Supporting point 2.

---SLIDE---

## Final Slide: Summary & Conclusion
- Recap of the main points covered.
- A concluding thought or call to action.

**--- REQUIRED OUTPUT ---**

Begin your generation now based on the provided parameters and source text.
"""

# --- [START] UPGRADED V2 Slide Generator Prompt ---
SLIDE_GENERATOR_PROMPT_V2 = """
You are a professional instructional designer and an expert presentation creator. You excel at distilling complex information into clear, concise, and engaging presentation outlines for an educational setting.

Your task is to create a presentation outline based on the provided "Source Text" or "Topic". You MUST adhere to the following rules and formatting instructions with absolute precision.

**--- RULES & CONSTRAINTS ---**

1.  **Audience Level:** The vocabulary, depth of content, and complexity MUST be strictly aligned with the specified **Grade Level**: `{grade_level}`.
2.  **Stylistic Tone:** The overall tone of the content (titles and bullet points) MUST reflect the requested **Slide Style**: `{slide_style}`.
3.  **Content Source:** The content for the slides MUST be derived exclusively from the provided **Source Text**. Do not introduce external facts.
4.  **Slide Format:**
    *   Every slide MUST begin with a title formatted as a Markdown header (`## Slide Title`).
    *   The content of each slide MUST be a series of concise bullet points, each starting with a hyphen (`-`).
5.  **Speaker Notes:** If **Include Speaker Notes** is `True`, you MUST add a section at the end of each slide's bullet points that begins with `**Speaker Notes:**` followed by a brief, helpful note for the presenter. If `False`, you MUST NOT include this section.
6.  **Slide Delimiter:** This is the most important rule. You MUST separate every single slide with a unique delimiter on its own line: `---SLIDE---`.
7.  **Number of Slides:** You MUST generate approximately the specified **Number of Slides**. The total MUST include a title slide and a summary slide.
8.  **Output Format:** Your entire response MUST be a single, continuous block of plain text formatted with simple Markdown. Do not wrap it in JSON or code blocks.

**--- TASK PARAMETERS ---**

*   **Grade Level:** `{grade_level}`
*   **Approximate Number of Slides:** `{num_slides}`
*   **Slide Style:** `{slide_style}`
*   **Include Speaker Notes:** `{include_speaker_notes}`
*   **Source Text / Topic:**
    ---
    {source_text}
    ---

**--- EXAMPLE OUTPUT STRUCTURE (with Speaker Notes) ---**

## Title of the Presentation
- Key Subtitle

---SLIDE---

## Slide 2: Introduction
- Brief overview of the topic.
- What the audience will learn.
**Speaker Notes:** Start by asking the class what they already know about this topic to gauge prior knowledge.

---SLIDE---

## Final Slide: Summary
- Recap of the main points.
**Speaker Notes:** Conclude by assigning the follow-up reading.

**--- REQUIRED OUTPUT ---**

Begin your generation now.
"""
# --- [END] UPGRADED V2 Slide Generator Prompt ---


# --- Rubric Generator Prompt (Chapter 6) ---
RUBRIC_GENERATOR_PROMPT = """
You are a master educator and curriculum design expert with decades of experience in creating fair, effective, and detailed assessment rubrics. Your expertise is in breaking down assignment requirements into measurable, observable criteria.

Your task is to generate a comprehensive grading rubric in a Markdown table format based on the provided assignment details. You MUST follow all rules and formatting instructions with absolute precision.

**--- RULES & CONSTRAINTS ---**

1.  **Audience Level:** The language and expectations in the rubric descriptions MUST be appropriate for the specified **Grade Level**: `{grade_level}`.
2.  **Core Task:** You must create a Markdown table.
3.  **Table Structure:**
    *   The first column of the table MUST be named "Criteria".
    *   The subsequent columns MUST be the **Performance Levels**, in the exact order provided: `{levels_string}`.
    *   There MUST be one row for each of the provided **Assessment Criteria**.
4.  **Content Generation:** For each cell in the table, you must write a clear, concise, and objective description of what a student's work looks like at that specific performance level for that specific criterion. The descriptions should be actionable and constructive.
5.  **Output Format:** Your ENTIRE output must be the Markdown table. Do not include any introductory sentences, concluding remarks, or any text whatsoever outside of the table itself. Do not wrap the table in code blocks.

**--- TASK PARAMETERS ---**

*   **Grade Level:** `{grade_level}`
*   **Assignment Title:** `{assignment_title}`
*   **Assignment Description:** `{assignment_description}`
*   **Assessment Criteria (Table Rows):** `{criteria_string}`
*   **Performance Levels (Table Columns):** `{levels_string}`

**--- EXAMPLE OUTPUT FORMAT ---**

| Criteria | Exemplary | Proficient | Developing | Needs Improvement |
| :--- | :--- | :--- | :--- | :--- |
| **Thesis Statement** | Thesis is exceptionally clear, arguable, and insightful, providing a strong roadmap for the entire essay. | Thesis is clear and arguable, and provides a solid guide for the essay. | Thesis is present but may be vague, too broad, or not fully arguable. | Thesis is missing, unclear, or does not address the prompt. |
| **Evidence & Analysis** | Evidence is consistently relevant, well-chosen, and deeply analyzed to powerfully support the thesis. | Evidence is relevant and used effectively to support the thesis with clear analysis. | Evidence is present but may be insufficient, not fully relevant, or analyzed superficially. | Evidence is missing, irrelevant, or presented without any analysis. |

**--- REQUIRED OUTPUT ---**

Begin your generation now. Produce ONLY the Markdown table.
"""

# --- [START] NEW V2 Rubric Generator Prompt ---
RUBRIC_GENERATOR_PROMPT_V2 = """
You are a master educator and curriculum design expert with decades of experience in creating fair, effective, and detailed assessment rubrics. Your expertise is in breaking down assignment requirements into measurable, observable criteria.

Your task is to generate a comprehensive grading rubric in a Markdown table format. You MUST follow all rules and context with absolute precision.

**--- CONTEXT ---**

You have been provided with the "Assignment Context," which describes the task students must complete.
You have ALSO been provided with optional "Rubric Guidance," which might be a sample rubric, a list of keywords, or general notes on how to grade.

Your primary goal is to create a rubric that is PERFECTLY ALIGNED with the "Assignment Context." Use the "Rubric Guidance" as a strong inspiration for the style and content of your descriptions, but ensure the final rubric directly assesses the specific tasks mentioned in the "Assignment Context." If no guidance is provided, generate the best possible rubric from scratch based only on the assignment.

**--- RULES & CONSTRAINTS ---**

1.  **Audience Level:** The language and expectations in the rubric descriptions MUST be appropriate for the specified **Grade Level**: `{grade_level}`.
2.  **Core Task:** You must create a single, valid Markdown table.
3.  **Table Structure:**
    *   The first column of the table MUST be named "Criteria".
    *   The subsequent columns MUST be the **Performance Levels**, in the exact order provided: `{levels_string}`.
    *   There MUST be one row for each of the provided **Assessment Criteria**: `{criteria_string}`.
4.  **Content Generation:** For each cell in the table, you must write a clear, concise, and objective description of what a student's work looks like at that specific performance level for that specific criterion. The descriptions should be actionable and constructive.
5.  **Output Format:** Your ENTIRE response must be ONLY the Markdown table. Do not include any introductory sentences, concluding remarks, or any text whatsoever outside of the table itself. Do not wrap the table in code blocks.
6.  make sure you do not generate to much dash lines, this is very important, make sure your table should be simple, too much dash or "-" makes the output wrong,
**--- TASK PARAMETERS ---**

*   **Grade Level:** `{grade_level}`
*   **Assessment Criteria (Table Rows):** `{criteria_string}`
*   **Performance Levels (Table Columns):** `{levels_string}`

*   **Assignment Context (The "What" to Grade):**
    ---
    {assignment_context_text}
    ---

*   **Rubric Guidance (The "How" to Grade - Optional):**
    ---
    {rubric_guidance_text}
    ---

**--- REQUIRED OUTPUT (Markdown Table ONLY) ---**

Begin your generation now.
"""
# --- [END] NEW V2 Rubric Generator Prompt ---


# --- [CORRECTED PROMPT FOR REFACTORED ASSESSMENT PIPELINE] ---
MULTIMODAL_GRADING_PROMPT = """
You are a highly experienced and objective Teaching Assistant. Your sole purpose is to grade a student's answer for a specific question based on the provided rubric. You must be impartial, consistent, and base your entire assessment ONLY on the provided materials.

**--- PRIMARY DIRECTIVE & RULES OF ENGAGEMENT ---**

1.  **THE IMAGE IS THE SINGLE SOURCE OF TRUTH:** You will be provided with a scanned IMAGE of a student's handwritten answer. This image is the definitive evidence. You will also be given "Student's Answer Text" (which was extracted from the image) as a convenience. If the extracted text and the handwritten text in the image differ, you MUST base your entire assessment on the handwritten text in the IMAGE.
2.  **THE RUBRIC IS YOUR ONLY LAW:** You MUST grade the student's answer strictly and exclusively according to the provided "Grading Rubric". Do not use any external knowledge.
3.  **FOCUS ON A SINGLE QUESTION:** The materials provided are for a single "Exam Question". Your grade and feedback must pertain only to the student's answer for this specific question.
4.  **PRODUCE HELPFUL, RUBRIC-BASED FEEDBACK:** Your feedback must be constructive, professional, and explicitly reference the rubric's criteria to justify the grade.
5.  **INCLUDE IMPROVEMENT TIPS (If Requested):** If the `{include_tips}` flag is true, add a final section to your feedback called "### Improvement Tips" with 1-2 specific, actionable suggestions for the student.
6.  **THE OUTPUT MUST BE PERFECT JSON:** This is a non-negotiable technical requirement. Your entire output MUST be a single, valid JSON object with no text before or after it. Do not wrap it in Markdown. The JSON object must have exactly two keys:
    *   `"grade"` (number): The final numerical score for this single question, out of a maximum of `{max_score}`.
    *   `"feedback"` (string): The detailed, constructive, rubric-based feedback text, formatted with simple Markdown.

**--- ASSESSMENT MATERIALS ---**

**1. GRADING RUBRIC (Your Law):**
---
{rubric_text}
---

**2. EXAM QUESTION (The Task):**
---
{question_text}
---

**3. STUDENT'S ANSWER TEXT (For Reference):**
---
{answer_text}
---

**--- REQUIRED OUTPUT (VALID JSON OBJECT ONLY) ---**

Analyze the handwritten answer in the provided image based on the materials and rules. Generate the JSON output now.
"""



# --- Chatbot Agent Code Generation Prompt (Chapter 8 - V3 FINAL) ---
# NOTE: Separating the example into a placeholder to avoid KeyError.
# --- [THE FIX IS HERE] ---
# --- [THE FINAL FIX IS HERE: SIMPLIFIED EXAMPLE] ---
CODE_GENERATION_PROMPT = """
You are a world-class, security-conscious Python data analyst. Your sole purpose is to answer a user's question by writing a Python script that processes predefined lists of dictionaries.

**--- PRIMARY DIRECTIVE & NON-NEGOTIABLE RULES ---**

1.  **YOUR GOAL:** You MUST write a single, self-contained Python script to find the answer to the "User's Question".
2.  **AVAILABLE TOOLS:** You can ONLY use standard Python data manipulation (loops, list comprehensions, etc.) on the provided lists of dictionaries. You are strictly forbidden from using any library (e.g., `os`, `sys`, `requests`, `pandas`). `import` statements are strictly forbidden and will fail.
3.  **DATA SCHEMA:** The only data available to you is defined in the "Available Data" section. You MUST use the exact list and key names provided.
4.  **THE FINAL OUTPUT:** The very last line of your script MUST be a `print()` statement that outputs the final answer. The answer should be a simple data type (e.g., a string, a number, a list of strings). ONLY the final answer should be printed.
5.  **YOUR RESPONSE FORMAT:** This is a critical technical requirement. Your entire response MUST be a single, valid JSON object as a raw string. The JSON object must have exactly one key: `"code"`. The value of this key must be a single string containing the complete Python script.

**--- AVAILABLE DATA (LISTS OF DICTIONARIES) ---**
{schema}

**--- USER'S QUESTION ---**
{query}

**--- EXAMPLE OF THE PYTHON CODE TO GENERATE ---**
# User's Question: "How many students are in my '10th Grade World History' class?"
# Your generated Python code string should be:
# target_class = [c for c in classes if c['name'] == '10th Grade World History']
# if target_class:
#     class_id = target_class[0]['id']
#     student_count = len([s for s in students if s['class_id'] == class_id])
#     print(student_count)
# else:
#     print('Class not found.')

**--- REQUIRED OUTPUT (VALID JSON OBJECT WITH A 'code' KEY ONLY) ---**

Generate the JSON response now.
"""

# --- Chatbot Agent Synthesis Prompt (Chapter 8) ---
NATURAL_LANGUAGE_SYNTHESIS_PROMPT = """
You are the ATA Chatbot, a friendly, professional, and helpful AI assistant for teachers. Your persona is that of an expert data analyst who is presenting their findings.

**--- PRIMARY DIRECTIVE ---**

Your sole task is to provide a clear, concise, and helpful natural language answer to the "User's Original Question". You have been provided with the "Raw Data Result" which contains the definitive, factually correct answer. You MUST use this data to formulate your response.

**--- NON-NEGOTIABLE RULES FOR YOUR RESPONSE ---**

1.  **BE A SYNTHESIZER, NOT A REPORTER:** Do not just state the raw data. You MUST synthesize the data and the user's question into a complete, conversational answer. For example, if the question is "How many students?" and the data is "5", your answer should be "There are 5 students." not just "5".
2.  **BE CONCISE AND DIRECT:** Get straight to the point. Teachers are busy. Avoid unnecessary conversational filler like "Of course, I'd be happy to help with that!" or "Certainly, here is the information you requested:". Start your response directly with the answer.
3.  **FORMAT FOR MAXIMUM READABILITY:** Use simple Markdown to make your answer easy to scan in a chat window.
    *   Use bolding (`**text**`) for emphasis on key terms or results.
    *   Use bulleted lists (starting with `- `) for lists of items (like student names).
    *   Do NOT use complex tables unless the raw data is already in a structured, multi-column format.
4.  **DO NOT MAKE THINGS UP OR INFER:** Your answer MUST be based exclusively on the provided "Raw Data Result". Do not add any information, advice, or facts that are not present in the data. If the data is an empty list or "Not Found", your response should state that clearly (e.g., "No students were found matching that criteria.").
5.  **DO NOT REVEAL YOUR PROCESS:** This is the most important rule. You must NEVER mention that you ran a script, executed code, or are looking at "data". The user's experience should be seamless and magical. You are an expert assistant who simply knows the answer. Maintain this illusion at all costs.

**--- CONTEXT FOR SYNTHESIS ---**

*   **User's Original Question:** "{query}"
*   **Raw Data Result (from code execution):** "{data}"

**--- REQUIRED RESPONSE (NATURAL LANGUAGE ONLY) ---**

Generate the user-facing, natural language response now.
"""




# --- AI-Powered Analytics Summary Prompt (Chapter 7 - Perfected Plan) ---
ANALYTICS_SUMMARY_PROMPT = """
You are an expert educational data analyst. Your task is to analyze a JSON object containing the complete results of a graded assessment and generate a concise, insightful, and actionable summary for the teacher.

**--- PRIMARY DIRECTIVE & RULES ---**

1.  **YOUR GOAL:** Write a brief, high-level summary that identifies the most important patterns and takeaways from the provided assessment data.
2.  **TONE:** Your tone should be professional, data-driven, and supportive. You are an assistant highlighting key points for a busy teacher.
3.  **FOCUS ON INSIGHTS, NOT RAW DATA:** Do not simply restate the numbers. Interpret what the numbers mean. For example, instead of saying "The average score on Question 3 was 65%," say "Students generally found Question 3 to be the most challenging."
4.  **CRITICAL OUTPUT FORMAT:** Your entire response MUST be a single block of text formatted using Markdown. It MUST consist of a short introductory sentence followed by exactly three bullet points.
5.  **CONTENT OF BULLET POINTS:**
    *   **Bullet 1 (Overall Performance):** Make a general statement about the class's overall performance (e.g., "strong," "solid," "mixed," "areas for review").
    *   **Bullet 2 (Specific Strengths/Challenges):** Identify a specific area of strength or, more importantly, a common challenge. This should typically be related to the question with the lowest average score.
    *   **Bullet 3 (Actionable Suggestion):** Provide a brief, actionable suggestion for the teacher based on the data (e.g., "It may be beneficial to review the topic of meiosis in the next class.").

**--- DATA CONTEXT ---**

You will be provided with a JSON object containing the aggregated analytics for the assessment. It includes the overall average, performance by question, and grade distribution.

*   **Assessment Analytics Data:**
    ---
    {analytics_json}
    ---

**--- EXAMPLE OF REQUIRED OUTPUT ---**

Here are the key takeaways from this assessment:
*   Overall, the class demonstrated a solid understanding of the material, with a strong class average.
*   The data indicates that students found Question 7, which focused on the stages of meiosis, to be the most challenging.
*   It may be beneficial to briefly review the key differences between mitosis and meiosis in an upcoming lesson.

**--- REQUIRED OUTPUT (Markdown Text ONLY) ---**

Generate the summary now.
"""




# --- [NEW PROMPT FOR REFACTORED ASSESSMENT PIPELINE] ---
ANSWER_ISOLATION_PROMPT = """
You are a highly specialized data extraction AI. Your sole purpose is to analyze a set of images containing a handwritten student exam and extract the complete answer for a single, specific question.

**--- PRIMARY DIRECTIVE & RULES ---**

1.  **YOUR GOAL:** Find and transcribe the student's complete handwritten answer for the specific "Question to Find" provided below.
2.  **THE IMAGE IS THE SOURCE OF TRUTH:** Your analysis MUST be based on the handwritten text in the provided image(s).
3.  **BE COMPREHENSIVE:** You must extract the entire answer for the question, even if it spans multiple paragraphs or pages.
4.  **MAINTAIN ORIGINAL TEXT:** Transcribe the student's answer as accurately as possible, including any spelling or grammar mistakes. Do not correct the student's work.
5.  **CRITICAL OUTPUT FORMAT:** Your entire response MUST be a single block of text containing ONLY the student's transcribed answer. Do not include any introductory text, concluding text, conversational filler, or explanations like "Here is the student's answer:". Your output should be suitable for direct use as input to another AI.
6.  **IF ANSWER IS NOT FOUND:** If you cannot find any text in the images that appears to be an answer to the specified question, you MUST return only the string "Answer not found.".

**--- CONTEXT ---**

*   **Question to Find:**
    ---
    {question_text}
    ---

**--- REQUIRED OUTPUT (Transcribed Answer Text ONLY) ---**

Analyze the provided image(s) now and generate the transcribed answer text.
"""


# --- [NEW PROMPT FOR OUTSIDER NAME EXTRACTION] ---
NAME_EXTRACTION_PROMPT = """
You are a highly specialized data extraction AI. Your sole purpose is to find and extract the full name of a person from a given block of text, which is from an OCR scan of a student's answer sheet.

**--- PRIMARY DIRECTIVE & RULES ---**

1.  **YOUR GOAL:** Find the student's name. It is likely located at the top of the text.
2.  **BE PRECISE:** Extract the full name (e.g., "John Smith"). Do not extract other text like "Name:", "Date:", student IDs, or course names.
3.  **CRITICAL OUTPUT FORMAT:** Your entire response MUST be a single, valid JSON object. The JSON object must have exactly one key: `"studentName"`. The value should be the extracted name as a string.
4.  **IF NAME IS NOT FOUND:** If you cannot confidently identify a name in the text, you MUST return a JSON object where the value for "studentName" is `null`.

**--- TEXT TO ANALYZE ---**
{text_block}
---

**--- EXAMPLE 1 ---**
INPUT TEXT: "Name: Jane Doe Student ID: 12345 Subject: History"
OUTPUT JSON:
{{
  "studentName": "Jane Doe"
}}

**--- EXAMPLE 2 ---**
INPUT TEXT: "Introduction to Biology This paper is the property of the school."
OUTPUT JSON:
{{
  "studentName": null
}}

**--- REQUIRED OUTPUT (VALID JSON OBJECT ONLY) ---**

Analyze the provided text and generate the JSON output now.
"""


# --- [NEW PROMPT FOR MULTIMODAL OUTSIDER NAME EXTRACTION] ---
MULTIMODAL_NAME_EXTRACTION_PROMPT = """
You are a highly specialized data extraction AI. Your sole purpose is to find and extract the full name of a person from the provided IMAGE of a student's answer sheet.

**--- PRIMARY DIRECTIVE & RULES ---**

1.  **YOUR GOAL:** Find the student's name in the IMAGE. It is likely located at the top of the first page.
2.  **IMAGE IS THE ONLY TRUTH:** Base your analysis exclusively on the visual information in the image.
3.  **BE PRECISE:** Extract only the full name (e.g., "John Smith"). Do not extract other text like "Name:", "Date:", student IDs, or course names.
4.  **CRITICAL OUTPUT FORMAT:** Your entire response MUST be a single, valid JSON object. The JSON object must have exactly one key: `"studentName"`. The value should be the extracted name as a string.
5.  **IF NAME IS NOT FOUND:** If you cannot confidently identify a name in the image, you MUST return a JSON object where the value for "studentName" is `null`.

**--- REQUIRED OUTPUT (VALID JSON OBJECT ONLY) ---**

Analyze the provided image and generate the JSON output now.
"""


# --- [NEW PROMPT FOR AI SCORE DISTRIBUTION] ---
AI_SCORE_DISTRIBUTION_PROMPT = """
You are an expert curriculum designer and assessment specialist. Your task is to analyze a list of assessment questions and intelligently distribute a total score among them.

**--- PRIMARY DIRECTIVE & RULES ---**

1.  **YOUR GOAL:** You are given a list of questions in a JSON object and a `totalMarks` for the entire assessment. You MUST assign a `maxScore` to each question.
2.  **INTELLIGENT DISTRIBUTION:** You must not simply divide the total marks evenly. Analyze the text of each question to infer its complexity, the cognitive effort required, and its likely importance.
    *   Assign more marks to questions that require detailed explanations, multi-step problem-solving, or synthesis of multiple concepts.
    *   Assign fewer marks to simple recall questions (e.g., definitions, single-word answers).
3.  **SUM MUST MATCH:** The sum of all `maxScore` values you assign MUST equal the provided `totalMarks`. This is a critical mathematical constraint.
4.  **INTEGER SCORES:** All assigned `maxScore` values must be integers.
5.  **CRITICAL OUTPUT FORMAT:** Your entire response MUST be a single, valid JSON object. Do not include any introductory text or wrap the JSON in markdown backticks.
6.  **CRITICAL JSON STRUCTURE:** The JSON object you return MUST have the exact same structure as the input JSON object you receive, with only the `maxScore` values updated.

**--- TASK CONTEXT ---**

*   **Total Marks to Distribute:** `{total_marks}`
*   **Assessment Questions JSON:**
    ```json
    {questions_json}
    ```

**--- REQUIRED OUTPUT (VALID JSON OBJECT ONLY) ---**

Analyze the questions and return the complete JSON object with the `maxScore` for each question updated.
"""







# /app/services/prompt_library.py (ADD THIS NEW PROMPT)



STUDENT_CENTRIC_GRADING_PROMPT = """
You are a highly experienced and objective Teaching Assistant. Your sole purpose is to grade a student's entire exam based on a provided set of questions and a specific answer key context.

**--- PRIMARY DIRECTIVE & RULES ---**

1.  **THE IMAGE IS THE SOURCE OF TRUTH:** You are given IMAGE(S) of a student's complete, handwritten answer sheet. This is your definitive evidence.
2.  **THE ANSWER KEY CONTEXT IS YOUR ONLY LAW:** You have been given an "Answer Key Context". This is your ground truth for what constitutes a correct answer. You MUST grade each question strictly according to this context.
3.  **GRADE ALL QUESTIONS:** You must provide a grade and feedback for every question listed in the "Questions and Rubrics" array.
4.  **PRODUCE HELPFUL FEEDBACK:** For each question, your feedback must be constructive and reference its specific rubric and the answer key context.
5.  **CRITICAL OUTPUT FORMAT:** Your entire output MUST be a single, valid JSON object. Do not include any text before or after it.
6.  **CRITICAL JSON STRUCTURE:** The JSON object must have one key: `"results"`. The value must be an array of objects. Each object in the array MUST have four keys:
    *   `"question_id"` (string): The ID of the question from the input.
    *   `"extractedAnswer"` (string): The verbatim student answer you found in the images. If you cannot find an answer for the question, this MUST be an empty string "".
    *   `"grade"` (number): The final numerical score for that question. If `extractedAnswer` is empty, the grade MUST be 0.
    *   `"feedback"` (string): The detailed, rubric-based feedback for that question.
7.  **GRADING RULES:**
    *   If you cannot locate an answer for a question in the student images, set `extractedAnswer` to `""`, `grade` to `0`, and the `feedback` to "No answer detected for this question."
    *   If an answer is present but completely incorrect, grade it as 0.
    *   For partially correct answers, assign a grade proportional to the correctness. Be a fair and detailed grader.
    *   Do NOT infer or assume an answer from the question text or the answer key. Grade only what is written.

**--- ASSESSMENT MATERIALS ---**

**1. ANSWER KEY CONTEXT (Your Law):**
---
{answer_key_context}
---

**2. QUESTIONS AND RUBRICS (The Tasks):**
---
{questions_json}
---

**--- REQUIRED OUTPUT (VALID JSON OBJECT ONLY) ---**

Analyze the handwritten answer(s) in the provided image(s). For each question in the JSON input, find the student's answer and grade it according to its rubric and the Answer Key Context. Generate the JSON output now.
"""




# --- [NEW PROMPT FOR V2 DOCUMENT-FIRST WORKFLOW - REFACTORED FOR DUAL UPLOAD] ---



# --- [PROMPT FOR V2 DOCUMENT-FIRST WORKFLOW - FINAL INTELLIGENT VERSION] ---
DOCUMENT_PARSING_PROMPT = """
You are an expert in educational materials and document analysis. Your task is to analyze the following document(s) and structure them into a specific JSON format.

**--- PRIMARY DIRECTIVE & RULES ---**

1.  **YOUR GOAL:** Identify all distinct sections and questions from the "Question Document Text". You must then identify the correct answer for each question, primarily using the "Answer Key Document Text" if it is provided.
2.  **SOURCE OF TRUTH:** You may be given IMAGES and extracted text. The IMAGES are the primary source of truth. Use the extracted text as a guide, but trust the IMAGE if they differ.

# --- [THE FIX IS HERE: MORE EXPLICIT DUAL-DOCUMENT LOGIC] ---
3.  **DUAL DOCUMENT LOGIC:**
    *   You MUST process the "Question Document Text" first to get a list of all questions.
    *   Then, you MUST iterate through that list of questions. For each question, use its number (e.g., "Question 1", "1.", "a)") to find the corresponding answer in the "Answer Key Document Text".
    *   If the "Answer Key Document Text" is provided, you MUST populate the `"answer"` field in your JSON output with the text you find.
    *   **CRITICAL RUBRIC RULE:** If the "Answer Key Document Text" is provided, you MUST also copy the extracted answer into the `"rubric"` field for that question. This provides a clear guide for the teacher.
    *   If the "Answer Key Document Text" is empty or not provided, you must attempt to extract both answers and rubrics from the "Question Document Text" itself. If no rubric is found, use an empty string.

4.  **[NEW] MAX SCORE EXTRACTION:**
    *   For each question, you MUST search for an explicit mark allocation (e.g., "[10 marks]", "(5 pts)", "10m").
    *   If you find a mark, you MUST populate the `"maxScore"` field with that number.
    *   If you CANNOT find an explicit mark for a question, you MUST set `"maxScore"` to `null`. Do not default to 100 or any other number.

5.  **SCORING METHOD & OTHER FIELDS:** You must infer the scoring method, sections, questions (with text, rubric, maxScore), and answers, and format them into the required JSON structure.
6.  **CRITICAL OUTPUT FORMAT:** Your entire response MUST be a single, valid JSON object. Do not include any introductory text, concluding remarks, or wrap the JSON in markdown backticks.
7.  **CRITICAL JSON STRUCTURE:** You MUST adhere to the following JSON schema with EXACTLY these key names:
    - The root object must have a `scoringMethod`, `totalScore`, `sections`, and `includeImprovementTips`.
    - Each object in the `sections` array must have a `title`, `total_score`, and `questions`.
    - Each object in the `questions` array MUST have the keys: `"text"`, `"rubric"`, `"maxScore"`, `"answer"`.

**--- EXAMPLE OF REQUIRED JSON OUTPUT STRUCTURE ---**
{{
  "scoringMethod": "per_question",
  "totalScore": null,
  "sections": [ ... ],
  "includeImprovementTips": false
}}

**--- DOCUMENT CONTEXT ---**

*   **Question Document Text:**
    ---
    {question_document_text}
    ---

*   **Answer Key Document Text (Optional):**
    ---
    {answer_key_document_text}
    ---

**--- REQUIRED OUTPUT (VALID JSON OBJECT ONLY) ---**

Analyze the provided document(s) and/or image(s) now and generate the JSON output, strictly following the specified JSON structure and key names.
"""








# --- [NEW PROMPT FOR GEMINI-BASED OCR] ---
GEMINI_OCR_PROMPT = """
Your task is to act as a highly precise Optical Character Recognition (OCR) engine.
Analyze the provided file(s) (image or document) and extract all text content verbatim.

**RULES:**
1. Transcribe the text exactly as you see it. Do not correct spelling, grammar, or formatting.
2. Do not add any summary, analysis, commentary, or any text other than the transcribed content.
3. Your entire output MUST BE ONLY the raw text extracted from the file.
"""






# --- Chatbot V1 Conversational Prompt ---
CONVERSATIONAL_CHATBOT_PROMPT = """
**You are "My Smart Teach" (MST), a friendly, professional, and helpful AI assistant for UK educators.**

**--- PRIMARY DIRECTIVE ---**

Your primary goal is to have a natural, helpful conversation with teachers. You are the first point of contact for our website, My Smart Teach. Your role is to answer questions about our platform, explain its benefits, address concerns, and guide users on how they can get involved with our pilot program. You must be informative, supportive, and reflect the innovative and teacher-centric values of our company.

**--- CORE KNOWLEDGE BASE ---**

This is essential information about the My Smart Teach platform. Use it to answer questions accurately.

*   **The Problem We Solve:** We address the "Teacher Workload Crisis" in the UK. Over 70% of UK educators identify excessive workload (planning, marking, data analysis) as the biggest barrier to their success and well-being. We also solve the "Fragmented Workflow," where teaching tasks are disconnected and inefficient.
*   **Our Solution - An Intelligent Workflow:** We offer a single, all-in-one platform with three core modules:
    *   **Prepare:** An AI "creative co-pilot" that instantly generates lesson materials like questions, presentation slides, and activities. It turns hours of prep time into minutes.
    *   **Assess:** Uses our UK patent-pending "Reflective Consensus" AI to mark an entire class's work in minutes. The process is accurate, transparent, and keeps the teacher in full control of the final grades.
    *   **Analyze:** Instantly visualizes student performance data, identifies learning gaps, and provides clear, actionable insights to inform the next lesson.
*   **Our Unique Technology:** Our core innovation is the patent-pending "Reflective Consensus" technology. It uses a panel of AI agents that collaborate to find the most accurate and unbiased result for every assessment. This is more reliable than generic AI systems.
*   **Target Audience:** We are specifically designed for UK educators and are finely tuned to the requirements of the UK's diverse curricula.
*   **Security & Ethics:** The platform is built on a foundation of trust. We are fully GDPR compliant. All school and student data is protected with robust security and will never be used without consent. The teacher and the school are always in control.
*   **Co-Founders:** The platform was created by Dr. Sharzad (a former teacher with a PhD in data analysis from the University of Nottingham) and Dr. Anand (an applied mathematician from the University of Birmingham). This blends real-world teaching experience with deep AI expertise.
*   **Pilot Program:** We are currently running an exclusive pilot program for a small group of passionate UK educators.
*   **Becoming a Founding Member:** Teachers who join the pilot program become "Founding Members." They receive a special Founder's Lifetime Discount, direct influence on future features, and priority access to the upcoming Prepare and Analyze modules.
*   **Company Info:** Our parent company is Unique Tech Solution Ltd, and we are based in Nottingham, UK.

**--- BEHAVIORAL GUIDELINES ---**

1.  **Persona:** Be friendly, encouraging, and professional. Use clear, simple language. Avoid overly technical jargon unless the user asks for it.
2.  **Be Proactive:** Don't just answer questions; anticipate the user's needs. If they ask about marking, also mention how the analysis module helps them use that marking data.
3.  **Don't Hallucinate:** Only provide information from the Core Knowledge Base. Do not make up features, pricing details (unless provided), or technical specifications.
4.  **Handling Unknown Questions:** If a user asks a very specific or technical question that is not in your knowledge base (e.g., "What specific machine learning model does your consensus system use?" or "Can it grade 3D models?"), use the following approach:
    *   Acknowledge the great question.
    *   State that you don't have the specific technical details for that query.
    *   Explain that the platform is constantly evolving, especially as part of the current pilot program.
    *   Gently pivot and encourage them to contact our expert team for a more detailed answer or to join the pilot program to see it firsthand.
    *   **Example Response for Unknown Technical Questions:** "That's a very insightful question! While I don't have the specific technical details on that particular function, it's important to know that My Smart Teach is an evolving platform. As this is a pilot phase, new features and capabilities are continuously being developed based on feedback from educators like you. For a deeper technical dive, I'd recommend reaching out to our development team via the contact form or requesting a free demo."
5. make sure as much as you can, your answer be in 1 sentence to 1 paragraph, no one want to read along message, so only and only all your answers should be between 1 srntence to  one paragaph
6.    be like a friendly human, dont talk to much, ask some simple and related question, and if user ask then give him some infomration about our service
**--- CONTEXT ---**

You are a chatbot integrated into the My Smart Teach website. You cannot perform actions like logging in a user, changing settings, or grading papers. Your role is informational and conversational.

**--- CHAT HISTORY ---**

The following is the history of your current conversation with the teacher. Use this history to understand the context of their latest message.

{chat_history}
---

**--- TEACHER'S LATEST MESSAGE ---**

{user_message}

**--- YOUR RESPONSE (Natural Language Only) ---**
"""


# === VISION-OPTIMIZED PROMPTS (NO OCR PRE-PROCESSING) ===

VISION_DOCUMENT_PARSING_PROMPT = """
You are an expert educational document analyzer with advanced vision and OCR capabilities. Your task is to analyze the provided assessment document files using your vision abilities and structure them into a specific JSON format.

**--- YOUR VISION CAPABILITIES ---**

You can:
1. **OCR ALL TEXT**: Extract both typed and handwritten text with high accuracy
2. **ANALYZE LAYOUT**: Understand document structure, sections, and formatting
3. **READ EQUATIONS**: Recognize mathematical notation and formulas
4. **DETECT DIAGRAMS**: Identify graphs, charts, and visual elements
5. **HANDLE MULTI-PAGE**: Process multiple pages in PDF documents

**--- PRIMARY TASK ---**

You will receive TWO files:
1. **Question Document**: Contains the assessment questions
2. **Answer Key Document** (optional): Contains the correct answers

**--- RULES & INSTRUCTIONS ---**

1. **FIRST**: Use your vision to carefully OCR and read ALL text from the Question Document
2. **IDENTIFY STRUCTURE**: Detect sections, question numbers, and any organizational structure
3. **EXTRACT QUESTIONS**: For each question, extract:
   - The question text (including any sub-parts)
   - The marking allocation (e.g., "[10 marks]", "(5 pts)") - set to `maxScore`
   - If found in the Question Document, extract the answer/rubric
4. **IF ANSWER KEY PROVIDED**:
   - OCR the Answer Key Document
   - Match answers to questions by number
   - Copy the answer into both `"answer"` AND `"rubric"` fields
5. **HANDLE HANDWRITING**: If the documents contain handwritten text, carefully transcribe it
6. **EQUATIONS & DIAGRAMS**: If questions reference diagrams or contain equations, note them in the question text
7. **MAX SCORE RULE**:
   - Only set `maxScore` if you find an explicit mark allocation
   - If no marks specified, set `maxScore` to `null`
8. **OUTPUT FORMAT**: Return ONLY a valid JSON object (no markdown, no explanations)

**--- REQUIRED JSON STRUCTURE ---**

CRITICAL: The "title" field in sections is REQUIRED and must ALWAYS be a non-null string. If no section title is visible in the document, use "Main Section" as the default.

{{
  "scoringMethod": "per_question",
  "totalScore": null,
  "sections": [
    {{
      "title": "Main Section",
      "total_score": null,
      "questions": [
        {{
          "text": "The full question text",
          "rubric": "The marking rubric or model answer",
          "maxScore": 10,
          "answer": "The correct answer"
        }}
      ]
    }}
  ],
  "includeImprovementTips": false
}}

**--- IMPORTANT NOTES ---**

- Trust your vision - the files you're analyzing are the source of truth
- For handwritten content, transcribe carefully
- Maintain the original question numbering and structure
- If uncertain about handwriting, transcribe your best interpretation
- **CRITICAL**: The "title" field must NEVER be null - use "Main Section" if no title is found

**--- NOW ANALYZE THE FILES ---**

Please analyze the provided files and generate the structured JSON output.
"""


VISION_ANSWER_GRADING_PROMPT = """
You are an expert grading assistant with advanced vision and OCR capabilities. Your task is to analyze a student's handwritten answer sheet and grade it according to the provided rubric.

**--- YOUR VISION CAPABILITIES ---**

You can:
1. **READ HANDWRITING**: Accurately OCR handwritten student responses
2. **DETECT DIAGRAMS**: Analyze student-drawn graphs, charts, and diagrams
3. **READ EQUATIONS**: Understand mathematical notation and formulas
4. **SPATIAL AWARENESS**: Understand layout, arrows, annotations
5. **MULTI-MODAL ANALYSIS**: Combine text, visual, and spatial information

**--- GRADING TASK ---**

Question: {question_text}

Rubric/Model Answer: {rubric}

Maximum Score: {max_score}

**--- INSTRUCTIONS ---**

1. **FIRST**: Use your vision to carefully OCR the student's handwritten answer from the image
2. **EXTRACT ANSWER**: Transcribe exactly what the student wrote (including diagrams if relevant)
3. **ANALYZE CONTENT**: Compare the student's answer against the rubric
4. **CONSIDER VISUAL ELEMENTS**: If the question involves diagrams/graphs, analyze those too
5. **ASSIGN GRADE**: Determine the appropriate score (0 to {max_score})
6. **PROVIDE FEEDBACK**: Write constructive feedback explaining the grade

**--- GRADING CRITERIA ---**

- Full marks: Answer fully matches the rubric/model answer
- Partial credit: Answer is partially correct or shows understanding
- Zero marks: Answer is incorrect, missing, or shows fundamental misunderstanding
- For diagrams: Check accuracy, labels, and completeness

**--- HANDLE HANDWRITING CAREFULLY ---**

- If handwriting is unclear, make your best interpretation
- Don't penalize for poor handwriting if the content is correct
- If completely illegible, note this in feedback and assign zero

**--- OUTPUT FORMAT (JSON ONLY) ---**

{{
  "extracted_answer": "The student's answer as you read it from the image",
  "grade": 8,
  "feedback": "Your constructive feedback explaining the grade",
  "confidence": "high"
}}

**--- NOW GRADE THE ANSWER ---**

Please analyze the provided answer sheet image and generate your grading response.
"""

# --- Vision-based Name Extraction Prompt ---
VISION_NAME_EXTRACTION_PROMPT = """
You are an expert at reading handwritten documents and extracting student information. Your task is to analyze a student's answer sheet and extract the student's name.

**--- YOUR TASK ---**

1. **LOOK FOR THE NAME**: Carefully examine the provided document image
2. **FIND STUDENT NAME**: Look for the student's name, typically at the top of the page
3. **READ HANDWRITING**: Use your OCR capabilities to accurately read handwritten text
4. **EXTRACT FULL NAME**: Return the complete student name as written

**--- INSTRUCTIONS ---**

- Look at the top portion of the answer sheet where students typically write their names
- The name might be in a "Name:" field or similar
- Return the FULL name as you see it (e.g., "John Smith", not just "John")
- If you cannot find a name, return an empty string
- Do not make up a name if you cannot find one

**--- OUTPUT FORMAT (JSON ONLY) ---**

{{
  "studentName": "The full name as you read it from the image"
}}

**--- NOW EXTRACT THE NAME ---**

Please analyze the provided answer sheet image and extract the student name.
"""

--- File: .\ata-backend\app\services\report_service.py ---

# /app/services/report_service.py

from typing import Dict
import io
from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH

def create_word_report(report_data: Dict) -> bytes:
    """
    Generates a personalized .docx assessment report from structured data.
    This is a synchronous, CPU-bound function.

    Args:
        report_data: A dictionary containing all data needed for the report.

    Returns:
        The raw binary content of the generated .docx file as a bytes object.
    """
    try:
        # 1. Extract data
        student_name = report_data["studentName"]
        final_grade = report_data["finalGrade"]
        questions = report_data["questions"]
        assessment_name = report_data["assessmentName"]
        class_name = report_data["className"]

        # 2. Create a new Document
        document = Document()

        # --- Header ---
        heading = document.add_heading('Assessment Report', level=1)
        heading.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        subtitle = document.add_paragraph(f"{assessment_name} | {class_name}")
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        document.add_paragraph() # Spacer

        # --- Student Summary ---
        document.add_heading('Student Summary', level=2)
        p_name = document.add_paragraph()
        p_name.add_run('Student Name: ').bold = True
        p_name.add_run(student_name)
        
        p_grade = document.add_paragraph()
        p_grade.add_run('Final Grade: ').bold = True
        p_grade.add_run(f"{final_grade}%").bold = True
        
        document.add_paragraph() # Spacer

        # --- Detailed Breakdown ---
        document.add_heading('Detailed Breakdown', level=2)
        
        for i, q in enumerate(questions):
            if i > 0:
                document.add_paragraph("_________________________") # Separator
            
            # Question Text
            q_text = document.add_paragraph()
            q_text.add_run(q['text']).bold = True

            # Grade
            p_q_grade = document.add_paragraph()
            p_q_grade.add_run('Grade: ').italic = True
            p_q_grade.add_run(str(q['grade'])).bold = True
            
            # Feedback
            p_q_feedback = document.add_paragraph()
            p_q_feedback.add_run('Feedback: ').italic = True
            p_q_feedback.add_run(q['feedback'])
            
            document.add_paragraph() # Spacer

        # --- Footer ---
        # python-docx does not have a simple built-in footer concept like fpdf2.
        # We will add it at the end of the main body for V1.
        document.add_paragraph("_________________________")
        footer = document.add_paragraph("Report Generated by ATA")
        footer.alignment = WD_ALIGN_PARAGRAPH.RIGHT
        for run in footer.runs:
            run.font.size = Pt(8)
            run.italic = True

        # 5. Save the document to an in-memory stream
        file_stream = io.BytesIO()
        document.save(file_stream)
        file_stream.seek(0) # Rewind the stream to the beginning

        return file_stream.read()

    except KeyError as e:
        error_msg = f"Missing required key in report_data for DOCX generation: {e}"
        print(f"ERROR: {error_msg}")
        raise ValueError(error_msg)
    except Exception as e:
        print(f"An unexpected error occurred during DOCX generation: {e}")
        raise

--- File: .\ata-backend\app\services\student_service.py ---

"""
This service contains the business logic for fetching and processing
student-related data, such as the data for the student transcript page.
"""

from typing import List, Dict, Optional
from ..services.database_service import DatabaseService
from ..db.models.assessment_models import ResultStatus
from ..models.student_model import StudentAssessmentRow, StudentTranscriptResponse, ClassTranscript
from ..services.assessment_helpers.analytics_and_matching import normalize_config_to_v2

class StudentService:
    def __init__(self, db: DatabaseService):
        self.db = db

    def get_transcript(self, student_id: str, user_id: str) -> StudentTranscriptResponse:
        """
        Constructs the detailed transcript for a single student, organized by class.
        Each class gets its own table with assessments and class-specific average.
        """
        student = self.db.get_student_by_id(student_id, user_id)
        if not student:
            raise ValueError("Student not found or access denied.")

        # Get all classes the student is a member of
        memberships = self.db.get_class_memberships_for_student(student_id, user_id)
        if not memberships:
            return StudentTranscriptResponse(
                id=student.id,
                studentId=student.studentId,
                name=student.name,
                overallAveragePercent=None,
                classSummaries=[]
            )

        # Build transcript per class
        class_summaries: List[ClassTranscript] = []
        overall_earned = 0.0
        overall_possible = 0.0

        for membership in memberships:
            class_id = membership.class_id
            class_name = membership.class_name

            # Get all assessments for this class
            assessments = self.db.get_assessments_for_class(class_id, user_id)

            class_rows: List[StudentAssessmentRow] = []
            class_earned = 0.0
            class_possible = 0.0

            for job in assessments:
                cfg = normalize_config_to_v2(job)
                max_total_score = sum(q.maxScore for s in cfg.sections for q in s.questions if q.maxScore is not None)

                # Get results for this specific student and job
                results = self.db.get_results_for_student_and_job(student_id, job.id, user_id)

                if not results:
                    status = "ABSENT"
                    total_score = None
                    report_url = None
                else:
                    any_pending = any(r.status == ResultStatus.PENDING_REVIEW.value for r in results)
                    if any_pending:
                        status = "PENDING_REVIEW"
                        total_score = None
                    else:
                        status = "GRADED"
                        total_score = sum(float(r.grade) for r in results if r.grade is not None)
                        class_earned += total_score
                        class_possible += max_total_score

                    report_url = f"/api/assessments/{job.id}/students/{student.id}/report.docx"

                created_at_str = job.created_at.isoformat() if job.created_at else None
                print(f"ðŸ“… [STUDENT SERVICE] Job {job.id}: created_at = {job.created_at}, ISO = {created_at_str}")

                class_rows.append(StudentAssessmentRow(
                    jobId=job.id,
                    assessmentName=cfg.assessmentName,
                    classId=class_id,
                    className=class_name,
                    createdAt=created_at_str,
                    totalScore=total_score,
                    maxTotalScore=max_total_score,
                    status=status,
                    reportUrl=report_url
                ))

            # Calculate class average
            class_avg = (class_earned / class_possible * 100) if class_possible > 0 else None

            class_summaries.append(ClassTranscript(
                classId=class_id,
                className=class_name,
                averagePercent=class_avg,
                assessments=class_rows
            ))

            # Add to overall totals
            overall_earned += class_earned
            overall_possible += class_possible

        # Calculate overall average
        overall_avg = (overall_earned / overall_possible * 100) if overall_possible > 0 else None

        return StudentTranscriptResponse(
            id=student.id,
            studentId=student.studentId,
            name=student.name,
            overallAveragePercent=overall_avg,
            classSummaries=class_summaries
        )

--- File: .\ata-backend\app\services\tool_service.py ---

# /ata-backend/app/services/tool_service.py (MODIFIED AND APPROVED - FLAWLESS VERSION)

"""
This service module acts as the central orchestrator for all AI content
generation tools.

It is responsible for:
1. Receiving a generation request from the `tools_router`.
2. Processing any source material (direct text, uploaded file, or library content).
3. Dispatching the request to the appropriate specialist AI handler.
4. Calling the `history_service` to persist the final, user-owned generation record.

This module has been made "user-aware" to ensure that all generated content
is correctly saved to the history of the authenticated user who initiated the request.
"""

from typing import Dict, Any, Optional
from pydantic import ValidationError
from fastapi import UploadFile
import asyncio
import os

from ..models.tool_model import ToolId, QuestionGeneratorSettings, SlideGeneratorSettings, RubricGeneratorSettings
from ..services import gemini_service, history_service, prompt_library, ocr_service
from .database_service import DatabaseService

# --- Tool-Specific Logic Functions (These are pure utilities and require no changes) ---

async def _handle_question_generator(settings: Dict[str, Any]) -> str:
    """
    Specialist handler for the Question Generator tool.
    Validates settings and calls the AI with the appropriate prompt.
    """
    try:
        validated_settings = QuestionGeneratorSettings(**settings)
    except ValidationError as e:
        raise ValueError(f"Invalid question settings provided. Details: {e}")
    if not validated_settings.source_text or len(validated_settings.source_text) < 20:
        raise ValueError("A valid source must be provided (Text, File, or Library Chapters) with sufficient content.")
    plan_lines = [f"- Generate {config.count} {config.difficulty.value} '{config.label}'." for config in validated_settings.question_configs]
    generation_plan_string = "\n".join(plan_lines)
    prompt = prompt_library.QUESTION_GENERATOR_PROMPT_V2.format(
        grade_level=validated_settings.grade_level,
        source_text=validated_settings.source_text,
        generation_plan_string=generation_plan_string
    )
    return await gemini_service.generate_text(prompt, temperature=0.7)


async def _handle_slide_generator(settings: Dict[str, Any]) -> str:
    """
    Specialist handler for the Slide Generator tool.
    Validates settings and calls the AI with the appropriate prompt.
    """
    try:
        validated_settings = SlideGeneratorSettings(**settings)
    except ValidationError as e:
        raise ValueError(f"Invalid slide settings provided. Details: {e}")
    if not validated_settings.source_text or len(validated_settings.source_text) < 10:
        raise ValueError("A valid source must be provided (Text, File, or Library Chapters) with sufficient content.")
    prompt = prompt_library.SLIDE_GENERATOR_PROMPT_V2.format(
        grade_level=validated_settings.grade_level,
        num_slides=validated_settings.num_slides,
        slide_style=validated_settings.slide_style.value,
        include_speaker_notes=validated_settings.include_speaker_notes,
        source_text=validated_settings.source_text
    )
    return await gemini_service.generate_text(prompt, temperature=0.6)


async def _handle_rubric_generator(settings: Dict[str, Any]) -> str:
    """
    Specialist handler for the Rubric Generator tool.
    Validates settings and calls the AI with the appropriate prompt.
    """
    try:
        validated_settings = RubricGeneratorSettings(**settings)
    except ValidationError as e:
        raise ValueError(f"Invalid rubric settings provided. Details: {e}")
    assignment_context_text = validated_settings.assignment_text or ""
    rubric_guidance_text = validated_settings.guidance_text or "None provided."
    if not assignment_context_text:
         raise ValueError("An 'Assignment Context' must be provided from Text, a File, or the Library.")
    criteria_string = ", ".join(validated_settings.criteria)
    levels_string = ", ".join(validated_settings.levels)
    prompt = prompt_library.RUBRIC_GENERATOR_PROMPT_V2.format(
        grade_level=validated_settings.grade_level,
        criteria_string=criteria_string,
        levels_string=levels_string,
        assignment_context_text=assignment_context_text,
        rubric_guidance_text=rubric_guidance_text
    )
    return await gemini_service.generate_text(prompt, temperature=0.5)


# --- Tool Handler Dispatcher (This is a static mapping and requires no changes) ---
TOOL_HANDLERS = {
    ToolId.QUESTION_GENERATOR: _handle_question_generator,
    ToolId.SLIDE_GENERATOR: _handle_slide_generator,
    ToolId.RUBRIC_GENERATOR: _handle_rubric_generator,
}


# --- Main Orchestration Function (MODIFIED AND SECURE) ---
async def generate_content_for_tool(
    settings_payload: Dict[str, Any],
    source_file: Optional[UploadFile],
    db: DatabaseService,
    user_id: str  # <-- CRITICAL MODIFICATION 1/2: Added user_id
) -> Dict[str, Any]:
    """
    Orchestrates the entire AI tool generation process.

    This function is now secure. It receives the authenticated user's ID and
    ensures that the final call to the `history_service` includes this ID,
    thereby guaranteeing that the generated content is saved to the correct
    user's history.

    Args:
        settings_payload: The raw payload from the router, containing tool_id and settings.
        source_file: An optional uploaded file for context.
        db: The DatabaseService instance.
        user_id: The ID of the authenticated user making the request.

    Returns:
        A dictionary containing the details of the saved generation record.
    """
    
    # This initial logic for processing the source material remains unchanged.
    tool_id_str = settings_payload.get("tool_id")
    settings_dict = settings_payload.get("settings")
    if not tool_id_str or settings_dict is None:
        raise ValueError("Payload must include 'tool_id' and 'settings'.")

    if source_file:
        if ("source_text" in settings_dict and settings_dict["source_text"]) or \
           ("selected_chapter_paths" in settings_dict and settings_dict["selected_chapter_paths"]):
             raise ValueError("Cannot provide a source file simultaneously with source text or library chapters.")
        file_bytes = await source_file.read()
        extracted_text = await asyncio.to_thread(
            ocr_service.extract_text_from_file, file_bytes, source_file.content_type
        )
        if not extracted_text:
            raise ValueError("Could not extract any readable text from the uploaded file.")
        settings_dict["source_text"] = extracted_text
    elif "selected_chapter_paths" in settings_dict and settings_dict["selected_chapter_paths"]:
        if "source_text" in settings_dict and settings_dict["source_text"]:
            raise ValueError("Cannot provide source text simultaneously with library chapters.")
        combined_text = []
        for path_str in settings_dict["selected_chapter_paths"]:
            abs_path = os.path.abspath(path_str)
            if not abs_path.startswith(os.path.abspath("Books")):
                raise ValueError(f"Invalid chapter path provided: {path_str}")
            try:
                with open(abs_path, 'r', encoding='utf-8') as f:
                    combined_text.append(f.read())
            except FileNotFoundError:
                raise ValueError(f"Could not find chapter file at path: {path_str}")
        settings_dict["source_text"] = "\n\n--- END OF CHAPTER ---\n\n".join(combined_text)

    tool_id = ToolId(tool_id_str)
    handler = TOOL_HANDLERS.get(tool_id)
    if not handler:
        raise ValueError(f"Invalid or not-yet-implemented toolId: {tool_id}")
    
    generated_content = await handler(settings_dict)
    
    # --- [CRITICAL MODIFICATION 2/2: SECURE PERSISTENCE] ---
    # The authenticated user's ID is now passed to the history_service.
    # This ensures the generated content is saved to the correct user's account.
    history_record = history_service.save_generation(
        db=db,
        user_id=user_id,  # <-- The user_id is now correctly passed.
        tool_id=tool_id.value,
        settings=settings_dict,
        generated_content=generated_content,
        source_filename=source_file.filename if source_file else None
    )
    
    # The response construction remains the same.
    return {
        "generation_id": history_record.id,
        "tool_id": history_record.tool_id.value,
        "content": history_record.generated_content
    }



--- File: .\ata-backend\app\services\user_service.py ---

# /ata-backend/app/services/user_service.py

"""
This service module encapsulates all business logic related to user management.

It acts as an intermediary between the API endpoints (routers) and the raw
database operations, ensuring a clean separation of concerns. The functions
in this module are responsible for:
- Retrieving users from the database.
- Orchestrating the creation of new users, including password hashing.
- Authenticating users by verifying their credentials.
"""

from typing import Optional
from sqlalchemy.orm import Session

# Import the SQLAlchemy model to interact with the database table.
from app.db.models.user_model import User as UserModel

# Import the Pydantic model that defines the data shape for user creation.
from app.models.user_model import UserCreate

# Import the security utilities for password hashing and verification.
from app.core.security import get_password_hash, verify_password


def get_user_by_email(db: Session, email: str) -> Optional[UserModel]:
    """
    Retrieves a single user from the database based on their email address.

    This is a fundamental lookup function used to check for user existence
    before registration and to fetch a user's details during login.

    Args:
        db: The active SQLAlchemy database session.
        email: The email address of the user to retrieve.

    Returns:
        The SQLAlchemy UserModel object if a user is found, otherwise None.
    """
    # Normalize email to lowercase for case-insensitive comparison
    return db.query(UserModel).filter(UserModel.email == email.lower()).first()


def create_user(db: Session, user: UserCreate) -> UserModel:
    """
    Creates a new user record in the database.

    This function orchestrates the entire user creation process:
    1. Checks if a user with the given email already exists.
    2. Hashes the plain-text password provided by the user.
    3. Creates a new SQLAlchemy UserModel instance with the validated data.
    4. Adds the new user to the database session and commits the transaction.

    Args:
        db: The active SQLAlchemy database session.
        user: A Pydantic UserCreate model containing the new user's details
              (email, full_name, and plain-text password).

    Raises:
        ValueError: If a user with the provided email already exists.

    Returns:
        The newly created SQLAlchemy UserModel object, including its server-generated ID.
    """
    # --- [THIS IS THE MODIFICATION] ---
    # The business rule for checking for a duplicate email is now correctly
    # placed within the service layer.
    existing_user = get_user_by_email(db, email=user.email)
    if existing_user:
        # Raising a standard Python exception allows the router to decide
        # which HTTP status code is appropriate.
        raise ValueError("An account with this email already exists.")
    # --- [END OF MODIFICATION] ---

    # Generate a secure hash of the user's password.
    # This is a critical security step. We never store the plain-text password.
    hashed_password = get_password_hash(user.password)

    # Create a new SQLAlchemy UserModel instance.
    # We use `model_dump()` to convert the Pydantic model to a dictionary,
    # excluding the password which we are replacing with the hash.
    # Normalize email to lowercase before storing
    db_user = UserModel(
        **user.model_dump(exclude={"password", "email"}),
        email=user.email.lower(),
        hashed_password=hashed_password
    )
    
    # Add the new user object to the session, commit it to the database,
    # and refresh the instance to get the server-generated values (like the ID).
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    
    return db_user


def authenticate_user(db: Session, email: str, password: str) -> Optional[UserModel]:
    """
    Authenticates a user by verifying their email and password.

    This is the core logic for the login process. It first finds the user by
    email and then uses the secure `verify_password` utility to check if the
    provided password matches the stored hash.

    Args:
        db: The active SQLAlchemy database session.
        email: The email provided by the user during login.
        password: The plain-text password provided by the user during login.

    Returns:
        The authenticated SQLAlchemy UserModel object if credentials are valid,
        otherwise None.
    """
    # First, retrieve the user from the database by their email.
    user = get_user_by_email(db, email=email)
    
    # If no user is found with that email, or if the password verification fails,
    # authentication is unsuccessful. We return None to signal this failure.
    if not user or not verify_password(password, user.hashed_password):
        return None
    
    # If the user exists and the password is correct, return the user object.
    return user

--- File: .\ata-backend\app\services\zip_service.py ---

# /app/services/zip_service.py

# --- Core Imports ---
import io
import zipfile
from typing import List, Tuple

# --- Core Public Function ---
def create_zip_archive(files_in_memory: List[Tuple[str, bytes]]) -> bytes:
    """
    Creates a ZIP archive in memory from a list of files.
    Each file is provided as a tuple of (filename, file_bytes).
    This is a synchronous, CPU-bound function that should be called via asyncio.to_thread.

    Args:
        files_in_memory: A list where each item is a tuple containing the desired
                         filename (e.g., "Report_Alice.pdf") and the file's raw
                         binary content.

    Returns:
        The raw binary content of the generated ZIP archive as a bytes object.
    """
    # Create an in-memory binary stream to act as the ZIP file.
    zip_buffer = io.BytesIO()

    # Create a ZipFile object that writes to our in-memory buffer.
    with zipfile.ZipFile(zip_buffer, "a", zipfile.ZIP_DEFLATED, False) as zip_file:
        # Iterate through the list of files to be added.
        for file_name, data in files_in_memory:
            # Write the binary data to the archive with the specified filename.
            zip_file.writestr(file_name, data)

    # Move the buffer's cursor to the beginning.
    zip_buffer.seek(0)
    
    # Read the complete binary content of the in-memory ZIP file.
    zip_bytes = zip_buffer.getvalue()
    zip_buffer.close()
    
    return zip_bytes

--- File: .\ata-backend\app\services\__init__.py ---

 


--- File: .\ata-backend\app\services\assessment_helpers\analytics_and_matching.py ---


# /app/services/assessment_helpers/analytics_and_matching.py (FINAL, CORRECTED, SUPERVISOR-APPROVED VERSION)

"""
This module contains specialist helper functions for the middle and end stages
of the assessment grading pipeline.

It is called by the main `assessment_service` and is responsible for:
1. Automatically matching uploaded answer sheet files to students in a roster.
2. Calculating aggregate analytics and statistics for a completed job.
3. Normalizing and validating the job's configuration data.

The `match_files_to_students` function has been made "user-aware" to ensure
all its database operations are securely scoped.
"""

import json
from typing import List, Dict, Union
import pandas as pd
import asyncio

from ...models import assessment_model
from ..database_service import DatabaseService

# --- PURE UTILITY FUNCTIONS (Correct and Unchanged) ---
# These functions do not interact with the database directly. They operate on
# data that has already been securely fetched, so they do not require user context.

def get_validated_config_from_job(job_record: 'Assessment') -> Union[assessment_model.AssessmentConfig, assessment_model.AssessmentConfigV2]:
    """
    Tries to parse config as V2 first, falls back to V1 for backward compatibility.
    This version is hardened to handle both dict and str config types.
    """
    config_data = job_record.config
    
    if isinstance(config_data, str):
        try:
            config_data = json.loads(config_data)
        except json.JSONDecodeError:
            raise ValueError("Config is a malformed JSON string.")

    try:
        return assessment_model.AssessmentConfigV2.model_validate(config_data)
    except Exception:
        return assessment_model.AssessmentConfig.model_validate(config_data)

def normalize_config_to_v2(job_record: 'Assessment') -> assessment_model.AssessmentConfigV2:
    """Takes a job record and ALWAYS returns an AssessmentConfigV2 model."""
    config = get_validated_config_from_job(job_record)
    
    if isinstance(config, assessment_model.AssessmentConfigV2):
        return config
    
    # This logic correctly upgrades a V1 config to the V2 structure.
    v1_questions_as_v2 = [assessment_model.QuestionConfigV2(**q.model_dump()) for q in config.questions]
    
    v1_as_v2_section = assessment_model.SectionConfigV2(
        title="Main Section",
        questions=v1_questions_as_v2
    )
    
    return assessment_model.AssessmentConfigV2(
        assessmentName=config.assessmentName,
        classId=config.classId,
        scoringMethod=assessment_model.ScoringMethod.PER_QUESTION,
        includeImprovementTips=getattr(config, 'includeImprovementTips', False),
        sections=[v1_as_v2_section]
    )

def calculate_analytics(all_results: List['Result'], config: assessment_model.AssessmentConfigV2) -> Dict:
    """Calculates aggregate statistics for a completed assessment."""
    all_questions = [q for section in config.sections for q in section.questions]
    
    results_dicts = [{c.name: getattr(r, c.name) for c in r.__table__.columns} for r in all_results]
    df = pd.DataFrame(results_dicts)

    # Robust checks for empty or invalid data.
    if df.empty or 'grade' not in df.columns:
         return {"classAverage": 0, "medianGrade": 0, "gradeDistribution": {}, "performanceByQuestion": {}}
    
    df['grade'] = pd.to_numeric(df['grade'], errors='coerce')
    df.dropna(subset=['grade'], inplace=True)
    if df.empty: return {"classAverage": 0, "medianGrade": 0, "gradeDistribution": {}, "performanceByQuestion": {}}
    
    total_max_score = sum(q.maxScore for q in all_questions if q.maxScore is not None)
    if total_max_score == 0: return {"classAverage": 0, "medianGrade": 0, "gradeDistribution": {}, "performanceByQuestion": {}}
    
    student_scores = df.groupby('student_id')['grade'].sum()
    student_percentages = (student_scores / total_max_score) * 100

    question_perf = {}
    for q in all_questions:
        q_grades = df[df['question_id'] == q.id]['grade'].dropna().tolist()
        avg_score = (sum(q_grades) / len(q_grades)) if q_grades else 0
        question_perf[q.id] = (avg_score / q.maxScore) * 100 if q.maxScore and q.maxScore > 0 else 0
    
    bins = [0, 59.99, 69.99, 79.99, 89.99, 101]
    labels = ["F (0-59)", "D (60-69)", "C (70-79)", "B (80-89)", "A (90-100)"]
    grade_dist = pd.cut(student_percentages, bins=bins, labels=labels, right=False).value_counts().sort_index().to_dict()
    
    return {
        "classAverage": round(float(student_percentages.mean()), 2) if not student_percentages.empty else 0,
        "medianGrade": round(float(student_percentages.median()), 2) if not student_percentages.empty else 0,
        "gradeDistribution": grade_dist,
        "performanceByQuestion": {k: round(v, 2) for k, v in question_perf.items()}
    }

import uuid
import os
from .. import gemini_service, prompt_library
from . import grading_pipeline

def _create_results_for_entity(db: DatabaseService, job_id: str, entity_id: str, entity_type: str, config: Union[assessment_model.AssessmentConfig, assessment_model.AssessmentConfigV2], file_info: Dict, user_id: str):
    """Creates placeholder result records for all questions for a given entity (student or outsider)."""
    all_questions = [q for s in config.sections for q in s.questions] if isinstance(config, assessment_model.AssessmentConfigV2) else config.questions

    for question in all_questions:
        result_id = f"res_{uuid.uuid4().hex[:16]}"

        result_payload = {
            "id": result_id,
            "job_id": job_id,
            "question_id": question.id,
            "grade": None,
            "feedback": None,
            "extractedAnswer": None,
            "status": "pending_grade",
            "answer_sheet_path": file_info.get('path', ''),
            "content_type": file_info.get('contentType', '')
        }

        if entity_type == 'student':
            result_payload['student_id'] = entity_id
            result_payload['outsider_student_id'] = None
        elif entity_type == 'outsider':
            result_payload['student_id'] = None
            result_payload['outsider_student_id'] = entity_id
        else:
            continue # Should not happen

        db.save_student_grade_result(result_payload)

# --- DATABASE-INTERACTIVE HELPER (Corrected and Secure) ---
async def match_files_to_students(
    db: DatabaseService, 
    job_id: str,
    user_id: str
):
    """
    Matches uploaded answer sheets to students. If a match is found, it creates
    the necessary Result records. If a file does not match anyone on the roster,
    it uses a multimodal AI call to extract the student's name from the document
    image and creates a new "Outsider" student.
    """
    job = db.get_assessment_job(job_id=job_id, user_id=user_id)
    if not job:
        print(f"ERROR: Job {job_id} not found or access denied for user {user_id} during file matching.")
        return

    config = normalize_config_to_v2(job)
    students = db.get_students_by_class_id(class_id=config.classId, user_id=user_id)
    student_map = {s.name.lower().strip(): s.id for s in students}
    
    unassigned_files_data = job.answer_sheet_paths
    if isinstance(unassigned_files_data, str):
        unassigned_files = json.loads(unassigned_files_data)
    else:
        unassigned_files = unassigned_files_data

    if not isinstance(unassigned_files, list):
        print(f"WARNING: answer_sheet_paths for job {job_id} is not a list. Skipping matching.")
        return

    for file_info in unassigned_files:
        path = file_info.get('path')
        content_type = file_info.get('contentType')
        if not path or not content_type:
            continue

        try:
            with open(path, "rb") as f:
                file_bytes = f.read()

            # Use vision-based name extraction for matching
            extracted_name = None
            try:
                # Use vision to extract student name from the document
                result = await gemini_service.process_file_with_vision_json(
                    file_bytes=file_bytes,
                    mime_type=content_type,
                    prompt=prompt_library.VISION_NAME_EXTRACTION_PROMPT,
                    temperature=0.1,
                    log_context="EXTRACT-NAME (Outsider Student)"
                )
                extracted_name = result['data'].get("studentName", "").strip()
            except Exception as name_exc:
                print(f"Could not extract name via vision AI for {path}: {name_exc}")
                extracted_name = None

            # Try to match the extracted name to rostered students
            match_found = False
            if extracted_name:
                normalized_extracted = extracted_name.lower().strip()
                for student_name, student_id in student_map.items():
                    if student_name in normalized_extracted or normalized_extracted in student_name:
                        print(f"Matched file {path} to rostered student {student_name} ({student_id}) via vision")
                        _create_results_for_entity(db, job_id, student_id, 'student', config, file_info, user_id)
                        match_found = True
                        break

            if not match_found:
                # This is an outsider
                outsider_name = extracted_name if extracted_name else "Unknown Student"
                print(f"File {path} did not match. Creating new outsider student: {outsider_name}")

                new_outsider = db.add_outsider_student({
                    "name": outsider_name,
                    "assessment_id": job_id
                })

                _create_results_for_entity(db, job_id, new_outsider.id, 'outsider', config, file_info, user_id)

        except FileNotFoundError:
            print(f"ERROR: File not found during matching for job {job_id}: {path}")
        except Exception as e:
            print(f"ERROR matching file {path} for job {job_id}: {e}")

--- File: .\ata-backend\app\services\assessment_helpers\data_assembly.py ---

# /app/services/assessment_helpers/data_assembly.py (FINAL, HARDENED VERSION)

import json
from typing import List, Dict, Union
import pandas as pd

from ...models import assessment_model

def _get_validated_config_from_job(job_record: 'Assessment') -> Union[assessment_model.AssessmentConfig, assessment_model.AssessmentConfigV2]:
    """A specialist helper that robustly parses a job's config JSON."""
    config_str = json.dumps(job_record.config)
    try:
        return assessment_model.AssessmentConfigV2.model_validate_json(config_str)
    except Exception:
        return assessment_model.AssessmentConfig.model_validate_json(config_str)

def _safe_float_convert(value):
    if value is None or str(value).strip() == '': return None
    try: return float(value)
    except (ValueError, TypeError): return None

# --- [THIS IS THE NEW, CORRECTED FUNCTION] ---
def _assemble_job_summaries(all_jobs: List['Assessment'], all_results: List['Result'], all_classes: Dict) -> List[Dict]:
    """
    Specialist for assembling the dashboard summary list.
    This version is hardened to gracefully handle failed or malformed jobs.
    """
    summaries = []
    # Create a DataFrame from the results for efficient, vectorized operations.
    # This is much faster than looping in Python for large datasets.
    results_df = pd.DataFrame([r.__dict__ for r in all_results]) if all_results else pd.DataFrame(columns=['job_id', 'student_id', 'status'])

    for job in all_jobs:
        # Start with a basic, default summary. This will be shown even if parsing fails.
        total_pages_value = job.total_pages if hasattr(job, 'total_pages') and job.total_pages else 0
        print(f"ðŸ“„ [DATA ASSEMBLY] Job {job.id}: total_pages = {total_pages_value}, status = {job.status}")

        summary = {
            "id": job.id,
            "assessmentName": "Assessment (Processing Error)", # A clear default name
            "className": "Unknown Class",
            "createdAt": job.created_at.isoformat() if job.created_at else "",
            "status": job.status,
            "progress": {"total": 0, "processed": 0},
            "totalPages": total_pages_value
        }
        
        try:
            # Attempt to parse the full, rich details.
            config = _get_validated_config_from_job(job)
            summary["assessmentName"] = config.assessmentName
            summary["className"] = all_classes.get(config.classId, "Unknown Class")
            
            # Only calculate progress if the job is not in a failed state and results exist.
            if job.status != "Failed" and not results_df.empty:
                job_results_df = results_df[results_df['job_id'] == job.id]
                if not job_results_df.empty:
                    total_students = len(job_results_df['student_id'].unique())
                    # Correctly filter for statuses that mean "processed"
                    processed_students = len(job_results_df[~job_results_df['status'].isin(['pending_match', 'matched', 'pending'])]['student_id'].unique())
                    summary["progress"] = {"total": total_students, "processed": processed_students}
            
        except Exception as e:
            # If parsing the config or progress fails, we log it, but we still have the basic summary
            # with the correct ID and "Failed" status, so it will appear in the UI.
            print(f"Could not fully parse summary for job {job.id}, showing basic info. Error: {e}")

        print(f"ðŸ”Ž [DATA ASSEMBLY] Final summary for {job.id}: {summary}")
        summaries.append(summary)

    print(f"ðŸ“¤ [DATA ASSEMBLY] Returning {len(summaries)} summaries")
    return summaries
# --- [END OF THE NEW FUNCTION] ---


def _build_results_dictionary(class_students: List['Student'], config: assessment_model.AssessmentConfigV2, all_results_for_job: List['Result']) -> Dict:
    """Specialist for assembling the complex, nested results dictionary."""
    # This function is already correct and does not need to be changed.
    results_map = {}
    for res in all_results_for_job:
        s_id = res.student_id; q_id = res.question_id
        if s_id not in results_map: results_map[s_id] = {}
        results_map[s_id][q_id] = res

    final_results_dict = {}
    all_questions = [q for section in config.sections for q in section.questions]

    for s in class_students:
        s_id = s.id
        final_results_dict[s_id] = {}
        for q in all_questions:
            q_id = q.id
            result_obj = results_map.get(s_id, {}).get(q_id)
            final_grade = _safe_float_convert(getattr(result_obj, 'grade', None))
            final_results_dict[s_id][q_id] = {
                "grade": final_grade,
                "feedback": getattr(result_obj, 'feedback', None),
                "extractedAnswer": getattr(result_obj, 'extractedAnswer', None),
                "status": getattr(result_obj, 'status', 'pending')
            }
    return final_results_dict

--- File: .\ata-backend\app\services\assessment_helpers\document_parser.py ---

# /app/services/assessment_helpers/document_parser.py (HYBRID: Vision for PDF/Images, OCR for DOCX)

import json
import uuid
import io
from typing import Dict, Optional
from fastapi import UploadFile
import google.generativeai as genai
from google.generativeai.types import GenerationConfig

from ...models.assessment_model import AssessmentConfigV2
from .. import gemini_service, prompt_library, ocr_service

async def parse_document_to_config(
    question_file: UploadFile,
    answer_key_file: Optional[UploadFile],
    class_id: str,
    assessment_name: str
) -> Dict:
    """
    Hybrid document parser:
    - For PDF/Images: Uses AI vision directly for better accuracy
    - For DOCX: Uses OCR text extraction + AI (vision API doesn't support DOCX)
    """
    # Read question file
    question_bytes = await question_file.read()
    question_content_type = question_file.content_type

    if not question_bytes:
        raise ValueError("The Question Document is empty.")

    # Read answer key file if provided
    answer_key_bytes = None
    answer_key_content_type = None
    if answer_key_file and answer_key_file.filename:
        answer_key_bytes = await answer_key_file.read()
        answer_key_content_type = answer_key_file.content_type

    # Check if files are DOCX (vision doesn't support DOCX)
    is_question_docx = 'wordprocessing' in (question_content_type or '') or question_file.filename.endswith('.docx')
    is_answer_key_docx = answer_key_bytes and ('wordprocessing' in (answer_key_content_type or '') or (answer_key_file and answer_key_file.filename.endswith('.docx')))

    # Use appropriate prompt based on file type
    if is_question_docx or is_answer_key_docx:
        # DOCX files - use OCR + text-based AI prompt
        prompt = prompt_library.DOCUMENT_PARSING_PROMPT
    else:
        # PDF/Image files - use vision-optimized prompt
        prompt = prompt_library.VISION_DOCUMENT_PARSING_PROMPT

    try:
        total_tokens_used = {'prompt_tokens': 0, 'completion_tokens': 0, 'total_tokens': 0}

        # Handle DOCX files with OCR + text-based AI
        if is_question_docx or is_answer_key_docx:
            # Extract text from DOCX files
            question_text = ocr_service.extract_text_from_file(question_bytes, question_content_type)
            answer_key_text = ""
            if answer_key_bytes:
                answer_key_text = ocr_service.extract_text_from_file(answer_key_bytes, answer_key_content_type)

            # Combine texts and send to AI with text-based prompt
            combined_text = f"QUESTION DOCUMENT:\n{question_text}\n\n"
            if answer_key_text:
                combined_text += f"ANSWER KEY DOCUMENT:\n{answer_key_text}"

            full_prompt = prompt.format(raw_document_text=combined_text)

            # Use generate_json for text-based parsing
            result = await gemini_service.generate_json(full_prompt, temperature=0.1)
            parsed_json = result  # generate_json returns the JSON directly, not wrapped

            # Log token usage for DOCX parsing (note: generate_json may not return tokens, use estimate)
            print(f"[TOKEN-USAGE] PARSE-DOCUMENT (DOCX - Text-based) - File processed successfully")

        # Handle PDF/Image files with Vision API
        elif answer_key_bytes:
            # Upload both files using temporary files
            import tempfile
            import os
            question_temp_path = None
            answer_key_temp_path = None

            try:
                # Create temporary files for both documents
                with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf' if 'pdf' in question_content_type else '.png') as temp_file:
                    temp_file.write(question_bytes)
                    question_temp_path = temp_file.name

                with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf' if 'pdf' in answer_key_content_type else '.png') as temp_file:
                    temp_file.write(answer_key_bytes)
                    answer_key_temp_path = temp_file.name

                # Upload both files to Gemini
                question_upload = genai.upload_file(
                    path=question_temp_path,
                    display_name="question_doc",
                    mime_type=question_content_type
                )

                answer_key_upload = genai.upload_file(
                    path=answer_key_temp_path,
                    display_name="answer_key_doc",
                    mime_type=answer_key_content_type
                )

                # Send both files to the model with JSON mode
                model = genai.GenerativeModel(gemini_service.GEMINI_FLASH_MODEL)
                config = GenerationConfig(
                    temperature=0.1,
                    response_mime_type="application/json"
                )

                response = await model.generate_content_async(
                    [prompt, question_upload, answer_key_upload],
                    generation_config=config
                )

                parsed_json = json.loads(response.text)

                # Track token usage for dual file parsing
                if hasattr(response, 'usage_metadata') and response.usage_metadata:
                    total_tokens_used['prompt_tokens'] = getattr(response.usage_metadata, 'prompt_token_count', 0)
                    total_tokens_used['completion_tokens'] = getattr(response.usage_metadata, 'candidates_token_count', 0)
                    total_tokens_used['total_tokens'] = getattr(response.usage_metadata, 'total_token_count', 0)
                    print(f"[TOKEN-USAGE] PARSE-DOCUMENT (Question + Answer Key) - Prompt: {total_tokens_used['prompt_tokens']}, Completion: {total_tokens_used['completion_tokens']}, Total: {total_tokens_used['total_tokens']}")

            finally:
                # Clean up temporary files
                if question_temp_path and os.path.exists(question_temp_path):
                    try:
                        os.unlink(question_temp_path)
                    except Exception:
                        pass
                if answer_key_temp_path and os.path.exists(answer_key_temp_path):
                    try:
                        os.unlink(answer_key_temp_path)
                    except Exception:
                        pass

        else:
            # Only question file - use single file vision processing
            result = await gemini_service.process_file_with_vision_json(
                file_bytes=question_bytes,
                mime_type=question_content_type,
                prompt=prompt,
                temperature=0.1,
                log_context="PARSE-DOCUMENT (Question Only)"
            )
            parsed_json = result['data']
            total_tokens_used = result['tokens']

    except json.JSONDecodeError as e:
        print(f"Failed to parse AI vision response: {e}")
        raise ValueError("The AI was unable to structure the provided document. Please try a different file or format.")
    except Exception as e:
        print(f"Error in vision-based document parsing: {e}")
        raise ValueError(f"Error processing document with AI vision: {e}")

    try:
        # Generate unique IDs for sections and questions
        if 'sections' in parsed_json and isinstance(parsed_json['sections'], list):
            for section in parsed_json['sections']:
                # Defensive: Ensure section title is never null
                if section.get('title') is None or section.get('title') == '':
                    section['title'] = 'Main Section'
                    print(f"[WARNING] AI returned null/empty section title, using 'Main Section' as fallback")

                # Assign a unique ID to the section
                section['id'] = f"sec_{uuid.uuid4().hex[:8]}"
                if 'questions' in section and isinstance(section['questions'], list):
                    for question in section['questions']:
                        # Assign a unique ID to each question
                        question['id'] = f"q_{uuid.uuid4().hex[:8]}"

        # Add assessment metadata
        parsed_json['assessmentName'] = assessment_name
        parsed_json['classId'] = class_id

        # Validate with Pydantic
        validated_config = AssessmentConfigV2(**parsed_json)

        return validated_config.model_dump()

    except Exception as e:
        print(f"Pydantic validation failed for AI-parsed config: {e}")
        raise ValueError(f"The AI structured the document in an unexpected way. Please check the document's formatting. Details: {e}")


--- File: .\ata-backend\app\services\assessment_helpers\grading_pipeline.py ---

# /app/services/assessment_helpers/grading_pipeline.py (VISION-OPTIMIZED)

import io
import json
from typing import List, Dict, Optional
import fitz  # PyMuPDF
from PIL import Image

from ..database_service import DatabaseService
from .. import gemini_service

def _safe_float_convert(value) -> Optional[float]:
    """A helper to safely convert grade values to float, returning None if invalid."""
    if value is None or str(value).strip() == '':
        return None
    try:
        return float(value)
    except (ValueError, TypeError):
        return None

def _prepare_images_from_answersheet(answer_sheet_path: str, content_type: str) -> List[Image.Image]:
    """
    Specialist for file ingestion.
    Reads a file from disk and converts it into a list of PIL Images, handling PDF conversion.
    KEPT FOR COMPATIBILITY: This is still used for name extraction in analytics_and_matching.py
    """
    with open(answer_sheet_path, "rb") as f:
        file_bytes = f.read()

    image_list = []
    if content_type and 'pdf' in content_type:
        pdf_document = fitz.open(stream=file_bytes, filetype="pdf")
        for page in pdf_document:
            pix = page.get_pixmap(dpi=150)
            img_bytes = pix.tobytes("png")
            image = Image.open(io.BytesIO(img_bytes))
            image_list.append(image)
    else:
        image = Image.open(io.BytesIO(file_bytes))
        image_list.append(image)

    if not image_list:
        raise ValueError(f"Could not extract any images from the file: {answer_sheet_path}")

    return image_list

async def _invoke_grading_ai_vision(
    file_bytes: bytes,
    mime_type: str,
    prompt: str
) -> Dict:
    """
    Vision-optimized AI grading function.
    Uses Gemini File API with vision capabilities to grade a single question.
    Returns structured JSON with extracted_answer, grade, and feedback.
    """
    return await gemini_service.process_file_with_vision_json(
        file_bytes=file_bytes,
        mime_type=mime_type,
        prompt=prompt,
        temperature=0.1
    )

def _save_single_grading_result_to_db(
    db: DatabaseService,
    job_id: str,
    student_id: str,
    question_id: str,
    grading_result: Dict
):
    """
    Specialist for persistence - saves a single question's grading result.
    """
    clean_grade = _safe_float_convert(grading_result.get('grade'))
    clean_feedback = grading_result.get('feedback', 'No feedback provided.')
    extracted_answer = grading_result.get('extracted_answer', '')

    db.update_student_result_with_grade(
        job_id=job_id,
        student_id=student_id,
        question_id=question_id,
        grade=clean_grade,
        feedback=clean_feedback,
        extracted_answer=extracted_answer,
        status="ai_graded"
    )

--- File: .\ata-backend\app\services\assessment_helpers\job_creation.py ---

# /ata-backend/app/services/assessment_helpers/job_creation.py

"""
This module contains specialist helper functions for the initial creation of an
assessment job.

It is called by the main `assessment_service` and is responsible for:
1. Handling the physical saving of uploaded answer sheet files to disk.
2. Creating the initial `Assessment` and placeholder `Result` records in the
   database, ensuring that the new `Assessment` record is correctly stamped
   with the owner's `user_id`.
"""

import os
import uuid
import datetime
from typing import List, Dict
from fastapi import UploadFile

from ..database_service import DatabaseService
from ...models import assessment_model

# A centralized constant for the root directory of all assessment-related file uploads.
ASSESSMENT_UPLOADS_DIR = "assessment_uploads"

def _save_uploaded_files(job_id: str, answer_sheets: List[UploadFile]) -> List[Dict]:
    """
    Handles the file system operations for saving uploaded answer sheets.

    This function is a pure utility and does not require user context. It creates
    a dedicated, uniquely named directory structure for each job to prevent
    file collisions.

    Args:
        job_id: The unique ID of the assessment job being created.
        answer_sheets: A list of `UploadFile` objects from the FastAPI request.

    Returns:
        A list of dictionaries, where each dictionary contains the physical `path`
        and `contentType` of a successfully saved file.
    """
    # This function remains unchanged as it is a pure utility.
    os.makedirs(ASSESSMENT_UPLOADS_DIR, exist_ok=True)
    
    job_dir = os.path.join(ASSESSMENT_UPLOADS_DIR, job_id)
    unassigned_dir = os.path.join(job_dir, 'unassigned')
    os.makedirs(unassigned_dir, exist_ok=True)
    
    answer_sheet_data = []
    for sheet in answer_sheets:
        safe_filename = f"answer_{uuid.uuid4().hex[:8]}_{os.path.basename(sheet.filename or 'untitled')}"
        path = os.path.join(unassigned_dir, safe_filename)
        with open(path, "wb") as buffer:
            content = sheet.file.read()
            buffer.write(content)
        answer_sheet_data.append({"path": path, "contentType": sheet.content_type})
    
    return answer_sheet_data

def _create_initial_job_records(
    db: DatabaseService, 
    job_id: str, 
    config: assessment_model.AssessmentConfig, 
    answer_sheet_data: List[Dict],
    user_id: str
):
    """
    Specialist for creating the database records for a V1 assessment job.

    This function is now user-aware. It receives the authenticated user's ID
    and stamps it onto the new `Assessment` job record, satisfying the
    database's `NOT NULL` constraint for the `user_id` foreign key.

    Args:
        db: The DatabaseService instance for data persistence.
        job_id: The unique ID for the new assessment job.
        config: The Pydantic model containing the V1 assessment configuration.
        answer_sheet_data: A list of dictionaries with file path and content type info.
        user_id: The unique ID of the user who owns this new assessment.
    """
    job_record = {
        "id": job_id,
        "status": assessment_model.JobStatus.QUEUED.value,
        "config": config.model_dump(),
        "answer_sheet_paths": answer_sheet_data,
        "user_id": user_id,  # Stamp the owner's ID onto the new record.
        "created_at": datetime.datetime.now(datetime.timezone.utc),
        "ai_summary": ""
    }
    db.add_assessment_job(job_record)
    
    # The logic for creating placeholder results for every student has been removed.
    # Result records will now be created only after a file has been successfully
    # matched to a student in the analytics_and_matching helper.
    pass

def _create_initial_job_records_v2(
    db: DatabaseService,
    job_id: str,
    config: assessment_model.AssessmentConfigV2,
    answer_sheet_data: List[Dict],
    user_id: str,
    total_pages: int = 0
):
    """
    Specialist for creating the database records for a V2 assessment job.

    Like its V1 counterpart, this function is now user-aware and ensures the new
    `Assessment` job record is correctly associated with an owner.

    Args:
        db: The DatabaseService instance.
        job_id: The unique ID for the new assessment job.
        config: The Pydantic model containing the V2 assessment configuration.
        answer_sheet_data: A list of dictionaries with file path and content type info.
        user_id: The unique ID of the user who owns this new assessment.
        total_pages: Total number of pages across all student submissions.
    """
    job_record = {
        "id": job_id,
        "status": assessment_model.JobStatus.QUEUED.value,
        "config": config.model_dump(),
        "answer_sheet_paths": answer_sheet_data,
        "user_id": user_id,  # Stamp the owner's ID onto the new record.
        "created_at": datetime.datetime.now(datetime.timezone.utc),
        "ai_summary": "",
        "total_pages": total_pages
    }
    db.add_assessment_job(job_record)
    
    # The logic for creating placeholder results for every student has been removed.
    # Result records will now be created only after a file has been successfully
    # matched to a student in the analytics_and_matching helper.
    pass

--- File: .\ata-backend\app\services\assessment_helpers\manual_submission_processor.py ---

# /ata-backend/app/services/assessment_helpers/manual_submission_processor.py

import os
import uuid
from typing import List, Dict, Tuple
from fastapi import UploadFile, Form

from .. import pdf_service

ASSESSMENT_UPLOADS_DIR = "assessment_uploads"

def _process_manual_submissions(job_id: str, files: List[UploadFile]) -> List[Dict[str, str]]:
    """
    Processes manually uploaded files from a FormData object.

    Groups images by entity, compresses and merges them into a PDF for each,
    and saves them to the job's directory.

    Args:
        job_id: The unique ID for the assessment job.
        files: A list of UploadFile objects from the request.

    Returns:
        A list of dictionaries, where each dictionary represents a saved
        answer sheet PDF and contains its path and content type.
    """
    # Create a mapping from entity ID to a list of their image files
    entity_files: Dict[str, List[UploadFile]] = {}
    for file in files:
        # The key from the frontend is formatted as 'student_1_files' or 'outsider_xyz_files'
        # We need to extract the entity ID from the field name
        field_name = file.filename
        if not field_name.endswith('_files'):
            continue

        entity_id = field_name.removesuffix('_files')

        if entity_id not in entity_files:
            entity_files[entity_id] = []
        entity_files[entity_id].append(file)

    saved_pdfs = []
    job_dir = os.path.join(ASSESSMENT_UPLOADS_DIR, job_id)
    os.makedirs(job_dir, exist_ok=True)

    for entity_id, image_files in entity_files.items():
        if not image_files:
            continue

        # Read, compress, and merge images into a single PDF
        image_bytes_list = [img.file.read() for img in image_files]
        compressed_images = [pdf_service.compress_image(data) for data in image_bytes_list]
        pdf_bytes = pdf_service.merge_images_to_pdf(compressed_images)

        # Save the generated PDF
        pdf_filename = f"manual_{entity_id}_{uuid.uuid4().hex[:8]}.pdf"
        pdf_path = os.path.join(job_dir, pdf_filename)
        with open(pdf_path, "wb") as f:
            f.write(pdf_bytes)

        saved_pdfs.append({
            "path": pdf_path,
            "contentType": "application/pdf",
            "originalName": f"{entity_id}_submission.pdf",
            "entityId": entity_id # Pass the entityId for matching
        })

    return saved_pdfs

--- File: .\ata-backend\app\services\assessment_helpers\__init__.py ---



--- File: .\ata-backend\app\services\class_helpers\crud.py ---

# /app/services/class_helpers/crud.py (MODIFIED AND APPROVED)

"""
This module contains the core, low-level business logic for Create, Read,
Update, and Delete (CRUD) operations on Class and Student entities.

It acts as a specialist helper, called by higher-level services like the main
`class_service` and `roster_ingestion` service. Every function here is now
"user-aware," requiring a `user_id` to ensure all database operations are
securely scoped to the authenticated user.
"""

import uuid
from typing import Dict, Optional

from ...models import class_model, student_model
from ..database_service import DatabaseService
from ...db.models.class_student_models import Class, Student

# --- CLASS-RELATED CORE BUSINESS LOGIC ---

def create_class(class_record: Dict, db: DatabaseService) -> Class:
    """
    Creates a new class record in the database from a pre-validated dictionary.

    This function now expects the incoming `class_record` dictionary to already
    contain the `user_id` of the owner, which is added by the calling service.
    Its primary responsibility is to generate a unique ID for the new class
    and persist it.

    Args:
        class_record: A dictionary containing all necessary data for a new class,
                      including the `user_id`.
        db: The DatabaseService instance for data persistence.

    Returns:
        The newly created SQLAlchemy Class object.
    """
    new_id = f"cls_{uuid.uuid4().hex[:12]}"
    class_record['id'] = new_id
    
    new_class_object = db.add_class(class_record)
    return new_class_object


def update_class(
    class_id: str,
    class_update: class_model.ClassCreate,
    db: DatabaseService,
    user_id: str
) -> Optional[Class]:
    """
    Updates a specific class's details, ensuring the user has ownership.

    Args:
        class_id: The ID of the class to update.
        class_update: A Pydantic model with the new data.
        db: The DatabaseService instance.
        user_id: The ID of the authenticated user making the request.

    Returns:
        The updated SQLAlchemy Class object, or None if not found.
    """
    update_data = class_update.model_dump(exclude_unset=True)
    if not update_data:
        raise ValueError("No update data provided.")
    
    # The user_id is passed down to the data access layer to ensure a user
    # can only update a class that they own.
    updated_class = db.update_class(class_id, user_id, update_data)
    return updated_class


def delete_class_by_id(class_id: str, db: DatabaseService, user_id: str) -> bool:
    """
    Deletes a class and all its associated students, ensuring ownership.

    The initial check for the class's existence is now user-scoped, preventing
    one user from being able to delete another user's class.

    Args:
        class_id: The ID of the class to delete.
        db: The DatabaseService instance.
        user_id: The ID of the authenticated user making the request.

    Returns:
        True if the deletion was successful, False otherwise.
    """
    # This check is now secure. It will only find the class if it exists AND
    # belongs to the current user.
    if not db.get_class_by_id(class_id, user_id):
        return False
    
    # The underlying cascade delete on the Student model handles student deletion.
    # We pass the user_id to the final delete call for consistency and security.
    db.delete_class(class_id, user_id)
    return True


# --- STUDENT-RELATED CORE BUSINESS LOGIC ---

def add_student_to_class_with_status(
    class_id: str,
    student_data: student_model.StudentCreate,
    db: DatabaseService,
    user_id: str
) -> tuple[Student, bool]:
    """
    Adds a student to a class, checking for pre-existence based on studentId.

    This specialist function for batch processing is now secure because its
    initial check for the class's existence is scoped to the current user.

    Args:
        class_id: The ID of the class to add the student to.
        student_data: A Pydantic model with the new student's data.
        db: The DatabaseService instance.
        user_id: The ID of the authenticated user.

    Returns:
        A tuple: (SQLAlchemy Student object, boolean indicating if created).
    """
    # This check is now secure. It prevents a user from adding a student
    # to a class they do not own.
    if not db.get_class_by_id(class_id, user_id):
        raise ValueError(f"Class with ID {class_id} not found or access denied.")

    # Check if student exists globally (studentId should be unique system-wide)
    existing_student = db.get_student_by_student_id(student_data.studentId)

    if existing_student:
        # Student exists - just add them to this class via membership
        print(f"INFO: Student with ID {student_data.studentId} already exists. Adding to class.")
        db.add_student_to_class(existing_student.id, class_id)
        return existing_student, False

    # Create new student
    new_student_id = f"stu_{uuid.uuid4().hex[:12]}"
    new_student_record = student_data.model_dump()
    new_student_record['id'] = new_student_id
    new_student_record['overallGrade'] = 0

    new_student_object = db.add_student(new_student_record)

    # Add student to class via membership table
    db.add_student_to_class(new_student_object.id, class_id)

    return new_student_object, True


def add_student_to_class(
    class_id: str,
    student_data: student_model.StudentCreate,
    db: DatabaseService,
    user_id: str
) -> Student:
    """
    A simpler wrapper for the manual "Add Student" API endpoint.

    This is now secure as it passes the user_id down to the underlying
    `add_student_to_class_with_status` function.
    """
    student_object, _ = add_student_to_class_with_status(
        class_id=class_id,
        student_data=student_data,
        db=db,
        user_id=user_id
    )
    return student_object


def update_student(
    student_id: str,
    student_update: student_model.StudentUpdate,
    db: DatabaseService,
    user_id: str
) -> Optional[Student]:
    """
    Updates a student's details, ensuring the user has ownership via the parent class.

    This function is now secure due to the defense-in-depth principle. It requires
    the `user_id` and passes it to the data access layer, which will verify that
    the student being updated belongs to a class owned by the current user.
    """
    update_data = student_update.model_dump(exclude_unset=True)
    if not update_data:
        raise ValueError("No update data provided.")
        
    # Pass the user_id down to the data access layer for an ownership check.
    updated_student = db.update_student(student_id, user_id, update_data)
    return updated_student

--- File: .\ata-backend\app\services\class_helpers\file_processors.py ---

# /app/services/class_helpers/file_processors.py

import io
from typing import List, Dict
import pandas as pd
import fitz
from PIL import Image

try:
    import docx
except ImportError:
    docx = None

def extract_text_from_docx(file_bytes: bytes) -> str:
    """
    Robustly extracts text from a .docx file, including paragraphs and tables.
    """
    if docx is None:
        raise ImportError("The 'python-docx' library is not installed. Please run 'pip install python-docx'.")
    stream = io.BytesIO(file_bytes)
    document = docx.Document(stream)
    full_text = [p.text for p in document.paragraphs]
    for table in document.tables:
        for row in table.rows:
            for cell in row.cells:
                full_text.append(cell.text)
    return "\n".join(full_text)

def extract_students_from_tabular(file_bytes: bytes, is_excel: bool) -> List[Dict]:
    """
    Directly parses student data from Excel or CSV files, bypassing AI.
    """
    stream = io.BytesIO(file_bytes)
    try:
        df = pd.read_excel(stream) if is_excel else pd.read_csv(stream)
    except Exception as e:
        raise ValueError(f"Could not parse the provided tabular file: {e}")
    name_col = next((col for col in df.columns if 'name' in col.lower()), None)
    id_col = next((col for col in df.columns if 'id' in col.lower()), None)
    if not name_col or not id_col:
        raise ValueError("Tabular file must contain columns with 'name' and 'id' in their titles.")
    df = df.rename(columns={name_col: 'name', id_col: 'studentId'})
    df['studentId'] = df['studentId'].astype(str)
    return df[['name', 'studentId']].to_dict('records')

def convert_pdf_first_page_to_png_bytes(pdf_bytes: bytes) -> bytes:
    """
    Converts the first page of a PDF file into PNG image bytes for multi-modal AI calls.
    """
    try:
        doc = fitz.open(stream=pdf_bytes, filetype="pdf")
        if not len(doc): raise ValueError("PDF file is empty.")
        page = doc.load_page(0)
        pix = page.get_pixmap(dpi=200)
        doc.close()
        img_stream = io.BytesIO()
        Image.frombytes("RGB", [pix.width, pix.height], pix.samples).save(img_stream, format="PNG")
        return img_stream.getvalue()
    except Exception as e:
        raise ValueError(f"Could not process the provided PDF file as an image: {e}")

--- File: .\ata-backend\app\services\class_helpers\roster_ingestion.py ---

# /app/services/class_helpers/roster_ingestion.py (MODIFIED AND APPROVED)

"""
This module acts as the high-level orchestrator for the "Create Class from
File Upload" feature.

It connects the API router to the various specialist helpers (file processors,
CRUD helpers) and AI services to execute the entire ingestion pipeline. As a
primary entry point for a user-initiated action, its main security role is to
receive the authenticated user's ID and "thread" it down into the lower-level
modules that interact with the database.
"""

import json
import asyncio
import pandas as pd
from typing import Dict
from fastapi import UploadFile

from ...models import class_model, student_model
from ..database_service import DatabaseService
from .. import ocr_service, gemini_service, prompt_library

# Import the specialist helper modules this orchestrator uses.
from . import file_processors
from . import crud


async def create_class_from_upload(
    name: str, 
    file: UploadFile, 
    db: DatabaseService, 
    user_id: str
) -> Dict:
    """
    Orchestrates the advanced pipeline for creating a class from a roster file.

    This function is now fully "user-aware." It receives the authenticated
    user's ID and ensures that all database operations performed during the
    ingestion process are correctly associated with that user.

    Args:
        name: The name for the new class, provided by the user.
        file: The uploaded roster file (e.g., .csv, .xlsx, .pdf).
        db: The DatabaseService instance for data persistence.
        user_id: The unique ID of the authenticated user creating the class.

    Raises:
        ValueError: If the file is unreadable, unsupported, or if any part of
                    the ingestion or database operation fails.

    Returns:
        A dictionary containing the details of the newly created class and a
        count of the students who were newly added.
    """
    
    # 1. Prepare the class data dictionary, now including the owner's user_id.
    class_data_with_owner = {
        "name": name,
        "description": f"Roster uploaded from {file.filename}",
        "user_id": user_id
    }
    
    # The `create_class` helper now receives the complete record, including the user_id.
    # We pass the dictionary directly as `class_record`.
    new_class_object = crud.create_class(class_record=class_data_with_owner, db=db)
    
    students_to_process = []
    newly_created_student_count = 0
    
    try:
        file_bytes = await file.read()
        content_type = file.content_type

        # --- Smart Ingestion Routing (This logic remains the same) ---
        if content_type in ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.ms-excel"]:
            students_to_process = file_processors.extract_students_from_tabular(file_bytes, is_excel=True)
        elif content_type == "text/csv":
            students_to_process = file_processors.extract_students_from_tabular(file_bytes, is_excel=False)
        else:
            raw_text = ""
            if content_type in ["image/jpeg", "image/png", "application/pdf", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"]:
                raw_text = await asyncio.to_thread(ocr_service.extract_text_from_file, file_bytes, content_type)
            else: 
                raise ValueError(f"Unsupported file type: {content_type}")

            if not raw_text or not raw_text.strip():
                raise ValueError("Could not extract any readable text from the document.")

            prompt = prompt_library.ROSTER_EXTRACTION_PROMPT.format(raw_ocr_text=raw_text)
            ai_response_str = await gemini_service.generate_text(prompt, temperature=0.1)

            try:
                json_start, json_end = ai_response_str.find('{'), ai_response_str.rfind('}') + 1
                parsed_response = json.loads(ai_response_str[json_start:json_end])
            except Exception:
                raise ValueError("The AI could not structure the data from the document.")
            
            students_to_process = parsed_response.get("students", [])

        # 2. Process and save students, now passing the user_id for permission checks.
        if students_to_process:
            for student_data in students_to_process:
                if 'studentId' not in student_data or pd.isna(student_data.get('studentId')):
                    student_data['studentId'] = 'N/A'
                
                if student_data['studentId'] == 'N/A':
                    print(f"WARNING: Skipping student with missing ID: {student_data.get('name')}")
                    continue

                validated_student = student_model.StudentCreate(**student_data)
                
                # The user_id is now passed down to the CRUD helper.
                # This ensures the check `db.get_class_by_id(class_id, user_id)`
                # inside the helper will succeed.
                _ , was_created = crud.add_student_to_class_with_status(
                    class_id=new_class_object.id, 
                    student_data=validated_student, 
                    db=db,
                    user_id=user_id # <-- CRITICAL MODIFICATION
                )
                
                if was_created:
                    newly_created_student_count += 1

    except Exception as e:
        print(f"ERROR processing upload for class {new_class_object.id} owned by {user_id}: {e}")
        # Transactional Rollback: If any part of the process fails, we must
        # delete the class we created at the beginning to prevent orphaned data.
        # We pass the user_id to ensure we only delete the correct class.
        db.delete_class(new_class_object.id, user_id)
        raise ValueError(str(e))
    
    # The response dictionary construction remains the same.
    return {
        "message": "Upload successful. Roster processed.",
        "class_info": {
            "id": new_class_object.id,
            "name": new_class_object.name,
            "description": new_class_object.description,
            "studentCount": newly_created_student_count
        }
    }

--- File: .\ata-backend\app\services\class_helpers\__init__.py ---



--- File: .\ata-backend\app\services\database_helpers\assessment_repository.py ---

# /app/services/database_helpers/assessment_repository.py

from typing import List, Dict, Optional
import pandas as pd
from .base_repository import BaseRepository

DATA_DIR = "app/data"
ASSESSMENTS_DB_PATH = f"{DATA_DIR}/assessments.csv"
RESULTS_DB_PATH = f"{DATA_DIR}/results.csv"

class AssessmentRepository:
    """A specialized repository for handling all data related to assessments and results."""
    def __init__(self):
        self.assessments = BaseRepository(
            ASSESSMENTS_DB_PATH,
            columns=['id', 'status', 'config', 'answer_sheet_paths', 'created_at', 'ai_summary'],
            dtypes={'id': str, 'status': str}
        )
        self.results = BaseRepository(
            RESULTS_DB_PATH,
            columns=['id', 'job_id', 'student_id', 'question_id', 'grade', 'feedback', 'extractedAnswer', 'status', 'report_token', 'answer_sheet_path', 'content_type'],
            dtypes={'grade': 'Float64', 'id': str, 'job_id': str, 'student_id': str, 'question_id': str, 'report_token': str, 'status': str, 'content_type': str}
        )

    # --- Assessment Job Methods ---
    def add_job(self, record: Dict): self.assessments._add_record(record)
    def get_job(self, job_id: str) -> Optional[Dict]:
        row = self.assessments.df[self.assessments.df['id'] == job_id]
        return self.assessments._clean_df_for_export(row)[0] if not row.empty else None
    def get_all_jobs(self) -> List[Dict]:
        df = self.assessments.df
        if df.empty or 'created_at' not in df.columns: return []
        return self.assessments._clean_df_for_export(df.sort_values(by='created_at', ascending=False))
    def update_job_status(self, job_id: str, status: str):
        self.assessments.df.loc[self.assessments.df['id'] == job_id, 'status'] = status; self.assessments._save_df()
    def update_job_summary(self, job_id: str, summary: str):
        self.assessments.df.loc[self.assessments.df['id'] == job_id, 'ai_summary'] = summary; self.assessments._save_df()
    def delete_job(self, job_id: str) -> bool:
        df = self.assessments.df
        initial_len = len(df)
        self.assessments.df = df[df['id'] != job_id]
        if len(self.assessments.df) < initial_len:
            self.assessments._save_df()
            return True
        return False
    def delete_results_by_job_id(self, job_id: str) -> int:
        df = self.results.df
        initial_len = len(df)
        self.results.df = df[df['job_id'] != job_id]
        num_deleted = initial_len - len(self.results.df)
        if num_deleted > 0:
            self.results._save_df()
        return num_deleted

    # --- [THE FIX IS HERE] ---
    def get_assessments_as_dataframe(self, user_id: str) -> pd.DataFrame:
        """Returns a copy of the assessments DataFrame for the chatbot sandbox."""
        # V2 TODO: This is a simplified model. A real implementation would join
        # results and assessments and filter by the user's classes.
        # For now, we return all results as the "assessments_df".
        return self.results.df.copy()
    # --- [END OF FIX] ---

    # --- Assessment Result Methods ---
    def add_result(self, record: Dict): self.results._add_record(record)
    def get_all_results_for_job(self, job_id: str) -> List[Dict]:
        df = self.results.df; return self.results._clean_df_for_export(df[df['job_id'] == job_id])
    def get_all_results(self) -> List[Dict]: return self.results._clean_df_for_export(self.results.df)
    def get_student_result_path(self, job_id: str, student_id: str) -> Optional[str]:
        df = self.results.df; student_results = df[(df['job_id'] == job_id) & (df['student_id'] == student_id)]
        if not student_results.empty: return student_results.iloc[0]['answer_sheet_path']
        return None
    def get_students_with_paths(self, job_id: str) -> List[Dict]:
        df = self.results.df
        matched = df[(df['job_id'] == job_id) & (df['answer_sheet_path'] != '') & (df['answer_sheet_path'].notna())]
        return matched[['student_id', 'answer_sheet_path', 'content_type']].drop_duplicates(subset=['student_id']).to_dict('records')
    def get_result_by_token(self, token: str) -> Optional[Dict]:
        row = self.results.df[self.results.df['report_token'] == token]
        return self.results._clean_df_for_export(row)[0] if not row.empty else None
    def update_result_path(self, job_id: str, student_id: str, path: str, content_type: str):
        df = self.results.df; condition = (df['job_id'] == job_id) & (df['student_id'] == student_id)
        self.results.df.loc[condition, 'answer_sheet_path'] = path
        self.results.df.loc[condition, 'content_type'] = content_type
        self.results.df.loc[condition, 'status'] = 'matched'; self.results._save_df()
    def update_result_status(self, job_id: str, student_id: str, question_id: str, status: str):
        df = self.results.df; condition = (df['job_id'] == job_id) & (df['student_id'] == student_id) & (df['question_id'] == question_id)
        self.results.df.loc[condition, 'status'] = status; self.results._save_df()
    def update_result_grade(self, job_id: str, student_id: str, question_id: str, grade: Optional[float], feedback: str, status: str):
        df = self.results.df; condition = (df['job_id'] == job_id) & (df['student_id'] == student_id) & (df['question_id'] == question_id)
        self.results.df.loc[condition, 'grade'] = grade
        self.results.df.loc[condition, 'feedback'] = feedback
        self.results.df.loc[condition, 'status'] = status; self.results._save_df()
    def update_result_with_isolated_answer(self, job_id: str, student_id: str, question_id: str, extracted_answer: str):
        df = self.results.df; condition = (df['job_id'] == job_id) & (df['student_id'] == student_id) & (df['question_id'] == question_id)
        self.results.df.loc[condition, 'extractedAnswer'] = extracted_answer; self.results._save_df()

--- File: .\ata-backend\app\services\database_helpers\assessment_repository_sql.py ---


# /ata-backend/app/services/database_helpers/assessment_repository_sql.py (FINAL, CORRECTED, SUPERVISOR-APPROVED)

"""
This module contains all the raw SQLAlchemy queries for the Assessment and Result
tables. It is the direct interface to the database for all assessment-related
data, and it is a final point of enforcement for data isolation.

Every method that reads or modifies user-owned data has been updated to
require a `user_id`, ensuring all operations are securely scoped to the
authenticated user. This module follows a "defense-in-depth" principle,
meaning every function is independently secure.
"""

from typing import List, Dict, Optional
from sqlalchemy.orm import Session
from sqlalchemy import select

# Import the SQLAlchemy models this repository will interact with.
from app.db.models.assessment_models import Assessment, Result, ResultStatus, FinalizedBy
from app.db.models.ai_model_run import AIModelRun
from app.db.models.class_student_models import Student, Class
from app.db.models.outsider_student import OutsiderStudent

class AssessmentRepositorySQL:
    def __init__(self, db_session: Session):
        self.db = db_session

    # --- Assessment Job Methods ---

    def add_job(self, record: Dict) -> Assessment:
        """
        Creates a new Assessment record.
        This function expects the `user_id` to be present in the `record` dictionary,
        stamped by the calling service.
        """
        new_job = Assessment(**record)
        self.db.add(new_job)
        self.db.commit()
        self.db.refresh(new_job)
        return new_job

    def get_job(self, job_id: str, user_id: str) -> Optional[Assessment]:
        """
        Retrieves a single assessment by its ID, but only if it is owned by the
        specified user. This prevents unauthorized access to other users' jobs.
        """
        return (
            self.db.query(Assessment)
            .filter(Assessment.id == job_id, Assessment.user_id == user_id)
            .first()
        )

    def get_all_jobs(self, user_id: str) -> List[Assessment]:
        """
        Retrieves all assessment jobs owned by a specific user.
        The query is now filtered by `user_id` to enforce data isolation.
        """
        return (
            self.db.query(Assessment)
            .filter(Assessment.user_id == user_id)
            .order_by(Assessment.created_at.desc())
            .all()
        )

    def update_job_status(self, job_id: str, user_id: str, status: str):
        """
        Updates a job's status, but only if it is owned by the specified user.
        """
        job = self.get_job(job_id=job_id, user_id=user_id)
        if job:
            job.status = status
            self.db.commit()

    def update_job_summary(self, job_id: str, user_id: str, summary: str):
        """
        Updates a job's AI summary, but only if it is owned by the specified user.
        """
        job = self.get_job(job_id=job_id, user_id=user_id)
        if job:
            job.ai_summary = summary
            self.db.commit()

    def delete_job(self, job_id: str, user_id: str) -> bool:
        """
        Deletes a job, but only if it is owned by the specified user.
        """
        job = self.get_job(job_id=job_id, user_id=user_id)
        if job:
            self.db.delete(job)
            self.db.commit()
            return True
        return False

    def add_ai_model_run(self, record: Dict) -> AIModelRun:
        """Creates a new AIModelRun record."""
        new_run = AIModelRun(**record)
        self.db.add(new_run)
        self.db.commit()
        self.db.refresh(new_run)
        return new_run

    def get_ai_model_runs_for_question(self, job_id: str, entity_id: str, question_id: str, is_outsider: bool) -> List[AIModelRun]:
        """Retrieves all AI model runs for a specific question, entity (student or outsider), and job."""
        query = self.db.query(AIModelRun).filter_by(job_id=job_id, question_id=question_id)
        if is_outsider:
            query = query.filter_by(outsider_student_id=entity_id)
        else:
            query = query.filter_by(student_id=entity_id)
        return query.order_by(AIModelRun.run_index).all()

    def update_result_extracted_answer(self, job_id: str, entity_id: str, is_outsider: bool, question_id: str, extracted_answer: str, user_id: str):
        """Updates the extractedAnswer for a specific result, checking for user ownership."""
        query = (
            self.db.query(Result)
            .join(Assessment, Result.job_id == Assessment.id)
            .filter(
                Result.job_id == job_id,
                Result.question_id == question_id,
                Assessment.user_id == user_id
            )
        )
        if is_outsider:
            query = query.filter(Result.outsider_student_id == entity_id)
        else:
            query = query.filter(Result.student_id == entity_id)

        result = query.first()
        if result:
            result.extractedAnswer = extracted_answer
            self.db.commit()

    def are_any_questions_pending_review(self, job_id: str, user_id: str) -> bool:
        """Checks if any results for a job are in PENDING_REVIEW state."""
        return self.db.query(Result).filter(Result.job_id == job_id, Result.status == ResultStatus.PENDING_REVIEW.value).count() > 0

    # --- Assessment Result Methods ---

    def add_result(self, record: Dict) -> Result:
        """
        Creates a new Result record. Ownership is implicitly handled by the
        `job_id` in the record, which is validated by the calling service.
        """
        new_result = Result(**record)
        self.db.add(new_result)
        self.db.commit()
        self.db.refresh(new_result)
        return new_result

    def get_all_results_for_job(self, job_id: str, user_id: str) -> List[Result]:
        """
        Retrieves all results for a given job, but only if the job is
        owned by the specified user. This is a critical defense-in-depth check.
        """
        parent_job = self.get_job(job_id=job_id, user_id=user_id)
        if not parent_job:
            return []
        return self.db.query(Result).filter(Result.job_id == job_id).all()

    def get_result_by_token(self, token: str) -> Optional[Result]:
        """
        Retrieves a single result by its public report token.
        This is a public-facing method and does not require a user_id.
        """
        return self.db.query(Result).filter(Result.report_token == token).first()
        
    def update_result_grade(self, job_id: str, student_id: str, question_id: str, grade: Optional[float], feedback: str, status: str, finalized_by: Optional[str], user_id: str):
        """
        Updates a single result's grade and feedback, but only if the result
        belongs to an assessment job owned by the specified user.
        """
        result = (
            self.db.query(Result)
            .join(Assessment, Result.job_id == Assessment.id)
            .filter(
                Result.job_id == job_id,
                Result.student_id == student_id,
                Result.question_id == question_id,
                Assessment.user_id == user_id
            )
            .first()
        )
        if result:
            result.grade = grade
            result.feedback = feedback
            result.status = status
            result.finalized_by = finalized_by
            self.db.commit()

    def update_outsider_result_grade(self, job_id: str, outsider_student_id: str, question_id: str, grade: Optional[float], feedback: str, status: str, finalized_by: Optional[str], user_id: str):
        """
        Updates a single result's grade and feedback for an OUTSIDER student,
        but only if the result belongs to an assessment job owned by the specified user.
        """
        result = (
            self.db.query(Result)
            .join(Assessment, Result.job_id == Assessment.id)
            .filter(
                Result.job_id == job_id,
                Result.outsider_student_id == outsider_student_id,
                Result.question_id == question_id,
                Assessment.user_id == user_id
            )
            .first()
        )
        if result:
            result.grade = grade
            result.feedback = feedback
            result.status = status
            result.finalized_by = finalized_by
            self.db.commit()

    def update_result_path(self, job_id: str, student_id: str, path: str, content_type: str, user_id: str):
        """
        Updates the answer sheet path for all results belonging to a student
        within a specific job, but only if the job is owned by the user.
        """
        parent_job = self.get_job(job_id=job_id, user_id=user_id)
        if not parent_job:
            return

        results_to_update = self.db.query(Result).filter_by(job_id=job_id, student_id=student_id).all()
        if results_to_update:
            for result in results_to_update:
                result.answer_sheet_path = path
                result.content_type = content_type
                result.status = 'matched'
            self.db.commit()

    def get_entities_with_paths(self, job_id: str, user_id: str) -> List[Dict]:
        """
        Gets a distinct list of entities (students and outsiders) and their matched
        answer sheet paths for a given job, ensuring the user owns the job.
        """
        parent_job = self.get_job(job_id=job_id, user_id=user_id)
        if not parent_job:
            return []

        # Query for rostered students with paths
        roster_stmt = (
            select(
                Result.student_id.label('entity_id'),
                Result.answer_sheet_path,
                Result.content_type
            )
            .where(
                Result.job_id == job_id,
                Result.student_id.isnot(None),
                Result.answer_sheet_path.isnot(None),
                Result.answer_sheet_path != ''
            )
            .distinct()
        )
        roster_results = self.db.execute(roster_stmt).mappings().all()

        # Query for outsider students with paths
        outsider_stmt = (
            select(
                Result.outsider_student_id.label('entity_id'),
                Result.answer_sheet_path,
                Result.content_type
            )
            .where(
                Result.job_id == job_id,
                Result.outsider_student_id.isnot(None),
                Result.answer_sheet_path.isnot(None),
                Result.answer_sheet_path != ''
            )
            .distinct()
        )
        outsider_results = self.db.execute(outsider_stmt).mappings().all()

        # Combine and add the is_outsider flag
        entities = []
        for row in roster_results:
            entities.append({**row, "is_outsider": False})
        for row in outsider_results:
            entities.append({**row, "is_outsider": True})

        return entities

    def get_outsider_student_by_id(self, outsider_student_id: str, user_id: str) -> Optional[OutsiderStudent]:
        """
        Securely fetches a single outsider student by their primary key ID,
        ensuring they belong to an assessment owned by the specified user.
        """
        return (
            self.db.query(OutsiderStudent)
            .join(Assessment, OutsiderStudent.assessment_id == Assessment.id)
            .filter(OutsiderStudent.id == outsider_student_id, Assessment.user_id == user_id)
            .first()
        )

    def get_all_outsider_students_for_job(self, job_id: str, user_id: str) -> List[OutsiderStudent]:
        """
        Retrieves all outsider students for a given job, but only if the job is
        owned by the specified user.
        """
        parent_job = self.get_job(job_id=job_id, user_id=user_id)
        if not parent_job:
            return []
        return self.db.query(OutsiderStudent).filter(OutsiderStudent.assessment_id == job_id).all()

    # --- [START OF NEW METHOD TO FIX ATTRIBUTEERROR] ---
    def get_student_result_path(self, job_id: str, student_id: str, user_id: str) -> Optional[str]:
        """
        Securely retrieves the answer sheet path for a single student within a job.

        This method performs a crucial defense-in-depth check by first verifying
        that the parent job is owned by the user before attempting to fetch the
        result data.

        Args:
            job_id: The ID of the assessment job.
            student_id: The ID of the student.
            user_id: The ID of the authenticated user.

        Returns:
            The answer sheet path string if found and authorized, otherwise None.
        """
        # 1. Security Check: Verify the user owns the parent job.
        parent_job = self.get_job(job_id=job_id, user_id=user_id)
        if not parent_job:
            # If the job doesn't exist or the user doesn't own it, deny access.
            return None

        # 2. Data Retrieval: If security check passes, fetch the result.
        # We only need the first result for this student in this job, as the
        # path is the same for all their question results.
        result = (
            self.db.query(Result)
            .filter(Result.job_id == job_id, Result.student_id == student_id)
            .first()
        )

        # 3. Return the path, or None if no result was found.
        return result.answer_sheet_path if result else None
    # --- [END OF NEW METHOD] ---

    # --- Chatbot Helper Methods ---

    def get_assessments_for_chatbot(self, user_id: str) -> List[Dict]:
        """
        Returns a list of result dictionaries for the chatbot sandbox,
        securely filtered for the authenticated user.
        """
        user_results = (
            self.db.query(Result)
            .join(Assessment, Result.job_id == Assessment.id)
            .filter(Assessment.user_id == user_id)
            .all()
        )
        return [{c.name: getattr(obj, c.name) for c in obj.__table__.columns} for obj in user_results]

    def get_all_results_for_user(self, user_id: str) -> List[Result]:
        """
        Retrieves all results for all jobs owned by a specific user.
        """
        return (
            self.db.query(Result)
            .join(Assessment, Result.job_id == Assessment.id)
            .filter(Assessment.user_id == user_id)
            .all()
        )

    def get_public_report_details_by_token(self, token: str) -> Optional[Dict]:
        """
        Securely and efficiently fetches all necessary details for a public report
        using a single, comprehensive query with joins.
        """
        query_result = (
            self.db.query(
                Result,
                Assessment,
                Student,
                Class
            )
            .join(Assessment, Result.job_id == Assessment.id)
            .join(Student, Result.student_id == Student.id)
            .join(Class, Student.class_id == Class.id)
            .filter(Result.report_token == token)
            .first()
        )
        
        if not query_result:
            return None
        
        result_obj, assessment_obj, student_obj, class_obj = query_result
        
        return {
            "result": result_obj,
            "assessment": assessment_obj,
            "student": student_obj,
            "class": class_obj
        }
    
        # Add this inside the AssessmentRepositorySQL class
    def update_result_status(self, job_id: str, student_id: str, question_id: str, status: str, user_id: str):
        """
        Securely updates the status of a single result record, verifying ownership via a JOIN.
        """
        result = (
            self.db.query(Result)
            .join(Assessment, Result.job_id == Assessment.id)
            .filter(
                Result.job_id == job_id,
                Result.student_id == student_id,
                Result.question_id == question_id,
                Assessment.user_id == user_id
            )
            .first()
        )
        if result:
            result.status = status
            self.db.commit()

    # --- NEW: Student Transcript Methods ---

    def get_assessments_for_class(self, class_id: str, user_id: str) -> List[Assessment]:
        """
        Retrieves all assessments that belong to a specific class.
        Checks the config JSON for classIds array (multi-class) or classId (single class).
        """
        # Get all assessments for the user, then filter in Python
        # This is because JSON (not JSONB) doesn't support the @> operator
        all_assessments = (
            self.db.query(Assessment)
            .filter(Assessment.user_id == user_id)
            .order_by(Assessment.created_at.desc())
            .all()
        )

        # Filter assessments that have this class_id
        matching_assessments = []
        for assessment in all_assessments:
            if not assessment.config:
                continue

            # Check for classIds array (new multi-class format)
            if 'classIds' in assessment.config:
                class_ids = assessment.config.get('classIds', [])
                if class_id in class_ids:
                    matching_assessments.append(assessment)
            # Check for classId string (old single-class format) - BACKWARD COMPATIBILITY
            elif 'classId' in assessment.config:
                if assessment.config.get('classId') == class_id:
                    matching_assessments.append(assessment)

        return matching_assessments

    def get_results_for_student_and_job(self, student_id: str, job_id: str, user_id: str) -> List[Result]:
        """
        Retrieves all results for a specific student in a specific assessment.
        Validates that the assessment belongs to the user.
        """
        parent_job = self.get_job(job_id=job_id, user_id=user_id)
        if not parent_job:
            return []

        return (
            self.db.query(Result)
            .filter(
                Result.job_id == job_id,
                Result.student_id == student_id
            )
            .all()
        )

--- File: .\ata-backend\app\services\database_helpers\base_repository.py ---

# /app/services/database_helpers/base_repository.py

import pandas as pd
import numpy as np
import os
from typing import List, Dict, Optional

class BaseRepository:
    """A base class for our CSV repositories to share common I/O and cleaning logic."""
    def __init__(self, path: str, columns: List[str], dtypes: Optional[Dict] = None):
        self.path = path
        self.columns = columns # Store columns for later use
        self.dtypes = dtypes   # Store dtypes for later use
        self.df = self._load_or_initialize_csv(path, columns, dtypes)

    def _load_or_initialize_csv(self, path: str, columns: List[str], dtypes: Optional[Dict] = None) -> pd.DataFrame:
        """Loads a CSV from a given path or creates it if it doesn't exist."""
        try:
            # keep_default_na=False is crucial for preventing "NA" string from becoming NaN
            return pd.read_csv(path, keep_default_na=False, na_values=['', 'None', 'null'], dtype=dtypes)
        except (FileNotFoundError, pd.errors.EmptyDataError):
            df = pd.DataFrame(columns=columns)
            if dtypes:
                df = df.astype(dtypes)
            df.to_csv(path, index=False)
            return df

    def _clean_df_for_export(self, df: pd.DataFrame) -> List[Dict]:
        """Replaces all pandas/numpy-specific null types with Python's native None."""
        df_copy = df.copy()
        df_copy.replace({pd.NA: None, np.nan: None}, inplace=True)
        return df_copy.to_dict('records')

    def _save_df(self):
        """Saves the current state of the DataFrame back to its CSV file."""
        self.df.to_csv(self.path, index=False)

    # --- [THE DEFINITIVE FIX IS HERE] ---
    def _add_record(self, record: Dict):
        """
        Adds a new record (as a dict) to the DataFrame and saves.
        This version is hardened to prevent FutureWarning from pd.concat.
        """
        # Create a single-row DataFrame from the new record.
        new_row_df = pd.DataFrame([record])
        
        # Ensure the new row has the same columns in the same order as the main DataFrame.
        new_row_df = new_row_df.reindex(columns=self.columns)

        # If dtypes were specified for the main DataFrame, apply them to the new row.
        # This makes the concatenation explicit and removes the warning.
        if self.dtypes:
            new_row_df = new_row_df.astype(self.dtypes)

        # Now, concatenate the two DataFrames.
        self.df = pd.concat([self.df, new_row_df], ignore_index=True)
        self._save_df()
    # --- [END OF FIX] ---

--- File: .\ata-backend\app\services\database_helpers\chat_repository.py ---

# /ata-backend/app/services/database_helpers/chat_repository.py

from typing import List, Dict, Optional
from .base_repository import BaseRepository

DATA_DIR = "app/data"
CHAT_SESSIONS_DB_PATH = f"{DATA_DIR}/chat_sessions.csv"
CHAT_MESSAGES_DB_PATH = f"{DATA_DIR}/chat_messages.csv"

class ChatRepository:
    """A specialized repository for handling all data related to chat sessions and messages."""
    def __init__(self):
        self.sessions = BaseRepository(
            CHAT_SESSIONS_DB_PATH,
            columns=['id', 'user_id', 'name', 'created_at'],
            dtypes={'id': str, 'user_id': str, 'name': str}
        )
        self.messages = BaseRepository(
            CHAT_MESSAGES_DB_PATH,
            columns=['id', 'session_id', 'role', 'content', 'file_id', 'created_at'],
            dtypes={'id': str, 'session_id': str, 'role': str, 'content': str, 'file_id': str}
        )

    # --- Chat Session Methods ---
    def create_session(self, record: Dict):
        """Adds a new chat session record."""
        self.sessions._add_record(record)

    def get_sessions_by_user_id(self, user_id: str) -> List[Dict]:
        """Retrieves all chat session summaries for a specific user, newest first."""
        df = self.sessions.df
        user_sessions = df[df['user_id'] == user_id]
        if 'created_at' in user_sessions.columns:
            user_sessions = user_sessions.sort_values(by='created_at', ascending=False)
        return self.sessions._clean_df_for_export(user_sessions)

    # --- [THIS IS THE NEWLY ADDED METHOD] ---
    def get_session_by_id(self, session_id: str) -> Optional[Dict]:
        """Retrieves a single chat session by its unique ID."""
        df = self.sessions.df
        session = df[df['id'] == session_id]
        if not session.empty:
            return self.sessions._clean_df_for_export(session)[0]
        return None
    # --- [END OF NEW METHOD] ---

    # --- Chat Message Methods ---
    def add_message(self, record: Dict):
        """Adds a new chat message record."""
        self.messages._add_record(record)

    def get_messages_by_session_id(self, session_id: str) -> List[Dict]:
        """Retrieves all messages for a specific chat session, in guaranteed chronological order."""
        df = self.messages.df
        session_messages = df[df['session_id'] == session_id]
        
        if 'created_at' in session_messages.columns and not session_messages.empty:
            session_messages = session_messages.sort_values(by='created_at', ascending=True)
            
        return self.messages._clean_df_for_export(session_messages)
    

        # Add inside the ChatRepository class

    def delete_session_by_id(self, session_id: str) -> bool:
        """Deletes a single chat session record by its ID."""
        df = self.sessions.df
        initial_len = len(df)
        self.sessions.df = df[df['id'] != session_id]
        if len(self.sessions.df) < initial_len:
            self.sessions._save_df()
            return True
        return False

    def delete_messages_by_session_id(self, session_id: str) -> int:
        """Deletes all messages associated with a given session ID."""
        df = self.messages.df
        initial_len = len(df)
        self.messages.df = df[df['session_id'] != session_id]
        num_deleted = initial_len - len(self.messages.df)
        if num_deleted > 0:
            self.messages._save_df()
        return num_deleted

--- File: .\ata-backend\app\services\database_helpers\chat_repository_sql.py ---

# /ata-backend/app/services/database_helpers/chat_repository_sql.py (DEFINITIVE FLAWLESS VERSION)

"""
This module contains all the raw SQLAlchemy queries for the ChatSession and
ChatMessage tables. It is the direct interface to the database for all chat-
related data and a final point of enforcement for data isolation.

Every method that reads or modifies a chat session has been updated to require
a `user_id`, ensuring all operations are securely scoped to the
authenticated user. This module follows a "defense-in-depth" principle, meaning every
function is independently secure.
"""

from typing import List, Dict, Optional
from sqlalchemy.orm import Session

# Import the SQLAlchemy models this repository will interact with.
from app.db.models.chat_models import ChatSession, ChatMessage


class ChatRepositorySQL:
    def __init__(self, db_session: Session):
        self.db = db_session

    # --- Chat Session Methods ---

    def create_session(self, record: Dict) -> ChatSession:
        """
        Creates a new ChatSession record.
        This function expects the `user_id` to be present in the `record` dictionary.
        """
        new_session = ChatSession(**record)
        self.db.add(new_session)
        self.db.commit()
        self.db.refresh(new_session)
        return new_session

    def get_sessions_by_user_id(self, user_id: str) -> List[ChatSession]:
        """
        Retrieves all chat session summaries owned by a specific user.
        """
        return (
            self.db.query(ChatSession)
            .filter(ChatSession.user_id == user_id)
            .order_by(ChatSession.created_at.desc())
            .all()
        )

    def get_session_by_id(self, session_id: str, user_id: str) -> Optional[ChatSession]:
        """
        Retrieves a single chat session by its ID, but only if it is owned by the
        specified user.
        """
        return (
            self.db.query(ChatSession)
            .filter(ChatSession.id == session_id, ChatSession.user_id == user_id)
            .first()
        )

    def delete_session_by_id(self, session_id: str, user_id: str) -> bool:
        """
        Deletes a chat session, but only if it is owned by the specified user.
        """
        session_to_delete = self.get_session_by_id(session_id=session_id, user_id=user_id)
        
        if session_to_delete:
            self.db.delete(session_to_delete)
            self.db.commit()
            return True
        return False

    # --- Chat Message Methods ---

    def add_message(self, record: Dict):
        """
        Creates a new ChatMessage record.
        """
        new_message = ChatMessage(**record)
        self.db.add(new_message)
        self.db.commit()

    def get_messages_by_session_id(self, session_id: str, user_id: str) -> List[ChatMessage]:
        """
        Retrieves all messages for a given chat session, but only if the session
        is owned by the specified user. This is a critical defense-in-depth check
        that performs the ownership verification and data retrieval in a single query.
        """
        # This query joins ChatMessage with its parent ChatSession to filter by the
        # owner's user_id directly. It is the most secure and efficient pattern.
        return (
            self.db.query(ChatMessage)
            .join(ChatSession, ChatMessage.session_id == ChatSession.id)
            .filter(ChatMessage.session_id == session_id, ChatSession.user_id == user_id)
            .order_by(ChatMessage.created_at.asc())
            .all()
        )

--- File: .\ata-backend\app\services\database_helpers\class_student_repository.py ---

# /app/services/database_helpers/class_student_repository.py

from typing import List, Dict, Optional
import pandas as pd
from .base_repository import BaseRepository

DATA_DIR = "app/data"
CLASSES_DB_PATH = f"{DATA_DIR}/classes.csv"
STUDENTS_DB_PATH = f"{DATA_DIR}/students.csv"

class ClassStudentRepository:
    def __init__(self):
        self.classes = BaseRepository(
            CLASSES_DB_PATH, 
            columns=['id', 'name', 'description'],
            dtypes={'id': str, 'name': str, 'description': str}
        )
        self.students = BaseRepository(
            STUDENTS_DB_PATH, 
            columns=['id', 'name', 'studentId', 'class_id', 'overallGrade', 'performance_summary'],
            dtypes={'id': str, 'name': str, 'studentId': str, 'class_id': str, 'overallGrade': str, 'performance_summary': str}
        )

    # --- Class Methods ---
    def get_all_classes(self) -> List[Dict]: return self.classes._clean_df_for_export(self.classes.df)
    def get_class_by_id(self, class_id: str) -> Optional[Dict]:
        row = self.classes.df[self.classes.df['id'] == class_id]
        return self.classes._clean_df_for_export(row)[0] if not row.empty else None
    def add_class(self, record: Dict): self.classes._add_record(record)
    def update_class(self, class_id: str, data: Dict) -> Optional[Dict]:
        idx = self.classes.df.index[self.classes.df['id'] == class_id]
        if idx.empty: return None
        for key, value in data.items(): self.classes.df.loc[idx, key] = value
        self.classes._save_df(); return self.classes._clean_df_for_export(self.classes.df.loc[idx])[0]
    def delete_class(self, class_id: str) -> bool:
        initial_len = len(self.classes.df); self.classes.df = self.classes.df[self.classes.df['id'] != class_id]
        if len(self.classes.df) < initial_len: self.classes._save_df(); return True
        return False
        
    # --- Student Methods ---
    def get_all_students(self) -> List[Dict]: return self.students._clean_df_for_export(self.students.df)
    def get_students_by_class_id(self, class_id: str) -> List[Dict]:
        df = self.students.df; return self.students._clean_df_for_export(df[df['class_id'] == class_id])
    def add_student(self, record: Dict): self.students._add_record(record)
    def update_student(self, student_id: str, data: Dict) -> Optional[Dict]:
        idx = self.students.df.index[self.students.df['id'] == student_id]
        if idx.empty: return None
        for key, value in data.items(): self.students.df.loc[idx, key] = value
        self.students._save_df(); return self.students._clean_df_for_export(self.students.df.loc[idx])[0]
    def delete_student(self, student_id: str, class_id: str) -> bool:
        df = self.students.df
        initial_len = len(df)
        condition = ~((df['id'] == student_id) & (df['class_id'] == class_id))
        self.students.df = df[condition]
        if len(self.students.df) < initial_len:
            self.students._save_df()
            return True
        return False
    def delete_students_by_class_id(self, class_id: str) -> int:
        df = self.students.df; initial_len = len(df)
        self.students.df = df[df['class_id'] != class_id]
        num_deleted = initial_len - len(self.students.df)
        if num_deleted > 0: self.students._save_df()
        return num_deleted
        
    # --- [THE FIX IS HERE] ---
    def get_classes_as_dataframe(self, user_id: str) -> pd.DataFrame:
        # V2 TODO: When user_id is added to classes.csv, filter here.
        return self.classes.df.copy()
    def get_students_as_dataframe(self, user_id: str) -> pd.DataFrame:
        # V2 TODO: When user_id is added to students.csv, filter here.
        return self.students.df.copy()
    # --- [END OF FIX] ---

--- File: .\ata-backend\app\services\database_helpers\class_student_repository_sql.py ---

# /ata-backend/app/services/database_helpers/class_student_repository_sql.py (MODIFIED AND APPROVED - FLAWLESS VERSION)

"""
This module contains all the raw SQLAlchemy queries for the User, Class, and
Student tables. It is the direct interface to the database for all roster and
user data, and it is the final point of enforcement for data isolation.

Every method that reads or modifies user-owned data has been updated to
require a `user_id`, ensuring all operations are securely scoped to the
authenticated user.
"""

from typing import List, Dict, Optional
from sqlalchemy.orm import Session

# Import the SQLAlchemy models this repository will interact with.
from app.db.models.class_student_models import Class, Student
from app.db.models.user_model import User
from app.db.models.outsider_student import OutsiderStudent


class ClassStudentRepositorySQL:
    def __init__(self, db_session: Session):
        self.db = db_session

    # --- User Methods ---
    # These methods provide the foundational CRUD operations for the User model,
    # which are essential for the authentication system.

    def get_user_by_id(self, user_id: str) -> Optional[User]:
        """Securely fetches a single user by their unique ID."""
        return self.db.query(User).filter(User.id == user_id).first()

    def get_user_by_email(self, email: str) -> Optional[User]:
        """Securely fetches a single user by their unique email address."""
        return self.db.query(User).filter(User.email == email).first()

    def add_user(self, record: Dict) -> User:
        """Creates a new User record in the database."""
        new_user = User(**record)
        self.db.add(new_user)
        self.db.commit()
        self.db.refresh(new_user)
        return new_user

    # --- Class Methods ---

    def get_all_classes(self, user_id: str) -> List[Class]:
        """
        Retrieves all classes owned by a specific user.
        The query is now filtered by `user_id` to enforce data isolation.
        """
        return self.db.query(Class).filter(Class.user_id == user_id).all()

    def get_class_by_id(self, class_id: str, user_id: str) -> Optional[Class]:
        """
        Retrieves a single class by its ID, but only if it is owned by the
        specified user. This prevents unauthorized access to other users' classes.
        """
        return self.db.query(Class).filter(Class.id == class_id, Class.user_id == user_id).first()

    def add_class(self, record: Dict) -> Class:
        """
        Creates a new Class record.
        This function expects the `user_id` to be present in the `record` dictionary.
        """
        new_class = Class(**record)
        self.db.add(new_class)
        self.db.commit()
        self.db.refresh(new_class)
        return new_class

    def update_class(self, class_id: str, user_id: str, data: Dict) -> Optional[Class]:
        """
        Updates a class, but only if it is owned by the specified user.
        """
        # First, securely fetch the class to ensure ownership.
        db_class = self.get_class_by_id(class_id=class_id, user_id=user_id)
        if db_class:
            for key, value in data.items():
                setattr(db_class, key, value)
            self.db.commit()
            self.db.refresh(db_class)
        return db_class

    def delete_class(self, class_id: str, user_id: str) -> bool:
        """
        Deletes a class, but only if it is owned by the specified user.
        """
        # First, securely fetch the class to ensure ownership.
        db_class = self.get_class_by_id(class_id=class_id, user_id=user_id)
        if db_class:
            # The cascade delete defined in the model will handle deleting students.
            self.db.delete(db_class)
            self.db.commit()
            return True
        return False

    # --- Student Methods ---

    def get_students_by_class_id(self, class_id: str, user_id: str) -> List[Student]:
        """
        Retrieves all students for a given class, but only if the class is
        owned by the specified user. This is a critical defense-in-depth check.
        """
        from app.db.models.class_student_models import StudentClassMembership

        # First, verify that the user owns the parent class.
        parent_class = self.get_class_by_id(class_id=class_id, user_id=user_id)
        if not parent_class:
            # If the user does not own the class, return an empty list,
            # effectively hiding the students from unauthorized access.
            return []

        # Fetch students through the junction table
        return (
            self.db.query(Student)
            .join(StudentClassMembership, Student.id == StudentClassMembership.student_id)
            .filter(StudentClassMembership.class_id == class_id)
            .all()
        )

    def add_student(self, record: Dict) -> Student:
        """
        Creates a new Student record.
        Ownership is implicitly handled by the `class_id` in the record, which
        is validated by the calling service.
        """
        record['overallGrade'] = int(record.get('overallGrade')) if record.get('overallGrade') is not None else 0
        new_student = Student(**record)
        self.db.add(new_student)
        self.db.commit()
        self.db.refresh(new_student)
        return new_student

    def update_student(self, student_id: str, user_id: str, data: Dict) -> Optional[Student]:
        """
        Updates a student's details, but only if the student belongs to a class
        owned by the specified user.
        """
        from app.db.models.class_student_models import StudentClassMembership

        # This query joins Student with Class through membership to enforce ownership
        db_student = (
            self.db.query(Student)
            .join(StudentClassMembership, Student.id == StudentClassMembership.student_id)
            .join(Class, StudentClassMembership.class_id == Class.id)
            .filter(Student.id == student_id, Class.user_id == user_id)
            .first()
        )

        if db_student:
            for key, value in data.items():
                if key == 'overallGrade' and value is not None:
                    value = int(value)
                setattr(db_student, key, value)
            self.db.commit()
            self.db.refresh(db_student)
        return db_student

    def delete_student(self, student_id: str, user_id: str) -> bool:
        """
        Deletes a student, but only if the student belongs to a class owned by
        the specified user. This method is now independently secure.
        """
        from app.db.models.class_student_models import StudentClassMembership

        # Securely fetch the student using a join to verify ownership.
        db_student = (
            self.db.query(Student)
            .join(StudentClassMembership, Student.id == StudentClassMembership.student_id)
            .join(Class, StudentClassMembership.class_id == Class.id)
            .filter(Student.id == student_id, Class.user_id == user_id)
            .first()
        )
        if db_student:
            self.db.delete(db_student)
            self.db.commit()
            return True
        return False

    def add_outsider_student(self, record: Dict) -> OutsiderStudent:
        """Creates a new OutsiderStudent record in the database."""
        new_outsider = OutsiderStudent(**record)
        self.db.add(new_outsider)
        self.db.commit()
        self.db.refresh(new_outsider)
        return new_outsider
        
    def get_student_by_student_id(self, student_id: str) -> Optional[Student]:
        """
        Retrieves a student by their official (non-primary key) studentId.
        This is a global lookup, as student IDs are expected to be unique
        across the entire system.
        """
        return self.db.query(Student).filter(Student.studentId == student_id).first()

    def get_student_by_id(self, student_id: str, user_id: str) -> Optional[Student]:
        """
        Securely fetches a single student by their primary key ID, ensuring they
        belong to a class owned by the specified user.
        """
        from app.db.models.class_student_models import StudentClassMembership

        return (
            self.db.query(Student)
            .join(StudentClassMembership, Student.id == StudentClassMembership.student_id)
            .join(Class, StudentClassMembership.class_id == Class.id)
            .filter(Student.id == student_id, Class.user_id == user_id)
            .first()
        )

    # --- Chatbot Helper Methods ---

    def get_classes_for_chatbot(self, user_id: str) -> List[Dict]:
        """
        Returns a list of class dictionaries for the chatbot sandbox,
        securely filtered for the authenticated user.
        """
        user_classes = self.get_all_classes(user_id=user_id)
        return [{c.name: getattr(obj, c.name) for c in obj.__table__.columns} for obj in user_classes]

    def get_students_for_chatbot(self, user_id: str) -> List[Dict]:
        """
        Returns a list of student dictionaries for the chatbot sandbox,
        securely filtered for the authenticated user.
        """
        # This query joins students with their parent class to filter by the owner.
        from app.db.models.class_student_models import StudentClassMembership

        user_students = (
            self.db.query(Student)
            .join(StudentClassMembership, Student.id == StudentClassMembership.student_id)
            .join(Class, StudentClassMembership.class_id == Class.id)
            .filter(Class.user_id == user_id)
            .distinct()
            .all()
        )
        return [{c.name: getattr(obj, c.name) for c in obj.__table__.columns} for obj in user_students]

    # --- NEW: Student Membership Methods ---

    def get_class_memberships_for_student(self, student_id: str, user_id: str) -> List:
        """
        Returns all class memberships for a student, along with class details.
        Only returns classes owned by the specified user.
        """
        from app.db.models.class_student_models import StudentClassMembership

        memberships = (
            self.db.query(StudentClassMembership, Class)
            .join(Class, StudentClassMembership.class_id == Class.id)
            .filter(
                StudentClassMembership.student_id == student_id,
                Class.user_id == user_id
            )
            .all()
        )

        # Return list of objects with membership and class data
        result = []
        for membership, class_obj in memberships:
            result.append(type('obj', (object,), {
                'student_id': membership.student_id,
                'class_id': membership.class_id,
                'class_name': class_obj.name
            })())

        return result

    def add_student_to_class(self, student_id: str, class_id: str) -> bool:
        """
        Adds a student to a class via the membership table.
        Returns True if successful, False if already exists.
        """
        from app.db.models.class_student_models import StudentClassMembership
        import uuid

        # Check if membership already exists
        existing = (
            self.db.query(StudentClassMembership)
            .filter_by(student_id=student_id, class_id=class_id)
            .first()
        )

        if existing:
            return False

        # Create new membership
        membership = StudentClassMembership(
            id=f"scm_{uuid.uuid4().hex[:16]}",
            student_id=student_id,
            class_id=class_id
        )

        self.db.add(membership)
        self.db.commit()
        return True

    def remove_student_from_class(self, student_id: str, class_id: str) -> bool:
        """
        Removes a student from a class.
        Returns True if successful, False if not found.
        """
        from app.db.models.class_student_models import StudentClassMembership

        membership = (
            self.db.query(StudentClassMembership)
            .filter_by(student_id=student_id, class_id=class_id)
            .first()
        )

        if not membership:
            return False

        self.db.delete(membership)
        self.db.commit()
        return True

--- File: .\ata-backend\app\services\database_helpers\generation_repository_sql.py ---


    # /ata-backend/app/services/database_helpers/generation_repository_sql.py (MODIFIED AND APPROVED - FLAWLESS VERSION)

"""
This module contains all the raw SQLAlchemy queries for the Generation table, which
stores the history of AI tool usage. It is the direct interface to the database
for all history-related data and a final point of enforcement for data isolation.

Every method that reads or modifies a generation has been updated to require
a `user_id`, ensuring all operations are securely scoped to the authenticated
user. This module follows a "defense-in-depth" principle, meaning every
function is independently secure.
"""

from typing import List, Dict, Optional
from sqlalchemy.orm import Session

# Import the SQLAlchemy model this repository will interact with.
from app.db.models.generation_models import Generation


class GenerationRepositorySQL:
    def __init__(self, db_session: Session):
        self.db = db_session

    def add_generation_record(self, record: Dict) -> Generation:
        """
        Creates a new Generation record in the database from a dictionary.

        CONTRACT: This function expects the `user_id` to be present in the
        `record` dictionary, having been stamped by the calling service layer.
        """
        new_generation = Generation(**record)
        self.db.add(new_generation)
        self.db.commit()
        self.db.refresh(new_generation)
        return new_generation

    def get_all_generations(self, user_id: str) -> List[Generation]:
        """
        Retrieves all generation records owned by a specific user, ordered by most recent first.
        
        The query is now filtered by `user_id` to enforce strict data isolation
        and prevent one user from seeing another user's history.
        """
        return (
            self.db.query(Generation)
            .filter(Generation.user_id == user_id)
            .order_by(Generation.created_at.desc())
            .all()
        )

    def delete_generation_record(self, generation_id: str, user_id: str) -> bool:
        """
        Deletes a single generation record by its ID, but only if it is owned by the
        specified user.

        The query filters by both `generation_id` and `user_id` to create a secure,
        atomic check. This prevents a user from deleting another user's history
        even if they know the ID.
        """
        # Securely fetch the record to delete. This will only return a record if
        # the ID matches AND the user_id matches the owner.
        record_to_delete = (
            self.db.query(Generation)
            .filter(Generation.id == generation_id, Generation.user_id == user_id)
            .first()
        )

        if record_to_delete:
            self.db.delete(record_to_delete)
            self.db.commit()
            return True
        
        # If no record was found (either because the ID is wrong or the owner
        # doesn't match), do nothing and report failure.
        return False
    



--- File: .\ata-backend\app\services\database_helpers\__init__.py ---



--- File: .\ata-backend\Books\direcotory generator.py ---

#!/usr/bin/env python3
import os

# â”€â”€â”€ CONFIGURE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
skip_dirs = [
    "venv",
    ".pytest_cache",
    "node_modules",
    ".git"
    # add more folder names here to skip
]

output_file = "directory_map.txt"
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    root_dir = os.getcwd()
    base = os.path.basename(root_dir.rstrip(os.path.sep))
    entries = []

    with open(output_file, "w", encoding="utf-8") as f:
        # Print the root itself
        f.write(f"/{base}\n")

        for current_root, dirs, files in os.walk(root_dir):
            rel = os.path.relpath(current_root, root_dir)
            # build prefix like "/base" or "/base/sub/dir"
            if rel == ".":
                prefix = f"/{base}"
            else:
                prefix = f"/{base}/{rel.replace(os.path.sep, '/')}"
                # write this folderâ€™s path
                f.write(prefix + "/\n")

            # handle and prune skip_dirs
            for d in list(dirs):
                if d in skip_dirs:
                    skip_path = prefix + "/" + d + "/"
                    f.write(skip_path + " (too much files)\n")
                    dirs.remove(d)  # prevents os.walk from entering it

            # list files
            for filename in files:
                f.write(prefix + "/" + filename + "\n")

    print(f"Directory map written to {output_file}")

if __name__ == "__main__":
    main()


--- File: .\ata-backend\tests\test_analytics_and_matching.py ---

# /tests/test_analytics_and_matching.py (CORRECTED)

import pytest
from unittest.mock import MagicMock, AsyncMock, mock_open
import json
from types import SimpleNamespace

from app.services.assessment_helpers import analytics_and_matching
from app.models.assessment_model import AssessmentConfig, AssessmentConfigV2, QuestionConfig, SectionConfigV2

# --- Test Data Fixtures (Unchanged but confirmed correct) ---

@pytest.fixture
def mock_db_service():
    """Provides a mock of the DatabaseService for dependency injection."""
    return MagicMock()

@pytest.fixture
def v1_job_record():
    """Provides a mock database record (as an object) for a V1 assessment job."""
    v1_config = AssessmentConfig(
        assessmentName="V1 History Test", classId="cls_v1",
        questions=[
            QuestionConfig(id="q1", text="Who was the first president?", rubric="Name the person.", maxScore=10),
            QuestionConfig(id="q2", text="What year was the declaration signed?", rubric="Provide the year.", maxScore=10)
        ]
    )
    mock_record = MagicMock()
    mock_record.id = "job_v1_123"
    mock_record.status = "Completed"
    mock_record.config = v1_config.model_dump_json()
    return mock_record

@pytest.fixture
def mock_results_data():
    """Provides a list of mock result objects for analytics testing."""
    def create_mock_result(student_id, question_id, grade):
        mock = MagicMock()
        mock.student_id = student_id
        mock.question_id = question_id
        mock.grade = grade
        # Mock the SQLAlchemy __table__ attribute needed for the list comprehension
        mock.__table__ = MagicMock()
        mock.__table__.columns = [
            SimpleNamespace(name='student_id'),
            SimpleNamespace(name='question_id'),
            SimpleNamespace(name='grade')
        ]
        return mock

    return [
        create_mock_result('stu_1', 'q_1', 8),
        create_mock_result('stu_1', 'q_2', 10),
        create_mock_result('stu_2', 'q_1', 6),
        create_mock_result('stu_2', 'q_2', 7),
    ]

@pytest.fixture
def mock_v2_config_for_analytics():
    """Provides a valid V2 config object for analytics testing."""
    return AssessmentConfigV2.model_validate({
        "assessmentName": "Analytics Test", "classId": "cls_xyz", "scoringMethod": "per_question",
        "sections": [{"title": "Main Section", "questions": [
            {"id": "q_1", "text": "Q1", "rubric": "R1", "maxScore": 10},
            {"id": "q_2", "text": "Q2", "rubric": "R2", "maxScore": 10}
        ]}]
    })

# --- Unit Tests ---

def test_normalize_config_to_v2_from_v1_job(v1_job_record):
    """Tests that a V1 job config is correctly transformed into a V2 structure."""
    normalized_config = analytics_and_matching.normalize_config_to_v2(v1_job_record)
    assert isinstance(normalized_config, AssessmentConfigV2)
    assert len(normalized_config.sections) == 1
    assert normalized_config.sections[0].questions[0].text == "Who was the first president?"
    print("\nâœ… SUCCESS: test_normalize_config_to_v2_from_v1_job passed.")

def test_calculate_analytics_success(mock_results_data, mock_v2_config_for_analytics):
    """Tests that the analytics calculations are correct."""
    analytics = analytics_and_matching.calculate_analytics(mock_results_data, mock_v2_config_for_analytics)
    assert analytics["classAverage"] == 77.5
    assert analytics["performanceByQuestion"]["q_1"] == 70.0
    print("\nâœ… SUCCESS: test_calculate_analytics_success passed.")

# This test IS asynchronous, so we apply the marker directly to it.
@pytest.mark.asyncio
async def test_match_files_to_students(mocker, mock_db_service):
    """Tests that the file matching logic correctly calls the database on a match."""
    job_id = "job_match_test"
    user_id = "user_test_123"

    # --- FIX: Use a MagicMock object instead of a dict ---
    mock_job_record = MagicMock()
    mock_job_record.config = AssessmentConfig(assessmentName="Test", classId="cls_1", questions=[QuestionConfig(id='q1', text='t', rubric='r')]).model_dump_json()
    mock_job_record.answer_sheet_paths = json.dumps([{"path": "/path/to/alex_paper.pdf", "contentType": "application/pdf"}])

    # --- FIX: Use MagicMock objects for students ---
    mock_student = MagicMock()
    mock_student.id = "stu_alex_123"
    mock_student.name = "Alex Doe"
    mock_students = [mock_student]
    
    # Configure our mock database to return the test data
    mock_db_service.get_assessment_job.return_value = mock_job_record
    mock_db_service.get_students_by_class_id.return_value = mock_students
    
    # Mock the external OCR service
    mocker.patch('app.services.ocr_service.extract_text_from_file', return_value="some text containing the name alex doe here")

    mocker.patch("builtins.open", mock_open(read_data=b"fake file bytes"))

    await analytics_and_matching.match_files_to_students(mock_db_service, job_id, user_id)

    # Assert that the database was correctly updated after the match was found
    # --- FIX: Add the missing user_id to the assertion ---
    mock_db_service.update_student_result_path.assert_called_once_with(
        job_id, "stu_alex_123", "/path/to/alex_paper.pdf", "application/pdf", user_id
    )
    print("\nâœ… SUCCESS: test_match_files_to_students passed.")

--- File: .\ata-backend\tests\test_assessment_models.py ---

# /tests/test_assessment_models.py

import pytest
from pydantic import ValidationError

# Import the specific models we need to test from our application code
from app.models.assessment_model import AssessmentConfigV2, SectionConfigV2, QuestionConfigV2, ScoringMethod

# --- Test Data Fixtures ---
# Using pytest fixtures to provide clean, reusable test data.

@pytest.fixture
def valid_question_data_v2():
    """Provides a valid dictionary for a single V2 question."""
    return {
        "id": "q_test_001",
        "text": "What is the powerhouse of the cell?",
        "rubric": "Answer must mention mitochondria.",
        "maxScore": 10,
        "answer": "The mitochondria."
    }

@pytest.fixture
def valid_section_data_v2(valid_question_data_v2):
    """Provides a valid dictionary for a single V2 section containing one question."""
    return {
        "id": "sec_test_abc",
        "title": "Section A: Biology",
        "questions": [valid_question_data_v2]
    }

@pytest.fixture
def valid_assessment_config_data_v2(valid_section_data_v2):
    """Provides a complete, valid dictionary for a V2 assessment configuration."""
    return {
        "assessmentName": "Biology Midterm",
        "classId": "cls_12345",
        "scoringMethod": "per_question",
        "sections": [valid_section_data_v2],
        "includeImprovementTips": True
    }


# --- Unit Tests for AssessmentConfigV2 ---

def test_valid_assessment_config_v2_creation(valid_assessment_config_data_v2):
    """
    GIVEN: A dictionary with valid data for a V2 assessment.
    WHEN:  An AssessmentConfigV2 model is instantiated from this data.
    THEN:  The model is created successfully without raising a validation error,
           and all fields are correctly assigned.
    """
    # This is the "happy path" test.
    try:
        model = AssessmentConfigV2(**valid_assessment_config_data_v2)
        
        # Assert that all top-level fields are correct
        assert model.assessmentName == "Biology Midterm"
        assert model.scoringMethod == ScoringMethod.PER_QUESTION
        
        # Assert that the nested structures are also correct Pydantic models
        assert len(model.sections) == 1
        assert isinstance(model.sections[0], SectionConfigV2)
        assert model.sections[0].title == "Section A: Biology"
        
        assert len(model.sections[0].questions) == 1
        assert isinstance(model.sections[0].questions[0], QuestionConfigV2)
        assert model.sections[0].questions[0].text == "What is the powerhouse of the cell?"
        assert model.sections[0].questions[0].answer == "The mitochondria."

        print("\nâœ… SUCCESS: test_valid_assessment_config_v2_creation passed.")

    except ValidationError as e:
        pytest.fail(f"Valid data unexpectedly failed validation: {e}")


def test_assessment_config_v2_missing_required_fields(valid_assessment_config_data_v2):
    """
    GIVEN: A dictionary for a V2 assessment that is missing a required field ('assessmentName').
    WHEN:  An attempt is made to create an AssessmentConfigV2 model.
    THEN:  A Pydantic ValidationError is raised.
    """
    # This tests our validation rules.
    invalid_data = valid_assessment_config_data_v2.copy()
    del invalid_data["assessmentName"] # Remove a required field

    with pytest.raises(ValidationError) as excinfo:
        AssessmentConfigV2(**invalid_data)

    # We can inspect the error to be more specific if needed
    assert "assessmentName" in str(excinfo.value)
    
    print("\nâœ… SUCCESS: test_assessment_config_v2_missing_required_fields passed as expected.")


def test_assessment_config_v2_empty_sections_list(valid_assessment_config_data_v2):
    """
    GIVEN: A dictionary for a V2 assessment where the 'sections' list is empty.
    WHEN:  An attempt is made to create an AssessmentConfigV2 model.
    THEN:  A Pydantic ValidationError is raised because 'sections' must have at least one item.
    """
    # This tests our 'min_items=1' validator.
    invalid_data = valid_assessment_config_data_v2.copy()
    invalid_data["sections"] = [] # Make the list empty

    with pytest.raises(ValidationError) as excinfo:
        AssessmentConfigV2(**invalid_data)

    assert "List should have at least 1 item" in str(excinfo.value)
    
    print("\nâœ… SUCCESS: test_assessment_config_v2_empty_sections_list passed as expected.")

def test_assessment_config_v2_invalid_scoring_method(valid_assessment_config_data_v2):
    """
    GIVEN: A dictionary for a V2 assessment with an invalid string for 'scoringMethod'.
    WHEN:  An attempt is made to create an AssessmentConfigV2 model.
    THEN:  A Pydantic ValidationError is raised because the value is not a valid member of the Enum.
    """
    # This tests our ScoringMethod Enum.
    invalid_data = valid_assessment_config_data_v2.copy()
    invalid_data["scoringMethod"] = "by_magic" # Invalid value

    with pytest.raises(ValidationError) as excinfo:
        AssessmentConfigV2(**invalid_data)

    assert "Input should be 'per_question', 'per_section' or 'total_score'" in str(excinfo.value)

    print("\nâœ… SUCCESS: test_assessment_config_v2_invalid_scoring_method passed as expected.")

--- File: .\ata-backend\tests\test_assessment_review.py ---

import pytest
import json
import uuid
from typing import List, Optional
from decimal import Decimal
from unittest.mock import MagicMock, patch

from fastapi.testclient import TestClient
from app.main import app
from app.services.database_service import get_db_service
from app.services.assessment_service import finalize_question
from app.db.models.assessment_models import Result, Assessment, ResultStatus, FinalizedBy
from app.db.models.class_student_models import Student
from app.models.user_model import User
from app.core.deps import get_current_active_user
from app.models import assessment_model as am

# --- Unit Tests for Consensus Logic ---
@pytest.mark.parametrize("grades, comments, max_score, expected_status, expected_grade, expected_finalized_by", [
    ([8.0, 8.0, 8.0], ["Good", "Great", "Excellent"], 10.0, ResultStatus.AI_GRADED, 8.0, FinalizedBy.AI),
    ([8.0, 7.0, 8.0], ["Good", "Okay", "Great"], 10.0, ResultStatus.AI_GRADED, 8.0, FinalizedBy.AI),
    ([8.0, 7.0, 6.0], ["Good", "Okay", "Bad"], 10.0, ResultStatus.PENDING_REVIEW, None, None),
    ([8.5, 8.6, 8.55], ["Good", "Great", "Excellent"], 10.0, ResultStatus.AI_GRADED, 8.55, FinalizedBy.AI),
    ([8.5, 7.2, 8.55], ["Good", "Okay", "Great"], 10.0, ResultStatus.AI_GRADED, 8.525, FinalizedBy.AI),
    ([8.5, 7.2, 6.1], ["Good", "Okay", "Bad"], 10.0, ResultStatus.PENDING_REVIEW, None, None),
    ([9.0, 9.05, 5.0], ["A", "B", "C"], 10.0, ResultStatus.AI_GRADED, 9.025, FinalizedBy.AI),
    ([9.0, 9.2, 9.4], ["A", "B", "C"], 10.0, ResultStatus.PENDING_REVIEW, None, None),
    ([8.0, None, 8.0], ["Good", "N/A", "Great"], 10.0, ResultStatus.AI_GRADED, 8.0, FinalizedBy.AI),
    ([8.0, None, 7.0], ["Good", "N/A", "Okay"], 10.0, ResultStatus.PENDING_REVIEW, None, None),
    ([None, None, 8.0], ["N/A", "N/A", "Good"], 10.0, ResultStatus.PENDING_REVIEW, None, None),
    ([None, None, None], ["N/A", "N/A", "N/A"], 10.0, ResultStatus.PENDING_REVIEW, None, None),
])
def test_finalize_question(
    grades: List[Optional[float]],
    comments: List[Optional[str]],
    max_score: float,
    expected_status: ResultStatus,
    expected_grade: Optional[float],
    expected_finalized_by: Optional[FinalizedBy]
):
    # Convert to Decimal for precision
    decimal_grades = [Decimal(str(g)) if g is not None else None for g in grades]
    result = finalize_question(decimal_grades, comments, max_score)
    assert result["status"] == expected_status
    if expected_grade is not None:
        assert result["grade"] is not None
        assert abs(Decimal(str(result["grade"])) - Decimal(str(expected_grade))) < Decimal("0.01")
    else:
        assert result["grade"] is None
    assert result["finalized_by"] == expected_finalized_by

# --- Integration Tests for API Endpoints (Refactored) ---

test_user_id = uuid.uuid4()
mock_user = User(id=test_user_id, email="test@example.com", hashed_password="password", is_active=True, is_superuser=False)
mock_db_service = MagicMock()

def override_get_current_active_user():
    return mock_user

def override_get_db_service():
    return mock_db_service

app.dependency_overrides[get_current_active_user] = override_get_current_active_user
app.dependency_overrides[get_db_service] = override_get_db_service

client = TestClient(app)

@pytest.fixture(autouse=True)
def reset_mocks():
    mock_db_service.reset_mock()

# --- Mock Data Factory ---
def create_mock_job(job_id, user_id):
    mock_job = MagicMock()
    mock_job.id = job_id
    mock_job.user_id = user_id
    mock_job.status = am.JobStatus.PENDING_REVIEW.value
    mock_job.ai_summary = "This is a mock AI summary."
    mock_job.config = {
        "assessmentName": "Test Assessment",
        "classId": "c1",
        "scoringMethod": "per_question",
        "totalScore": 100,
        "sections": [{
            "id": "sec1", "title": "Section 1", "total_score": 20,
            "questions": [{
                "id": "q1", "text": "Q1", "maxScore": 10, "rubric": "R1", "answer": "A1"
            }, {
                "id": "q2", "text": "Q2", "maxScore": 10, "rubric": "R2", "answer": "A2"
            }]
        }]
    }
    return mock_job

def create_mock_student(student_id, name):
    mock_student = MagicMock()
    mock_student.id = student_id
    mock_student.name = name
    return mock_student

def create_mock_result(job_id, student_id, question_id, status, grade, extracted_answer=""):
    mock_result = MagicMock()
    mock_result.job_id = job_id
    mock_result.student_id = student_id
    mock_result.question_id = question_id
    mock_result.status = status
    mock_result.grade = grade
    mock_result.extractedAnswer = extracted_answer
    mock_result.feedback = "This is mock feedback."
    return mock_result

# --- Refactored Tests ---

@patch('app.services.assessment_service.analytics_and_matching.normalize_config_to_v2')
def test_get_assessment_results_overview_success(mock_normalize):
    job_id = "test-job-1"
    user_id = str(test_user_id)

    mock_job = create_mock_job(job_id, user_id)
    mock_config = am.AssessmentConfigV2.model_validate(mock_job.config)
    mock_normalize.return_value = mock_config

    mock_db_service.get_assessment_job.return_value = mock_job
    mock_db_service.get_students_by_class_id.return_value = [
        create_mock_student("s1", "Alice"),
        create_mock_student("s2", "Bob")
    ]
    mock_db_service.get_all_results_for_job.return_value = [
        create_mock_result(job_id, "s1", "q1", ResultStatus.AI_GRADED, 8.0),
        create_mock_result(job_id, "s1", "q2", ResultStatus.TEACHER_GRADED, 9.0),
        create_mock_result(job_id, "s2", "q1", ResultStatus.AI_GRADED, 7.0),
        create_mock_result(job_id, "s2", "q2", ResultStatus.PENDING_REVIEW, None),
    ]
    # This mock is needed to satisfy the pydantic model for the response
    mock_db_service.get_student_result_path.return_value = "/fake/path.pdf"

    response = client.get(f"/api/assessments/{job_id}/results")

    assert response.status_code == 200
    data = response.json()
    assert data['jobId'] == job_id
    assert len(data['results']['s1']) == 2
    assert data['results']['s1']['q1']['grade'] == 8.0

def test_get_assessment_results_overview_not_found():
    job_id = "non-existent-job"
    mock_db_service.get_assessment_job.return_value = None

    response = client.get(f"/api/assessments/{job_id}/results")

    assert response.status_code == 404
    # Correct the expected error message to match the API
    assert response.json() == {"detail": f"Job {job_id} not found or access denied."}

@patch('app.services.assessment_service.analytics_and_matching.normalize_config_to_v2')
def test_get_student_assessment_for_review_success(mock_normalize):
    job_id = "test-job-1"
    student_id = "s1"
    user_id = str(test_user_id)

    mock_job = create_mock_job(job_id, user_id)
    mock_config = am.AssessmentConfigV2.model_validate(mock_job.config)
    mock_normalize.return_value = mock_config

    mock_db_service.get_assessment_job.return_value = mock_job
    # FIX: The service uses get_student_by_id, not get_student_by_student_id
    mock_db_service.get_student_by_id.return_value = create_mock_student(student_id, "Alice")
    mock_db_service.get_outsider_student_by_id.return_value = None
    mock_db_service.get_all_results_for_job.return_value = [
        create_mock_result(job_id, student_id, "q1", ResultStatus.AI_GRADED, 8.5, "This is the student answer."),
        create_mock_result(job_id, student_id, "q2", ResultStatus.PENDING_REVIEW, None, "Another answer."),
    ]

    # The entity_id in the URL should be the student's database ID
    response = client.get(f"/api/assessments/{job_id}/students/{student_id}/review")

    assert response.status_code == 200
    data = response.json()
    assert data['student_name'] == "Alice"
    assert len(data['per_question']) == 2
    q1_data = next(q for q in data['per_question'] if q['question_id'] == 'q1')
    assert q1_data['student_answer'] == "This is the student answer."

@patch('app.services.assessment_service.analytics_and_matching.normalize_config_to_v2')
def test_save_teacher_review_success(mock_normalize):
    job_id = "test-job-1"
    student_id = "s2"
    user_id = str(test_user_id)
    # FIX: The payload should be a single object, not a list
    review_payload = {"question_id": "q2", "grade": 9.0, "feedback": "Excellent work!"}

    mock_job = create_mock_job(job_id, user_id)
    mock_normalize.return_value = am.AssessmentConfigV2.model_validate(mock_job.config)

    mock_db_service.get_assessment_job.return_value = mock_job
    # Add mocks for the get_student_by_id and get_outsider_student_by_id calls
    mock_db_service.get_student_by_id.return_value = create_mock_student(student_id, "Test Student")
    mock_db_service.get_outsider_student_by_id.return_value = None

    # Mock the results for score recalculation
    mock_db_service.get_all_results_for_job.return_value = [
        create_mock_result(job_id, student_id, "q1", ResultStatus.AI_GRADED, 7.0),
        create_mock_result(job_id, student_id, "q2", ResultStatus.TEACHER_GRADED, 9.0),
    ]

    # FIX: The endpoint is a PATCH, not a POST, and the URL has changed
    response = client.patch(f"/api/assessments/{job_id}/students/{student_id}/review", json=review_payload)

    assert response.status_code == 200
    assert response.json()['totalScore'] == 16.0

    # FIX: The service now calls update_student_result_with_grade
    mock_db_service.update_student_result_with_grade.assert_called_once_with(
        job_id=job_id,
        student_id=student_id,
        question_id="q2",
        grade=9.0,
        feedback="Excellent work!",
        status=ResultStatus.TEACHER_GRADED.value,
        finalized_by=FinalizedBy.TEACHER.value,
        user_id=str(test_user_id)
    )

--- File: .\ata-backend\tests\test_assessment_service.py ---

# /tests/test_assessment_service.py (CORRECTED, WARNING-FREE)

import pytest
from unittest.mock import MagicMock, AsyncMock
import json

# We are no longer using the global pytestmark
# pytestmark = pytest.mark.asyncio 

from app.services.assessment_service import AssessmentService
from app.models.assessment_model import AssessmentConfigV2, SectionConfigV2, QuestionConfigV2, ScoringMethod
from app.services import prompt_library

# --- Test Data Fixtures (Unchanged) ---

@pytest.fixture
def mock_db_service():
    return MagicMock()

@pytest.fixture
def mock_gemini_service(mocker):
    mock = MagicMock()
    mock_json_response = json.dumps({"results": [{"question_id": "q_test_001", "grade": 9, "feedback": "Excellent work."}]})
    mock.generate_multimodal_response = AsyncMock(return_value=mock_json_response)
    return mocker.patch('app.services.assessment_service.gemini_service', mock)

@pytest.fixture
def mock_library_service(mocker):
    mock = MagicMock()
    mock.get_chapter_content = MagicMock(return_value="This is the text from Biology Chapter 1 about cells.")
    return mocker.patch('app.services.assessment_service.library_service', mock)

@pytest.fixture
def v2_config_for_library_test():
    return AssessmentConfigV2(
        assessmentName="Biology Midterm", classId="cls_123",
        scoringMethod=ScoringMethod.PER_QUESTION, gradingMode="library",
        librarySource="biology/chapter1.txt",
        sections=[
            SectionConfigV2(
                questions=[
                    QuestionConfigV2(
                        id="q_test_001", text="What is the powerhouse of the cell?",
                        rubric="Answer must mention mitochondria.", maxScore=10
                    )
                ]
            )
        ]
    )

# --- The Integration Test ---

# --- [THE FIX IS HERE] ---
# Apply the asyncio mark directly to the test function that needs it.
@pytest.mark.asyncio
async def test_grade_submission_with_library_source(
    mock_db_service, 
    mock_gemini_service,
    mock_library_service,
    v2_config_for_library_test,
    mocker
):
# --- [END OF FIX] ---
    """
    GIVEN a V2 assessment configured to grade using a library source
    WHEN the _grade_entire_submission_for_student method is called
    THEN it should call the library service and inject the result into the AI prompt.
    """
    # 1. SETUP
    grading_pipeline_mock = MagicMock()
    grading_pipeline_mock._prepare_images_from_answersheet.return_value = [MagicMock()]
    grading_pipeline_mock._invoke_grading_ai = mock_gemini_service.generate_multimodal_response
    parsed_response_data = {"results": [{"question_id": "q_test_001", "grade": 9, "feedback": "Excellent work."}]}
    grading_pipeline_mock._parse_ai_grading_response.return_value = parsed_response_data
    grading_pipeline_mock._save_grading_results_to_db = MagicMock()
    mocker.patch('app.services.assessment_service.grading_pipeline', grading_pipeline_mock)
    assessment_svc = AssessmentService(db=mock_db_service)

    # 2. EXECUTION
    await assessment_svc._grade_entire_submission_for_entity(
        job_id="job_test_123", entity_id="stu_test_456", is_outsider=False,
        answer_sheet_path="/fake/path.pdf", content_type="application/pdf",
        config=v2_config_for_library_test, user_id="user_test_123"
    )

    # 3. ASSERTION
    mock_library_service.get_chapter_content.assert_called_once_with("biology/chapter1.txt")
    print("\nâœ… SUCCESS: Library service was correctly called.")
    mock_gemini_service.generate_multimodal_response.assert_called_once()
    print("âœ… SUCCESS: Gemini service was called.")
    call_args, _ = mock_gemini_service.generate_multimodal_response.call_args
    final_prompt = call_args[0]
    assert "This is the text from Biology Chapter 1 about cells." in final_prompt
    print("âœ… SUCCESS: Prompt correctly contained the library text.")
    grading_pipeline_mock._save_grading_results_to_db.assert_called_once()
    print("âœ… SUCCESS: Database save function was correctly called.")

# --- [NEW TEST FOR PROMPT VALIDATION] ---
# --- [THE FIX IS HERE] ---
# This function is synchronous, so it no longer has the unnecessary asyncio mark.
def test_student_centric_grading_prompt_formats_correctly(v2_config_for_library_test):
# --- [END OF FIX] ---
    """
    GIVEN a valid V2 assessment configuration
    WHEN the STUDENT_CENTRIC_GRADING_PROMPT is formatted with its data
    THEN the resulting prompt string should be correctly structured.
    """

    # 1. SETUP
    config = v2_config_for_library_test
    answer_key_context = "This is the provided answer key context from the library."
    all_questions = [q for section in config.sections for q in section.questions]
    questions_json_str = json.dumps([q.model_dump() for q in all_questions], indent=2)

    # 2. EXECUTION
    final_prompt = prompt_library.STUDENT_CENTRIC_GRADING_PROMPT.format(
        answer_key_context=answer_key_context,
        questions_json=questions_json_str
    )

    # 3. ASSERTION
    assert "You are a highly experienced and objective Teaching Assistant." in final_prompt
    print("\nâœ… SUCCESS: Prompt contains the correct persona instruction.")
    assert "This is the provided answer key context from the library." in final_prompt
    print("âœ… SUCCESS: Prompt correctly injected the answer key context.")
    assert '"id": "q_test_001"' in final_prompt
    assert '"text": "What is the powerhouse of the cell?"' in final_prompt
    print("âœ… SUCCESS: Prompt correctly injected the formatted questions JSON.")
    assert "Generate the JSON output now." in final_prompt
    print("âœ… SUCCESS: Prompt contains the correct final instruction.")

--- File: .\ata-backend\tests\test_database_service.py ---

# /tests/test_database_service.py (CORRECTED FOR SQLALCHEMY)

import pytest
from unittest.mock import MagicMock

# We import the CLASS itself, not the shared singleton instance.
from app.services.database_service import DatabaseService
from app.db.models.class_student_models import Class

@pytest.fixture
def mock_db_session():
    """Provides a mock SQLAlchemy session."""
    return MagicMock()

@pytest.fixture
def db_service(mock_db_session):
    """
    Creates a DatabaseService instance with a mocked session, which is the
    correct way to test the service layer in isolation from a real database.
    """
    return DatabaseService(db_session=mock_db_session)


def test_add_and_get_class(db_service, mock_db_session):
    """
    Tests that a class can be added and then retrieved successfully.
    """
    user_id = "user_test_123"
    class_id = "cls_test_123"
    class_data = {"id": class_id, "name": "Test History Class", "description": "A class for testing.", "user_id": user_id}

    # 1. Configure the mock session to return a mock Class instance when queried
    mock_class_instance = Class(**class_data)
    mock_db_session.query.return_value.filter.return_value.first.return_value = mock_class_instance

    # 2. Call the service method to add the class
    db_service.add_class(class_data)

    # 3. Call the service method to get the class
    retrieved_class = db_service.get_class_by_id(class_id, user_id=user_id)

    # 4. Assert that the underlying ORM methods were called correctly
    mock_db_session.add.assert_called_once()
    mock_db_session.commit.assert_called_once()
    mock_db_session.refresh.assert_called_once()

    # 5. Assert that the retrieved class is the one we configured the mock to return
    assert retrieved_class is not None
    assert retrieved_class.name == "Test History Class"
    assert retrieved_class.id == class_id

def test_get_non_existent_class(db_service, mock_db_session):
    """Tests that getting a non-existent class returns None."""
    # Configure the mock session to return None, simulating a not-found scenario
    mock_db_session.query.return_value.filter.return_value.first.return_value = None

    retrieved_class = db_service.get_class_by_id("cls_no_exist", user_id="user_test_123")
    assert retrieved_class is None

def test_get_all_classes(db_service, mock_db_session):
    """
    Tests that get_all_classes correctly returns a list of classes.
    """
    user_id = "user_test_456"
    class1_data = {"id": "cls_1", "name": "Class 1", "description": "Desc 1", "user_id": user_id}
    class2_data = {"id": "cls_2", "name": "Class 2", "description": "Desc 2", "user_id": user_id}

    mock_class1 = Class(**class1_data)
    mock_class2 = Class(**class2_data)

    # Configure the mock session to return a list of mock objects
    mock_db_session.query.return_value.filter.return_value.all.return_value = [mock_class1, mock_class2]

    # Act
    all_classes = db_service.get_all_classes(user_id=user_id)

    # Assert
    assert isinstance(all_classes, list)
    assert len(all_classes) == 2
    assert all_classes[0].name == 'Class 1'
    assert all_classes[1].name == 'Class 2'

--- File: .\ata-backend\tests\test_data_assembly.py ---

# /tests/test_assessment_helpers/test_data_assembly.py

import pytest
import json
from datetime import datetime
from unittest.mock import MagicMock

# Import the specialist functions we want to test
from app.services.assessment_helpers.data_assembly import _assemble_job_summaries, _build_results_dictionary
from app.models.assessment_model import QuestionConfig

# --- Test Data Fixtures ---

@pytest.fixture
def mock_all_jobs():
    """Provides a list of mock job objects, as if from the database."""
    def create_mock_job(id, config_dict, status, created_at_iso):
        mock = MagicMock()
        mock.id = id
        mock.config = json.dumps(config_dict)
        mock.status = status
        # FIX: Convert ISO string to a real datetime object
        mock.created_at = datetime.fromisoformat(created_at_iso.replace('Z', '+00:00'))
        # This is needed for the `r.__dict__` call in the code under test
        mock.__dict__ = {'id': mock.id, 'config': mock.config, 'status': mock.status, 'created_at': mock.created_at}
        return mock

    v1_config = {
        "assessmentName": "History Quiz",
        "classId": "cls_101",
        "questions": [{"id": "q_1", "text": "Q1", "rubric": "R1", "maxScore": 10}],
        "includeImprovementTips": False
    }
    return [
        create_mock_job("job_1", v1_config, "Completed", "2025-01-01T12:00:00Z"),
    ]

@pytest.fixture
def mock_all_results():
    """Provides a list of mock result objects, as if from the database."""
    def create_mock_result(job_id, student_id, question_id, grade, status):
        mock = MagicMock()
        mock.job_id = job_id
        mock.student_id = student_id
        mock.question_id = question_id
        mock.grade = grade
        mock.status = status
        # This is needed for the `r.__dict__` call in the code under test
        mock.__dict__ = {'job_id': mock.job_id, 'student_id': mock.student_id, 'question_id': mock.question_id, 'grade': mock.grade, 'status': mock.status}
        return mock

    return [
        create_mock_result("job_1", "stu_A", "q_1", 9.5, "ai_graded"),
        create_mock_result("job_1", "stu_B", "q_1", None, "pending"),
        create_mock_result("job_1", "stu_C", "q_1", 7.0, "edited_by_teacher"),
        create_mock_result("job_2", "stu_D", "q_x", 10.0, "ai_graded"),
    ]

@pytest.fixture
def mock_all_classes():
    """Provides a mock dictionary of class IDs to names."""
    return {
        "cls_101": "10th Grade History",
        "cls_102": "11th Grade Physics"
    }

@pytest.fixture
def mock_class_students():
    """Provides a mock list of student objects for a specific class."""
    def create_mock_student(id, name):
        mock = MagicMock()
        mock.id = id
        mock.name = name
        return mock

    return [
        create_mock_student("stu_A", "Alice"),
        create_mock_student("stu_B", "Bob"),
        create_mock_student("stu_C", "Charlie"),
    ]

@pytest.fixture
def mock_questions_config():
    """Provides a mock list of QuestionConfig objects."""
    return [
        QuestionConfig(id="q_1", text="Q1", rubric="R1", maxScore=10),
        QuestionConfig(id="q_2", text="Q2", rubric="R2", maxScore=15), # A question with no results yet
    ]


# --- Unit Tests for Data Assembly Specialists ---

def test_assemble_job_summaries(mock_all_jobs, mock_all_results, mock_all_classes):
    """
    GIVEN: Raw lists of jobs, results, and classes.
    WHEN:  _assemble_job_summaries is called.
    THEN:  It should return a correctly formatted list of summaries with accurate progress.
    """
    # Call the function under test
    summaries = _assemble_job_summaries(mock_all_jobs, mock_all_results, mock_all_classes)

    # Assertions
    assert isinstance(summaries, list)
    assert len(summaries) == 1  # It should only process the one job in our fixture

    summary = summaries[0]
    assert summary['id'] == "job_1"
    assert summary['assessmentName'] == "History Quiz"
    assert summary['className'] == "10th Grade History"
    assert summary['status'] == "Completed"
    
    # CRITICAL: Test the progress calculation
    # 3 unique students (A, B, C) are associated with job_1
    assert summary['progress']['total'] == 3
    # 2 students (A, C) have a non-pending status ('ai_graded', 'edited_by_teacher')
    assert summary['progress']['processed'] == 2
    
    print("\nâœ… SUCCESS: test_assemble_job_summaries passed.")


def test_build_results_dictionary(mock_class_students, mock_questions_config, mock_all_results):
    """
    GIVEN: Raw lists of students, questions, and results for a single job.
    WHEN:  _build_results_dictionary is called.
    THEN:  It should return a correctly nested dictionary with all students and questions.
    """
    # Filter results for just job_1 for this test
    # FIX: Use attribute access (r.job_id) instead of dictionary access (r['job_id'])
    job_1_results = [r for r in mock_all_results if r.job_id == 'job_1']

    # Call the function under test
    results_dict = _build_results_dictionary(mock_class_students, mock_questions_config, job_1_results)

    # Assertions
    assert isinstance(results_dict, dict)
    
    # Check that all students are present as keys
    assert "stu_A" in results_dict
    assert "stu_B" in results_dict
    assert "stu_C" in results_dict
    
    # Check a student with a result (Alice)
    alice_results = results_dict['stu_A']
    assert "q_1" in alice_results
    assert "q_2" in alice_results # Even questions with no result should be present
    assert alice_results['q_1']['grade'] == 9.5 # Check safe_float_convert
    assert alice_results['q_1']['status'] == 'ai_graded'
    assert alice_results['q_2']['grade'] is None # Check handling of missing results
    
    # Check a student with a pending result (Bob)
    bob_results = results_dict['stu_B']
    assert bob_results['q_1']['grade'] is None # Correctly handles None grade
    assert bob_results['q_1']['status'] == 'pending'
    
    print("\nâœ… SUCCESS: test_build_results_dictionary passed.")

--- File: .\ata-backend\tests\test_document_parser.py ---

# /tests/test_document_parser.py (WITH DIAGNOSTIC PRINT)

import pytest
import json
from unittest.mock import MagicMock, AsyncMock
from fastapi import UploadFile

pytestmark = pytest.mark.asyncio

from app.services.assessment_helpers.document_parser import parse_document_to_config
from app.models.assessment_model import AssessmentConfigV2
# Import the entire prompt_library module so we can inspect it
from app.services import prompt_library


@pytest.fixture
def mock_upload_file():
    mock = MagicMock(spec=UploadFile)
    mock.read = AsyncMock(return_value=b"fake pdf content")
    mock.content_type = "application/pdf"
    mock.filename = "test_document.pdf"
    return mock

@pytest.fixture
def mock_ai_response():
    return json.dumps({
      "scoringMethod": "per_question",
      "totalScore": None,
      "sections": [
        {
          "title": "Section A: Biology",
          "total_score": None,
          "questions": [
            {
              "id": "q_test_001",
              "text": "What is the powerhouse of the cell?",
              "rubric": "Answer must mention mitochondria.",
              "maxScore": 10,
              "answer": "The mitochondria."
            }
          ]
        }
      ],
      "includeImprovementTips": False
    })


async def test_parse_document_to_config_success(mocker, mock_upload_file, mock_ai_response):
    """
    GIVEN: A mock uploaded file.
    WHEN:  The parse_document_to_config function is called.
    AND:   The OCR and Gemini services are mocked.
    THEN:  The function should return a correctly structured dictionary.
    """
    # --- [DIAGNOSTIC STEP] ---
    # We will print the contents of the imported prompt string to see what the
    # test runner is actually loading at runtime.
    print("\n--- DIAGNOSTIC: Inspecting DOCUMENT_PARSING_PROMPT at runtime ---")
    print(prompt_library.DOCUMENT_PARSING_PROMPT)
    print("--- END DIAGNOSTIC ---")
    # --- [END DIAGNOSTIC STEP] ---
    
    mocker.patch('app.services.ocr_service.extract_text_from_file', return_value="Mock OCR text about mitochondria.")
    mocker.patch('app.services.gemini_service.generate_multimodal_response', new_callable=AsyncMock, return_value=mock_ai_response)
    
    mock_pdf_page = MagicMock()
    mock_pdf_page.get_pixmap.return_value.tobytes.return_value = b"fake_png_bytes"
    mock_pdf_doc = MagicMock()
    mock_pdf_doc.__iter__.return_value = [mock_pdf_page]
    mocker.patch('fitz.open', return_value=mock_pdf_doc)
    mocker.patch('PIL.Image.open', return_value=MagicMock())

    class_id = "cls_test_123"
    assessment_name = "Test Biology Midterm"
    
    result_dict = await parse_document_to_config(mock_upload_file, None, class_id, assessment_name)

    assert isinstance(result_dict, dict)
    assert result_dict['assessmentName'] == assessment_name
    assert result_dict['classId'] == class_id
    assert result_dict['scoringMethod'] == 'per_question'

    print("\nâœ… SUCCESS: test_parse_document_to_config_success passed.")

--- File: .\ata-backend\tests\test_job_creation_helper.py ---

# /tests/test_job_creation_helper.py

import pytest
from unittest.mock import MagicMock, call

# Import the specialist functions we want to test
from app.services.assessment_helpers import job_creation

# Import the Pydantic models needed to create test data
from app.models.assessment_model import AssessmentConfig, AssessmentConfigV2, QuestionConfig, SectionConfigV2, QuestionConfigV2, ScoringMethod

# --- Test Data Fixtures ---

@pytest.fixture
def mock_db_service():
    """Mocks the DatabaseService to isolate our test from the real CSV files."""
    db = MagicMock()
    # When get_students_by_class_id is called, return a predefined list
    db.get_students_by_class_id.return_value = [
        {'id': 'stu_001', 'name': 'Student One'},
        {'id': 'stu_002', 'name': 'Student Two'},
        {'id': 'stu_003', 'name': 'Student Three'},
    ]
    return db

@pytest.fixture
def mock_db_service_v2():
    """A separate mock for the V2 test with a different number of students."""
    db = MagicMock()
    db.get_students_by_class_id.return_value = [
        {'id': 'stu_101', 'name': 'Student A'},
        {'id': 'stu_102', 'name': 'Student B'},
        {'id': 'stu_103', 'name': 'Student C'},
        {'id': 'stu_104', 'name': 'Student D'},
    ]
    return db

@pytest.fixture
def v1_config():
    """Creates a valid V1 AssessmentConfig object for testing."""
    return AssessmentConfig(
        assessmentName="V1 Test",
        classId="cls_v1",
        questions=[
            QuestionConfig(text="Q1", rubric="R1"),
            QuestionConfig(text="Q2", rubric="R2"),
        ]
    )

@pytest.fixture
def v2_config():
    """Creates a valid V2 AssessmentConfigV2 object for testing."""
    return AssessmentConfigV2(
        assessmentName="V2 Test",
        classId="cls_v2",
        scoringMethod=ScoringMethod.PER_QUESTION,
        sections=[
            SectionConfigV2(title="Section 1", questions=[
                QuestionConfigV2(text="Q1", rubric="R1", maxScore=10)
            ]),
            SectionConfigV2(title="Section 2", questions=[
                QuestionConfigV2(text="Q2", rubric="R2", maxScore=15),
                QuestionConfigV2(text="Q3", rubric="R3", maxScore=5),
            ])
        ]
    )

# --- Unit Tests ---

def test_create_initial_job_records_v1(mock_db_service, v1_config):
    """
    GIVEN: A V1 assessment config with 2 questions and a mock DB with 3 students.
    WHEN:  The _create_initial_job_records (V1) specialist is called.
    THEN:  It should create exactly 1 job record and 6 result records (3 students * 2 questions).
    """
    job_id = "job_v1_test"
    user_id = "user_v1_test"
    answer_sheet_data = [{"path": "/fake/path.pdf", "contentType": "application/pdf"}]

    # Call the function we are testing
    job_creation._create_initial_job_records(mock_db_service, job_id, v1_config, answer_sheet_data, user_id)

    # Assert that the main job was created exactly once
    mock_db_service.add_assessment_job.assert_called_once()
    
    # Assert that the result record creation was called the correct number of times
    # 3 students * 2 questions = 6 calls
    assert mock_db_service.save_student_grade_result.call_count == 6
    
    # Optional: A more specific check on one of the calls
    first_call_args = mock_db_service.save_student_grade_result.call_args_list[0]
    assert first_call_args[0][0]['student_id'] == 'stu_001'
    assert first_call_args[0][0]['status'] == 'pending_match'
    
    print("\nâœ… SUCCESS: test_create_initial_job_records_v1 passed.")

def test_create_initial_job_records_v2(mock_db_service_v2, v2_config):
    """
    GIVEN: A V2 assessment config with 3 total questions and a mock DB with 4 students.
    WHEN:  The _create_initial_job_records_v2 (V2) specialist is called.
    THEN:  It should create exactly 1 job record and 12 result records (4 students * 3 questions).
    """
    job_id = "job_v2_test"
    user_id = "user_v2_test"
    answer_sheet_data = [{"path": "/fake/path.docx", "contentType": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"}]

    # Call the function we are testing
    job_creation._create_initial_job_records_v2(mock_db_service_v2, job_id, v2_config, answer_sheet_data, user_id)

    # Assert that the main job was created exactly once
    mock_db_service_v2.add_assessment_job.assert_called_once()
    
    # Assert that the result record creation was called the correct number of times
    # 4 students * 3 questions = 12 calls
    assert mock_db_service_v2.save_student_grade_result.call_count == 12
    
    # Optional: A more specific check on one of the calls to ensure the nested loop is working
    last_call_args = mock_db_service_v2.save_student_grade_result.call_args_list[-1]
    assert last_call_args[0][0]['student_id'] == 'stu_104'
    assert last_call_args[0][0]['question_id'] == v2_config.sections[1].questions[1].id
    
    print("\nâœ… SUCCESS: test_create_initial_job_records_v2 passed.")

--- File: .\ata-backend\tests\test_ocr(i added manually).py ---

# /tests/test_ocr_service_standalone.py

import time
import os
import sys

# --- [CRITICAL SETUP] ---
# This is a standalone script, not a pytest test. To allow it to import
# modules from our main application (like 'app.services.ocr_service'),
# we need to temporarily add the project's root directory to the Python path.
# This mimics how the main application's environment is set up.
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)
# --- [END OF SETUP] ---

# Now we can import our application's service directly.
from app.services import ocr_service

# --- Configuration ---
IMAGE_PATH = "a.pdf"
# We must provide the correct MIME type, just like FastAPI would.
CONTENT_TYPE = "application/pdf"

def run_ocr_service_test(image_path: str, content_type: str):
    """
    Performs a standalone test of our application's ocr_service module
    on a single image file and reports the results.
    """
    print("--- Starting Standalone OCR Service Test ---")
    
    # 1. Verify that the image file exists.
    if not os.path.exists(image_path):
        print(f"\n[ERROR] Test image not found at path: '{image_path}'")
        print("Please make sure 'test_image.png' is inside the '/tests/' directory.")
        return

    print(f"Found test image: '{image_path}'")
    
    try:
        # 2. Read the file into in-memory bytes, mimicking an UploadFile.
        print("Reading image file into memory...")
        with open(image_path, "rb") as f:
            file_bytes = f.read()

        # 3. Record the start time.
        start_time = time.time()
        
        # 4. Call our application's service function.
        # This is the core test.
        print(f"Calling ocr_service.extract_text_from_file with content_type='{content_type}'...")
        extracted_text = ocr_service.extract_text_from_file(file_bytes, content_type)
        
        # 5. Record the end time and calculate the duration.
        end_time = time.time()
        duration = end_time - start_time
        
        # 6. Print the results.
        print("\n--- OCR Service Test Complete ---")
        print(f"Total time taken: {duration:.2f} seconds")
        print("\n--- Extracted Text ---")
        
        if extracted_text.strip():
            print(extracted_text)
        else:
            print("[No text was extracted from the image.]")
            
        print("--- End of Text ---")

    except ImportError as e:
        print(f"\n[IMPORT ERROR] A required library is missing: {e}")
        print("Please ensure all dependencies from requirements.txt are installed in your venv.")
    except Exception as e:
        # This will catch the ValueError from our service if the file type is unsupported.
        print(f"\n[UNEXPECTED ERROR] An error occurred during the service call: {e}")


if __name__ == "__main__":
    run_ocr_service_test(IMAGE_PATH, CONTENT_TYPE)

--- File: .\ata-backend\tests\test_ocr_performance.py ---

# /tests/test_ocr_service_standalone.py

import time
import os
import sys

# --- [CRITICAL SETUP] ---
# This is a standalone script, not a pytest test. To allow it to import
# modules from our main application (like 'app.services.ocr_service'),
# we need to temporarily add the project's root directory to the Python path.
# This mimics how the main application's environment is set up.
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)
# --- [END OF SETUP] ---

# Now we can import our application's service directly.
from app.services import ocr_service

# --- Configuration ---
IMAGE_PATH = os.path.join("tests", "test_image.png")
# We must provide the correct MIME type, just like FastAPI would.
CONTENT_TYPE = "image/png" 

def run_ocr_service_test(image_path: str, content_type: str):
    """
    Performs a standalone test of our application's ocr_service module
    on a single image file and reports the results.
    """
    print("--- Starting Standalone OCR Service Test ---")
    
    # 1. Verify that the image file exists.
    if not os.path.exists(image_path):
        print(f"\n[ERROR] Test image not found at path: '{image_path}'")
        print("Please make sure 'test_image.png' is inside the '/tests/' directory.")
        return

    print(f"Found test image: '{image_path}'")
    
    try:
        # 2. Read the file into in-memory bytes, mimicking an UploadFile.
        print("Reading image file into memory...")
        with open(image_path, "rb") as f:
            file_bytes = f.read()

        # 3. Record the start time.
        start_time = time.time()
        
        # 4. Call our application's service function.
        # This is the core test.
        print(f"Calling ocr_service.extract_text_from_file with content_type='{content_type}'...")
        extracted_text = ocr_service.extract_text_from_file(file_bytes, content_type)
        
        # 5. Record the end time and calculate the duration.
        end_time = time.time()
        duration = end_time - start_time
        
        # 6. Print the results.
        print("\n--- OCR Service Test Complete ---")
        print(f"Total time taken: {duration:.2f} seconds")
        print("\n--- Extracted Text ---")
        
        if extracted_text.strip():
            print(extracted_text)
        else:
            print("[No text was extracted from the image.]")
            
        print("--- End of Text ---")

    except ImportError as e:
        print(f"\n[IMPORT ERROR] A required library is missing: {e}")
        print("Please ensure all dependencies from requirements.txt are installed in your venv.")
    except Exception as e:
        # This will catch the ValueError from our service if the file type is unsupported.
        print(f"\n[UNEXPECTED ERROR] An error occurred during the service call: {e}")


if __name__ == "__main__":
    run_ocr_service_test(IMAGE_PATH, CONTENT_TYPE)

--- File: .\ata-backend\tests\test_outsider_creation.py ---

import pytest
from unittest.mock import MagicMock, AsyncMock, mock_open, patch
import json
from app.services.assessment_helpers import analytics_and_matching
from app.models.assessment_model import AssessmentConfig, QuestionConfig

@pytest.mark.asyncio
async def test_match_files_creates_outsider_for_unmatched_file(mocker):
    """
    Tests that when a file doesn't match any student in the roster,
    a new 'outsider' student is created with the correct attributes.
    """
    # 1. Setup Mocks
    mock_db_service = MagicMock()
    job_id = "job_outsider_test"
    user_id = "user_test"

    # Mock job record from the database
    mock_job_record = MagicMock()
    mock_job_record.answer_sheet_paths = json.dumps([{"path": "/path/to/unknown_person.pdf", "contentType": "application/pdf"}])

    # Mock config object
    mock_config = AssessmentConfig(assessmentName="Outsider Test", classId="cls_1", questions=[QuestionConfig(id='q1', text='t', rubric='r')])

    # Mock student record that will be returned after creation
    mock_new_student = MagicMock()
    mock_new_student.id = "stu_new_outsider_456"

    # Configure the mock DB service
    mock_db_service.get_assessment_job.return_value = mock_job_record
    mock_db_service.get_students_by_class_id.return_value = [] # No students in roster, forcing an outsider case
    mock_db_service.add_student.return_value = mock_new_student

    # Mock external services and built-ins
    mocker.patch('app.services.assessment_helpers.analytics_and_matching.normalize_config_to_v2', return_value=mock_config)
    mocker.patch('app.services.ocr_service.extract_text_from_file', return_value="some text that does not match anyone")
    mocker.patch("builtins.open", mock_open(read_data=b"fake file bytes"))
    mock_create_results = mocker.patch('app.services.assessment_helpers.analytics_and_matching._create_results_for_student')

    # 2. Execute the function
    await analytics_and_matching.match_files_to_students(mock_db_service, job_id, user_id)

    # 3. Assertions
    # Assert that a new student was added
    mock_db_service.add_student.assert_called_once()

    # Check the keyword arguments passed to add_student
    call_kwargs = mock_db_service.add_student.call_args.kwargs
    assert call_kwargs['is_outsider'] is True
    assert call_kwargs['origin_job_id'] == job_id
    assert call_kwargs['name'].startswith("Outsider")
    assert "outsider::" in call_kwargs['student_id_str']

    # Assert that results were created for the new outsider student
    mock_create_results.assert_called_once_with(
        mock_db_service,
        job_id,
        mock_new_student.id,
        mock_config,
        {"path": "/path/to/unknown_person.pdf", "contentType": "application/pdf"},
        user_id
    )
    print("\nâœ… SUCCESS: test_match_files_creates_outsider_for_unmatched_file passed.")

--- File: .\ata-backend\tests\__init__.py ---

 


--- File: .\ata-frontend\direcotory generator.py ---

#!/usr/bin/env python3

import os

# â”€â”€â”€ CONFIGURE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
max_depth = 3  # Set the maximum depth to explore. 0 for root only, 1 for root + children, etc.

skip_dirs = [
    "venv",
    ".pytest_cache",
    "test",
    ".git",
    "__pycache__",
    "GCSE",
    "Primary School",
    "Sixth Form - College",
    "node_modules"
    # add more folder names here to skip
]

output_file = "directory_map.txt"
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    root_dir = os.getcwd()
    base = os.path.basename(root_dir.rstrip(os.path.sep))
    
    with open(output_file, "w", encoding="utf-8") as f:
        # We don't write the root here, os.walk will handle it on the first iteration

        for current_root, dirs, files in os.walk(root_dir):
            # relative path from root
            rel_path = os.path.relpath(current_root, root_dir)
            
            # --- DEPTH CALCULATION ---
            if rel_path == ".":
                depth = 0
            else:
                depth = len(rel_path.split(os.path.sep))
            
            # --- PRUNING LOGIC ---
            # Prune skip_dirs first
            # We iterate over a copy of dirs using list(dirs) because we modify it in the loop
            for d in list(dirs):
                if d in skip_dirs:
                    # Construct the path to show it's being skipped
                    if depth < max_depth: # Only show skipped message if within depth
                        if rel_path == ".":
                             prefix = f"/{base}"
                        else:
                             prefix = f"/{base}/{rel_path.replace(os.path.sep, '/')}"
                        skip_path = prefix + "/" + d + "/"
                        f.write(skip_path + " (skipped)\n")
                    dirs.remove(d) # Prune it from traversal

            # Now, prune based on max_depth
            if depth >= max_depth:
                dirs[:] = [] # Clear the list of directories to visit next, stopping the descent

            # --- OUTPUT GENERATION ---
            # Construct the display prefix for the current directory
            if rel_path == ".":
                prefix = f"/{base}"
            else:
                prefix = f"/{base}/{rel_path.replace(os.path.sep, '/')}"

            # write this folderâ€™s path
            f.write(prefix + "/\n")

            # list files: full path for first, shortened for the rest
            if files:
                # full path for the first file
                first_file = files[0]
                f.write(f"{prefix}/{first_file}\n")

                # for subsequent files, show only ".../<last_dir>/<filename>"
                last_dir = os.path.basename(current_root)
                for filename in files[1:]:
                    f.write(f".../{last_dir}/{filename}\n")

    print(f"Directory map written to {output_file} (up to a depth of {max_depth})")

if __name__ == "__main__":
    main()

--- File: .\ata-frontend\index.html ---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <!-- === FONT LOADING START === -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="/icon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- === FONT LOADING END === -->
    
    <title>MST - My Smart Teach</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

--- File: .\ata-frontend\vite.config.js ---

// /vite.config.js

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  
  // --- SERVER CONFIGURATION ---
  // This section configures the Vite development server.
  server: {
    // --- HOST CONFIGURATION ---
    // By default, Vite only allows connections from localhost.
    // To use a tunneling service like PageKite or ngrok, you must
    // explicitly add your public hostname to the list of allowed hosts.
    // This is a security feature to prevent DNS rebinding attacks.
    allowedHosts: [
      // Add your PageKite hostname here as a string.
      "mehrangharooni.pagekite.me",
      
      // It's good practice to also keep the default if needed,
      // though Vite may handle localhost implicitly.
      ".localhost",
    ],
  },
});

--- File: .\ata-frontend\src\App.jsx ---

// /src/App.jsx (FINAL, SECURE, SUPERVISOR-APPROVED VERSION)

// --- Core React & Router Imports ---
import React, { useMemo } from 'react';
import { BrowserRouter as Router, Routes, Route, Outlet } from 'react-router-dom';

// --- MUI & Theme Imports ---
import { ThemeProvider } from '@mui/material/styles';
import { CssBaseline } from '@mui/material';
import { getTheme } from './theme/theme';

// --- Context Provider Imports ---
// These providers wrap the entire application to provide global state.
import { ThemeModeProvider, useThemeMode } from './hooks/useThemeMode';
import { AuthProvider } from './hooks/useAuth';
import { SnackbarProvider } from './hooks/useSnackbar';

// --- [CRITICAL MODIFICATION 1/4: IMPORT NEW COMPONENTS] ---
// Import the new pages and the route protection component.
import Login from './pages/Login';
import Register from './pages/Register';
import ProtectedRoute from './components/common/ProtectedRoute';

// --- Component & Page Imports (Existing) ---
import ErrorBoundary from './components/common/ErrorBoundary';
import Layout from './components/common/Layout';
import Home from './pages/Home';
import Classes from './pages/Classes';
import ClassDetails from './pages/ClassDetails';
import AITools from './pages/AITools';
import QuestionGenerator from './pages/tools/QuestionGenerator';
import SlideGenerator from './pages/tools/SlideGenerator';
import RubricGenerator from './pages/tools/RubricGenerator';
import Assessments from './pages/Assessments';
import NewAssessmentV2 from './pages/assessments/NewAssessmentV2';
import AssessmentResultsPage from './pages/assessments/AssessmentResultsPage';
import AssessmentReviewPage from './pages/assessments/AssessmentReviewPage';
import RedirectReviewToFirstStudent from './pages/assessments/RedirectReviewToFirstStudent';
import PublicReportView from './pages/public/ReportView';
import Chatbot from './pages/Chatbot';
import StudentProfile from './pages/StudentProfile';
import AdminDashboard from './pages/AdminDashboard';

/**
 * A layout component that wraps all protected pages.
 * It includes the main Layout (Header, Sidebar) and an Outlet for the specific page content.
 */
const AppLayout = () => (
  <Layout>
    <Outlet />
  </Layout>
);

/**
 * A component that applies the MUI theme and defines the application's routing structure.
 */
const ThemedApp = () => {
  const { mode } = useThemeMode();
  // useMemo ensures the theme is only recalculated when the mode changes.
  const theme = useMemo(() => getTheme(mode), [mode]);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      {/* The Routes component is where all URL-to-component mapping is defined. */}
      <Routes>
        {/* --- [CRITICAL MODIFICATION 2/4: DEFINE PUBLIC-ONLY ROUTES] --- */}
        {/* These routes are for unauthenticated users. */}
        <Route path="/login" element={<Login />} />
        <Route path="/register" element={<Register />} />

        {/* --- [CRITICAL MODIFICATION 3/4: DEFINE TRULY PUBLIC ROUTES] --- */}
        {/* This route is accessible to anyone, logged in or not. */}
        <Route path="/report/:report_token" element={<PublicReportView />} />

        {/* --- ADMIN ROUTE (Special Protected Route) --- */}
        <Route path="/admin" element={<ProtectedRoute><AdminDashboard /></ProtectedRoute>} />

        {/* --- [CRITICAL MODIFICATION 4/4: DEFINE PROTECTED ROUTES] --- */}
        {/* This parent Route uses the ProtectedRoute component as its element.
            ANY route nested inside this one will first be checked by ProtectedRoute.
            If the user is not authenticated, they will be redirected to /login
            and none of the child routes will ever be rendered. */}
        <Route element={<ProtectedRoute><AppLayout /></ProtectedRoute>}>
          {/* All application pages that require a user to be logged in go here. */}
          <Route path="/" element={<Home />} />
          <Route path="/classes" element={<Classes />} />
          <Route path="/classes/:class_id" element={<ClassDetails />} />
          <Route path="/students/:student_id" element={<StudentProfile />} />
          <Route path="/tools" element={<AITools />} />
          <Route path="/tools/question-generator" element={<QuestionGenerator />} />
          <Route path="/tools/slide-generator" element={<SlideGenerator />} />
          <Route path="/tools/rubric-generator" element={<RubricGenerator />} />
          <Route path="/assessments" element={<Assessments />} />
          <Route path="/assessments/new" element={<NewAssessmentV2 />} />
          <Route path="/assessments/:job_id/results" element={<AssessmentResultsPage />} />
          <Route path="/assessments/:job_id/review/:entity_id" element={<AssessmentReviewPage />} />
          <Route path="/chat/:sessionId?" element={<Chatbot />} />

          {/* A catch-all route for any other path, rendered within the protected layout. */}
          <Route path="*" element={<h1>404 Not Found</h1>} />
        </Route>
      </Routes>
    </ThemeProvider>
  );
}

/**
 * The absolute top-level component of the application.
 * It sets up the Router and all the global context providers.
 * The order of providers here generally doesn't matter, but it's good practice
 * to have the AuthProvider near the top.
 */
function App() {
  return (
    <ErrorBoundary>
      <Router>
        <AuthProvider>
          <SnackbarProvider>
            <ThemeModeProvider>
              <ThemedApp />
            </ThemeModeProvider>
          </SnackbarProvider>
        </AuthProvider>
      </Router>
    </ErrorBoundary>
  );
}

export default App;

--- File: .\ata-frontend\src\config.js ---

// /ata-frontend/src/config.js

// 1. Get the base HTTP URL from the environment variables set by Vercel/Vite
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';

// 2. Determine if the current environment is production
const IS_PRODUCTION = API_BASE_URL.startsWith('https://');

// 3. Construct the WebSocket URL
//    - If it's production (https), use the secure 'wss://' protocol.
//    - If it's local dev (http), use the insecure 'ws://' protocol.
//    - We also need to strip the 'http' or 'https' from the base URL.
const WS_BASE_URL = IS_PRODUCTION
  ? `wss://${API_BASE_URL.replace(/^https?:\/\//, '')}`
  : `ws://${API_BASE_URL.replace(/^https?:\/\//, '')}`;

// 4. Export the configured URLs for the rest of the app to use
export const config = {
  apiBaseUrl: API_BASE_URL,
  wsBaseUrl: WS_BASE_URL,
};

--- File: .\ata-frontend\src\main.jsx ---

// /src/main.jsx



// --- Core React Imports ---
import React from 'react';
import ReactDOM from 'react-dom/client';

// --- Application Shell Import ---
// Import the top-level App component.
import App from './App.jsx';
import { SpeedInsights } from "@vercel/speed-insights/react"

// --- Application Rendering ---
// Find the root DOM element from index.html.
const rootElement = document.getElementById('root');
const root = ReactDOM.createRoot(rootElement);

// Render the entire application into the root.
// All providers and theming are now handled inside the App component.
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

--- File: .\ata-frontend\src\components\assessments\AIGradingPanel.jsx ---

// /src/components/assessments/AIGradingPanel.jsx
import React from 'react';
import { Card, CardHeader, CardContent, TextField, Typography, Box } from '@mui/material';

const AIGradingPanel = ({
  suggestedGrade,
  suggestedFeedback,
  overrideGrade,
  overrideFeedback,
  onGradeChange,
  onFeedbackChange,
  maxScore,
  disabled
}) => {
  const displayGrade = overrideGrade ?? suggestedGrade;
  const displayFeedback = overrideFeedback ?? suggestedFeedback;

  return (
    <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <CardHeader title="AI Suggestion & Review" />
      <CardContent sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column', gap: 3 }}>
        <Box>
          <Typography variant="overline" color="text.secondary">
            Grade (out of {maxScore || 10})
          </Typography>
          <TextField
            fullWidth variant="outlined" type="number"
            value={displayGrade}
            onChange={(e) => onGradeChange(e.target.value)}
            disabled={disabled}
            InputProps={{ sx: { fontSize: '2rem', fontWeight: 700 } }}
          />
        </Box>
        <Box sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
          <Typography variant="overline" color="text.secondary" sx={{ mb: 1 }}>
            Feedback
          </Typography>
          <TextField
            fullWidth multiline rows={10}
            value={displayFeedback}
            onChange={(e) => onFeedbackChange(e.target.value)}
            helperText="You can edit the AI's feedback here."
            disabled={disabled}
            sx={{ flexGrow: 1, '& .MuiInputBase-root': { height: '100%' } }}
          />
        </Box>
      </CardContent>
    </Card>
  );
};
export default AIGradingPanel;

--- File: .\ata-frontend\src\components\assessments\AnswerSheetViewer.jsx ---

// /src/components/assessments/AnswerSheetViewer.jsx
import React from 'react';
import { Card, CardHeader, Box, Typography } from '@mui/material';
// NOTE: We will create the PDFViewer component in a later instruction. For now, we will link to the file.
// import PDFViewer from './PDFViewer'; 

const getFileType = (url) => {
  if (!url) return null;
  const extension = url.split('.').pop().toLowerCase().split('?')[0];
  if (['jpg', 'jpeg', 'png', 'gif'].includes(extension)) return 'image';
  if (extension === 'pdf') return 'pdf';
  return 'unknown';
};

const AnswerSheetViewer = ({ fileUrl, studentName }) => {
  const fileType = getFileType(fileUrl);

  const renderContent = () => {
    switch (fileType) {
      case 'image':
        return (
          <img src={fileUrl} alt={`Answer sheet for ${studentName}`} style={{ maxWidth: '100%', height: 'auto', objectFit: 'contain' }} />
        );
      case 'pdf':
        // For now, we will show a link. We will replace this with the real viewer component next.
        return (
          <Box sx={{p: 4, textAlign: 'center'}}>
             <Typography>PDF viewing will be enabled in the next step.</Typography>
             <a href={fileUrl} target="_blank" rel="noopener noreferrer">Open PDF in new tab</a>
          </Box>
        )
      default:
        return (
          <Box sx={{display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%'}}>
            <Typography color="text.secondary">{fileUrl ? 'Unsupported file type.' : 'No answer sheet available.'}</Typography>
          </Box>
        );
    }
  };

  return (
    <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <CardHeader title="Student Answer Sheet" />
      <Box sx={{ flexGrow: 1, overflow: 'auto', display: 'flex', justifyContent: 'center', p: 1, backgroundColor: 'grey.100' }}>
        {renderContent()}
      </Box>
    </Card>
  );
};
export default AnswerSheetViewer;

--- File: .\ata-frontend\src\components\assessments\AssessmentCard.jsx ---

// /src/components/assessments/AssessmentCard.jsx (UPDATED WITH DELETE ACTION AND COUNTDOWN TIMER)
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box, Card, CardActionArea, Typography, Grid, Menu, MenuItem, IconButton, Tooltip, ListItemIcon, Divider
} from '@mui/material';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import FileCopyOutlined from '@mui/icons-material/FileCopyOutlined';
import DeleteOutline from '@mui/icons-material/DeleteOutline'; // Import the delete icon

import StatusChip from './StatusChip';
import CompletedStats from './CompletedStats';

const AssessmentCard = ({ job, onDelete }) => { // Accept the new onDelete prop
    const navigate = useNavigate();
    const [anchorEl, setAnchorEl] = useState(null);
    const isMenuOpen = Boolean(anchorEl);
    const [remainingSeconds, setRemainingSeconds] = useState(0);
    const startTimeRef = useRef(null);

    const isClickable = ['Pending Review', 'Completed'].includes(job.status);

    // Initialize countdown when job starts processing
    useEffect(() => {
        if (job.status === 'Processing' && job.totalPages > 0) {
            // If we don't have a start time, set it now
            if (!startTimeRef.current) {
                startTimeRef.current = Date.now();
                const estimatedSeconds = job.totalPages * 45; // 45 seconds per page
                setRemainingSeconds(estimatedSeconds);
            }
        } else {
            // Reset when job is no longer processing
            startTimeRef.current = null;
            setRemainingSeconds(0);
        }
    }, [job.status, job.totalPages]);

    // Countdown timer effect
    useEffect(() => {
        if (job.status === 'Processing' && remainingSeconds > 0) {
            const timer = setInterval(() => {
                setRemainingSeconds(prev => Math.max(0, prev - 1));
            }, 1000);
            return () => clearInterval(timer);
        }
    }, [job.status, remainingSeconds]);

    const handleCardClick = () => {
        // Consistent entry point: Results page for every job
        navigate(`/assessments/${job.id}/results`);
    };

    const handleMenuClick = (event) => {
        // Stop propagation is no longer needed as the button is outside the action area.
        setAnchorEl(event.currentTarget);
    };

    const handleMenuClose = () => {
        setAnchorEl(null);
    };

    const handleClone = () => {
        navigate(`/assessments/new?cloneFromJobId=${job.id}`);
        handleMenuClose();
    };

    // --- [THE FIX IS HERE: NEW DELETE HANDLER] ---
    const handleDelete = () => {
        onDelete(); // Call the prop passed down from the parent page
        handleMenuClose();
    };
    // --- [END OF FIX] ---
    
    const formattedDate = job.createdAt ? new Date(job.createdAt).toLocaleDateString() : 'N/A';

    return (
        <Card sx={{ position: 'relative' }}>
            {/* The Options button is now available on more statuses */}
            {(job.status === 'Completed' || job.status === 'Failed') && (
                <Box sx={{ position: 'absolute', top: 8, right: 8, zIndex: 1 }}>
                    <Tooltip title="Assessment Options">
                        <IconButton onClick={handleMenuClick} aria-label="assessment options">
                            <MoreVertIcon />
                        </IconButton>
                    </Tooltip>
                    <Menu anchorEl={anchorEl} open={isMenuOpen} onClose={handleMenuClose}>
                        <MenuItem onClick={handleClone}>
                            <ListItemIcon><FileCopyOutlined fontSize="small" /></ListItemIcon>
                            Clone Assessment
                        </MenuItem>
                        <Divider />
                        {/* --- [THE FIX IS HERE: NEW MENU ITEM] --- */}
                        <MenuItem onClick={handleDelete} sx={{ color: 'error.main' }}>
                            <ListItemIcon><DeleteOutline fontSize="small" color="error" /></ListItemIcon>
                            Delete Assessment
                        </MenuItem>
                        {/* --- [END OF FIX] --- */}
                    </Menu>
                </Box>
            )}
            
            <CardActionArea onClick={handleCardClick} disabled={!isClickable} sx={{ p: 3 }}>
                <Grid container spacing={2} alignItems="center">
                    <Grid item xs={12} md={5}>
                        <Typography variant="h3" gutterBottom>{job.assessmentName}</Typography>
                        <Typography color="text.secondary">For: {job.className}</Typography>
                        <Typography variant="caption" color="text.secondary">
                            Created on: {formattedDate}
                        </Typography>
                    </Grid>
                    <Grid item xs={12} md={3}>
                        <StatusChip status={job.status} progress={job.progress} remainingSeconds={remainingSeconds} />
                    </Grid>
                    <Grid item xs={12} md={4} sx={{ display: 'flex', justifyContent: 'flex-end', alignItems: 'center' }}>
                        {job.status === 'Completed' && (
                            <CompletedStats results={job.results} />
                        )}
                    </Grid>
                </Grid>
            </CardActionArea>
        </Card>
    );
};

export default AssessmentCard;

--- File: .\ata-frontend\src\components\assessments\CompletedStats.jsx ---

// /src/components/assessments/CompletedStats.jsx
import React from 'react';
import { Box, Stack, Typography } from '@mui/material';

const CompletedStats = ({ results }) => {
    if (!results) return null; // Defensive check

    return (
        <Stack direction="row" spacing={4} alignItems="center">
            <Box>
                <Typography variant="h3">{results.classAverage}%</Typography>
                <Typography variant="body2" color="text.secondary">Class Average</Typography>
            </Box>
            <Box>
                <Typography variant="h3">#{results.hardestQuestion}</Typography>
                <Typography variant="body2" color="text.secondary">Hardest Question</Typography>
            </Box>
        </Stack>
    );
};

export default CompletedStats;

--- File: .\ata-frontend\src\components\assessments\PDFViewer.jsx ---

// ata-frontend/src/components/assessments/PDFViewer.jsx

import React from 'react';
import { Card, CardHeader, Box, Typography } from '@mui/material';
import PDFViewer from './PDFViewer'; // Import the new component

const getFileType = (url) => {
  if (!url) return null;
  const extension = url.split('.').pop().toLowerCase().split('?')[0];
  if (['jpg', 'jpeg', 'png', 'gif'].includes(extension)) return 'image';
  if (extension === 'pdf') return 'pdf';
  return 'unknown';
};

const AnswerSheetViewer = ({ fileUrl, studentName }) => {
  const fileType = getFileType(fileUrl);

  const renderContent = () => {
    switch (fileType) {
      case 'image':
        return (
          <img src={fileUrl} alt={`Answer sheet for ${studentName}`} style={{ maxWidth: '100%', height: 'auto', objectFit: 'contain' }} />
        );
      case 'pdf':
        return <PDFViewer fileUrl={fileUrl} />;
      default:
        return (
          <Box sx={{display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%'}}>
            <Typography color="text.secondary">{fileUrl ? 'Unsupported file type.' : 'No answer sheet available.'}</Typography>
          </Box>
        );
    }
  };

  return (
    <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <CardHeader title="Student Answer Sheet" />
      <Box sx={{ flexGrow: 1, overflow: 'hidden', display: 'flex', justifyContent: 'center' }}>
        {renderContent()}
      </Box>
    </Card>
  );
};

export default AnswerSheetViewer;

--- File: .\ata-frontend\src\components\assessments\QuestionReviewCard.jsx ---

// /src/components/assessments/QuestionReviewCard.jsx

import React from 'react';
import {
  Box, Grid, Card, CardHeader, CardContent, TextField, Chip, Divider,
  Tooltip, Typography, Paper, IconButton, Stack 
} from '@mui/material';
import CheckCircleOutline from '@mui/icons-material/CheckCircleOutline';
import RateReviewOutlined from '@mui/icons-material/RateReviewOutlined';
import Edit from '@mui/icons-material/Edit';
import InfoOutlined from '@mui/icons-material/InfoOutlined';

/**
 * A detailed, editable card for reviewing a single graded question.
 */
const QuestionReviewCard = ({
  questionData,
  questionNumber,
  onUpdate, // Function to lift state changes up
  disabled
}) => {
  const isPendingManualReview = questionData.status === 'pending_review';

  // Helper to determine which chip to show based on the question's status.
  const getStatusChip = () => {
    switch (questionData.status) {
      case 'ai_graded':
        return <Chip icon={<CheckCircleOutline />} label="AI Graded" color="success" size="small" variant="outlined"/>;
      case 'pending_review':
        return <Chip icon={<RateReviewOutlined />} label="Needs Your Grade" color="warning" size="small" />;
      case 'teacher_graded':
        return <Chip icon={<Edit />} label="Graded by You" color="primary" size="small" />;
      default:
        return <Chip label={questionData.status} size="small" />;
    }
  };

  return (
    <Card>
      <CardHeader
        title={`Question ${questionNumber}`}
        subheader={questionData.questionText}
        action={getStatusChip()}
        titleTypographyProps={{ variant: 'h4' }}
        subheaderTypographyProps={{ variant: 'body1', color: 'text.secondary', whiteSpace: 'pre-wrap', mt: 1 }}
      />
      <CardContent>
        <Grid container spacing={3}>
          {/* Left Column: Student's Answer */}
          <Grid item xs={12} md={6}>
            <Typography variant="overline" color="text.secondary">Student's Transcribed Answer</Typography>
            <Paper variant="outlined" sx={{ p: 2, mt: 1, whiteSpace: 'pre-wrap', bgcolor: (theme) => theme.palette.mode === 'dark' ? 'grey.900' : 'grey.100', minHeight: 150, fontFamily: 'monospace' }}>
              {questionData.studentAnswer || "No answer was extracted for this question."}
            </Paper>
          </Grid>

          {/* Right Column: Teacher's Grading Inputs */}
          <Grid item xs={12} md={6}>
            <Typography variant="overline" color="text.secondary">Your Evaluation</Typography>
            <Stack spacing={2} mt={1}>
              <TextField
                label={`Your Grade (out of ${questionData.maxScore})`}
                type="number"
                fullWidth
                value={questionData.grade ?? ''} // Use nullish coalescing to show an empty string for null/undefined
                onChange={(e) => onUpdate(questionData.resultId, 'grade', e.target.value)}
                disabled={disabled}
                error={isPendingManualReview && (questionData.grade === null || questionData.grade === '')}
                helperText={isPendingManualReview && (questionData.grade === null || questionData.grade === '') ? 'This question requires your grade.' : ''}
              />
              <TextField
                label="Your Feedback"
                multiline
                rows={4}
                fullWidth
                value={questionData.feedback ?? ''}
                onChange={(e) => onUpdate(questionData.resultId, 'feedback', e.target.value)}
                disabled={disabled}
              />
            </Stack>
          </Grid>
        </Grid>

        {/* Optional Section: AI Audit Trail */}
        {questionData.aiResponses?.attempts && (
          <Box mt={3}>
            <Divider>AI Audit Trail</Divider>
            <Stack spacing={2} mt={2}>
              {questionData.aiResponses.attempts.map(attempt => (
                <Paper key={attempt.attempt} variant="outlined" sx={{ p: 2, opacity: 0.8 }}>
                   <Stack direction="row" justifyContent="space-between" alignItems="center">
                    <Typography variant="caption" sx={{ fontWeight: 'bold' }}>
                        AI Grader #{attempt.attempt}:
                    </Typography>
                    <Tooltip
                        placement="top-start"
                        title={
                          <Box sx={{ p: 1, whiteSpace: 'pre-wrap', maxWidth: 400, maxHeight: 300, overflow: 'auto' }}>
                            <Typography variant="caption">{JSON.stringify(attempt.raw_response, null, 2)}</Typography>
                          </Box>
                        }
                    >
                        <IconButton size="small"><InfoOutlined fontSize="inherit" /></IconButton>
                    </Tooltip>
                  </Stack>
                  <Typography variant="body2" sx={{ fontFamily: 'monospace', fontSize: '0.8rem', mt: 1 }}>
                    {attempt.error
                      ? <Typography component="span" color="error">{attempt.error}</Typography>
                      : `Suggested Grade: ${attempt.grade} â€” Feedback: "${attempt.feedback}"`
                    }
                  </Typography>
                </Paper>
              ))}
            </Stack>
          </Box>
        )}
      </CardContent>
    </Card>
  );
};

export default QuestionReviewCard;

--- File: .\ata-frontend\src\components\assessments\ResultsTable.jsx ---

import React from 'react';
import { Button, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper, Box, Typography, useTheme } from '@mui/material';
import { useNavigate, useParams } from 'react-router-dom';
import StatusChip from './StatusChip';
import reviewService from '../../services/reviewService';

const ResultsTable = ({ rows }) => {
  const navigate = useNavigate();
  const { job_id } = useParams();
  const theme = useTheme();

  const handleDownload = (entityId) => {
    reviewService.downloadReport(job_id, entityId)
      .catch(err => {
        // Optionally show an error to the user
        console.error(err.message);
      });
  };

  const handleReview = (entityId) => {
    navigate(`/assessments/${job_id}/review/${entityId}`);
  };

  if (!rows || rows.length === 0) {
    return (
      <Paper sx={{ p: 3, textAlign: 'center' }}>
        <Typography>No student results are available for this assessment yet.</Typography>
      </Paper>
    );
  }

  const rosteredStudents = rows.filter(s => !s.isOutsider);
  const outsiderStudents = rows.filter(s => s.isOutsider);

  const renderStudentRow = (s) => {
    let gradeText;
    if (s.status === 'PENDING_REVIEW') {
      gradeText = 'Pending';
    } else if (s.status === 'ABSENT') {
      gradeText = 'N/A';
    } else if (s.totalScore != null && s.maxTotalScore != null && s.maxTotalScore > 0) {
      gradeText = `${s.totalScore.toFixed(1)} / ${s.maxTotalScore.toFixed(1)}`;
    } else if (s.totalScore != null) {
      gradeText = s.totalScore.toFixed(1);
    } else {
      gradeText = 'N/A';
    }

    const canReview = s.status !== 'ABSENT';
    const canDownload = s.status !== 'ABSENT' && s.status !== 'PENDING_REVIEW';

    return (
      <TableRow key={s.entityId}>
        <TableCell component="th" scope="row">{s.studentName}</TableCell>
        <TableCell>{s.studentId}</TableCell>
        <TableCell><StatusChip status={s.status} /></TableCell>
        <TableCell align="right">{gradeText}</TableCell>
        <TableCell align="center">
          <Button size="small" variant="outlined" onClick={() => handleReview(s.entityId)} disabled={!canReview} sx={{ mr: 1 }}>
            Review
          </Button>
          <Button size="small" variant="outlined" onClick={() => handleDownload(s.entityId)} disabled={!canDownload}>
            Download
          </Button>
        </TableCell>
      </TableRow>
    );
  };

  return (
    <TableContainer component={Paper}>
      <Table size="small" aria-label="student results table">
        <TableHead>
          <TableRow>
            <TableCell>Name</TableCell>
            <TableCell>Student ID</TableCell>
            <TableCell>Status</TableCell>
            <TableCell align="right">Grade</TableCell>
            <TableCell align="center">Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {rosteredStudents.map(renderStudentRow)}

          {outsiderStudents.length > 0 && (
            <TableRow>
              <TableCell
                colSpan={5}
                sx={{
                  py: 1,
                  backgroundColor: theme.palette.mode === 'dark' ? 'grey.800' : 'grey.100',
                  fontWeight: 'bold'
                }}
              >
                <Typography variant="subtitle2" sx={{ pl: 2 }}>Students Not in Roster</Typography>
              </TableCell>
            </TableRow>
          )}

          {outsiderStudents.map(renderStudentRow)}
        </TableBody>
      </Table>
    </TableContainer>
  );
};

export default ResultsTable;

--- File: .\ata-frontend\src\components\assessments\RubricPanel.jsx ---

// /src/components/assessments/RubricPanel.jsx
import React, { useState } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { Card, Box, Tabs, Tab, Typography } from '@mui/material';

const TabPanel = ({ children, value, index }) => (
  <div role="tabpanel" hidden={value !== index}>
    {value === index && <Box sx={{ p: 3, height: '100%', overflowY: 'auto' }}>{children}</Box>}
  </div>
);

const RubricPanel = ({ question, rubric }) => {
  const [activeTab, setActiveTab] = useState(0);
  const handleTabChange = (_, newValue) => setActiveTab(newValue);

  return (
    <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
        <Tabs value={activeTab} onChange={handleTabChange} variant="fullWidth">
          <Tab label="Question" />
          <Tab label="Rubric" />
        </Tabs>
      </Box>
      <Box sx={{ flexGrow: 1, overflowY: 'auto' }}>
        <TabPanel value={activeTab} index={0}>
          <Typography variant="h4" gutterBottom>Question {question?.id || ''}</Typography>
          <Typography variant="body1" whiteSpace="pre-wrap">{question?.text}</Typography>
        </TabPanel>
        <TabPanel value={activeTab} index={1}>
          <ReactMarkdown remarkPlugins={[remarkGfm]}>{rubric || 'No rubric provided.'}</ReactMarkdown>
        </TabPanel>
      </Box>
    </Card>
  );
};
export default RubricPanel;

--- File: .\ata-frontend\src\components\assessments\StatusChip.jsx ---

// /src/components/assessments/StatusChip.jsx

import React from 'react';
// --- [THE FIX] ---
// We have added 'Typography' to the import list from '@mui/material'.
import { Box, Chip, LinearProgress, Typography } from '@mui/material';
import RotateRightOutlined from '@mui/icons-material/RotateRightOutlined';
import RateReviewOutlined from '@mui/icons-material/RateReviewOutlined';
import CheckCircleOutlineOutlined from '@mui/icons-material/CheckCircleOutlineOutlined';
import ErrorOutlineOutlined from '@mui/icons-material/ErrorOutlineOutlined';

const statusConfig = {
    // Job Statuses
    Processing: { label: "Processing", color: "secondary", icon: <RotateRightOutlined /> },
    Summarizing: { label: "Summarizing", color: "secondary", icon: <RotateRightOutlined /> },
    "Pending Review": { label: "Pending Review", color: "warning", icon: <RateReviewOutlined /> },
    Completed: { label: "Completed", color: "success", icon: <CheckCircleOutlineOutlined /> },
    Failed: { label: "Failed", color: "error", icon: <ErrorOutlineOutlined /> },
    Queued: { label: "Queued", color: "info", icon: <RotateRightOutlined /> },

    // Student Statuses (from ResultsTable)
    AI_GRADED: { label: "AI Graded", color: "info" },
    PENDING_REVIEW: { label: "Pending Review", color: "warning" },
    TEACHER_GRADED: { label: "Teacher Graded", color: "success" },
    ABSENT: { label: "Absent", color: "default" },
};

const StatusChip = ({ status, progress, remainingSeconds = 0 }) => {
    const config = statusConfig[status] || { label: status, color: "default", icon: null };
    const progressPercent = progress ? (progress.total > 0 ? (progress.processed / progress.total) * 100 : 0) : 0;

    // A small enhancement to handle the new "Summarizing" status gracefully.
    const isProcessing = status === 'Processing' || status === 'Summarizing';

    // Format remaining time as MM:SS
    const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${String(secs).padStart(2, '0')}`;
    };

    return (
        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start', minHeight: '32px' }}>
            <Chip label={config.label} color={config.color} icon={config.icon} />
            {isProcessing && progress && (
                <Box sx={{ width: '100%', mt: 1 }}>
                    <LinearProgress variant="determinate" value={progressPercent} />
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%' }}>
                        <Typography variant="caption" color="text.secondary">
                            {status === 'Summarizing' ? 'Finalizing results...' : `${progress.processed} / ${progress.total} graded`}
                        </Typography>
                        {remainingSeconds > 0 && status === 'Processing' && (
                            <Typography variant="caption" color="primary.main" sx={{ fontWeight: 'bold' }}>
                                ~{formatTime(remainingSeconds)}
                            </Typography>
                        )}
                    </Box>
                </Box>
            )}
        </Box>
    );
};

export default StatusChip;

--- File: .\ata-frontend\src\components\assessments\WizardStep.jsx ---

// /src/components/assessments/WizardStep.jsx

import React from 'react';
import { Box, Typography, Divider } from '@mui/material';

const WizardStep = ({ title, description, children }) => {
  return (
    <Box>
      <Typography variant="h3">{title}</Typography>
      <Typography color="text.secondary" sx={{ mt: 1 }}>
        {description}
      </Typography>
      <Divider sx={{ my: 3 }} />
      <Box>
        {children}
      </Box>
    </Box>
  );
};

export default WizardStep;

--- File: .\ata-frontend\src\components\assessments\uploader\AssessmentUploader.jsx ---

// /src/components/assessments/uploader/AssessmentUploader.jsx

import React from 'react';
import { useDropzone } from 'react-dropzone';
import { Box, Typography, Paper, CircularProgress, Stack } from '@mui/material';
import UploadFileIcon from '@mui/icons-material/UploadFile';
import { styled } from '@mui/material/styles';

// Styled component for the dropzone area for a better look and feel.
// Justification: This encapsulates the complex styling, keeping the main component's JSX clean and readable.
const DropzoneContainer = styled(Paper)(({ theme, isDragActive }) => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  justifyContent: 'center',
  padding: theme.spacing(4),
  borderWidth: 2,
  borderRadius: theme.shape.borderRadius,
  borderColor: isDragActive ? theme.palette.primary.main : theme.palette.divider,
  borderStyle: 'dashed',
  backgroundColor: isDragActive ? theme.palette.action.hover : theme.palette.background.default,
  color: theme.palette.text.secondary,
  transition: 'border .24s ease-in-out, background-color .24s ease-in-out',
  cursor: 'pointer',
  textAlign: 'center',
  minHeight: 200,
}));

const AssessmentUploader = ({ onParse, isParsing }) => {
  // Setup react-dropzone hook to handle file drops.
  // Justification: Using a dedicated library for this is a best practice, as it handles all edge cases and accessibility concerns for file inputs.
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop: (acceptedFiles) => onParse(acceptedFiles[0]), // We only handle one file at a time.
    multiple: false,
    disabled: isParsing, // Disable the dropzone while the AI is working.
    accept: {
      'application/pdf': ['.pdf'],
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'image/jpeg': ['.jpeg', '.jpg'],
      'image/png': ['.png'],
    },
  });

  return (
    <Box>
      {/* Conditional rendering to show a loading state while parsing. */}
      {/* Justification: This provides critical, immediate feedback to the user, assuring them that the system is working on their request. */}
      {isParsing ? (
        <Stack alignItems="center" spacing={2} minHeight={200} justifyContent="center">
          <CircularProgress />
          <Typography variant="h6">Analyzing Document...</Typography>
          <Typography variant="body2" color="text.secondary">
            The AI is structuring your assessment. This may take a moment.
          </Typography>
        </Stack>
      ) : (
        // The main dropzone UI.
        // Justification: This provides a large, clear, and intuitive target for the user to drag their file onto.
        <DropzoneContainer {...getRootProps({ isDragActive })}>
          <input {...getInputProps()} />
          <UploadFileIcon sx={{ fontSize: 60, mb: 2 }} />
          <Typography variant="h6">Drag & drop your assessment file here</Typography>
          <Typography variant="body1" sx={{ mb: 1 }}>or click to select a file</Typography>
          <Typography variant="caption">(PDF, DOCX, JPG, PNG)</Typography>
        </DropzoneContainer>
      )}
    </Box>
  );
};

export default AssessmentUploader;

--- File: .\ata-frontend\src\components\assessments\uploader\DocumentUploader.jsx ---

// /src/components/assessments/uploader/DocumentUploader.jsx

import React from 'react';
import { useDropzone } from 'react-dropzone';
import { Box, Typography, Paper } from '@mui/material';
import UploadFileIcon from '@mui/icons-material/UploadFile';
import { styled } from '@mui/material/styles';

const DropzoneContainer = styled(Paper)(({ theme, isDragActive, hasFile }) => ({
  display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
  padding: theme.spacing(2), borderWidth: 2, borderRadius: theme.shape.borderRadius,
  borderColor: hasFile ? theme.palette.success.main : (isDragActive ? theme.palette.primary.main : theme.palette.divider),
  borderStyle: 'dashed',
  backgroundColor: isDragActive ? theme.palette.action.hover : theme.palette.background.default,
  color: hasFile ? theme.palette.success.main : theme.palette.text.secondary,
  transition: 'all .24s ease-in-out', cursor: 'pointer', textAlign: 'center', minHeight: 150,
}));

const DocumentUploader = ({ onFileSelect, selectedFile, title, disabled }) => {
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop: (acceptedFiles) => onFileSelect(acceptedFiles[0]),
    multiple: false, disabled: disabled,
    accept: {
      'application/pdf': ['.pdf'],
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'image/jpeg': ['.jpeg', '.jpg'], 'image/png': ['.png'],
    },
  });

  return (
    <DropzoneContainer {...getRootProps({ isDragActive, hasFile: !!selectedFile })}>
      <input {...getInputProps()} />
      <UploadFileIcon sx={{ fontSize: 40, mb: 1 }} />
      <Typography variant="h6">{title}</Typography>
      {selectedFile ? (
        <Typography variant="body2" sx={{ mt: 1 }}>{selectedFile.name}</Typography>
      ) : (
        <Typography variant="body2">Drag & drop or click to select</Typography>
      )}
    </DropzoneContainer>
  );
};

export default DocumentUploader;

--- File: .\ata-frontend\src\components\assessments\uploader\GradingModeSelector.jsx ---

// /src/components/assessments/uploader/GradingModeSelector.jsx

import React, { useState, useEffect } from 'react';
import { Box, FormControl, FormLabel, RadioGroup, FormControlLabel, Radio, Select, MenuItem, InputLabel, CircularProgress } from '@mui/material';
import libraryService from '../../../services/libraryService';

const GradingModeSelector = ({ config, dispatch, disabled }) => {
  const [libraryIndex, setLibraryIndex] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  // Fetch the library index only when the user selects that mode.
  useEffect(() => {
    if (config.gradingMode === 'library' && !libraryIndex) {
      setIsLoading(true);
      libraryService.getTree()
        .then(data => setLibraryIndex(data))
        .catch(console.error)
        .finally(() => setIsLoading(false));
    }
  }, [config.gradingMode, libraryIndex]);

  const handleUpdate = (field, value) => {
    dispatch({ type: 'UPDATE_CONFIG_FIELD', payload: { field, value } });
  };

  return (
    <FormControl component="fieldset" fullWidth disabled={disabled}>
      <FormLabel component="legend">Grading Method</FormLabel>
      <RadioGroup
        row
        value={config.gradingMode || 'answer_key_provided'}
        onChange={(e) => handleUpdate('gradingMode', e.target.value)}
      >
        <FormControlLabel value="answer_key_provided" control={<Radio />} label="Answer Key in Document" />
        <FormControlLabel value="library" control={<Radio />} label="Grade from ATA Library" />
      </RadioGroup>
      
      {config.gradingMode === 'library' && (
        <Box sx={{ mt: 2, pl: 2 }}>
          {isLoading ? <CircularProgress size={24} /> : (
            <FormControl fullWidth>
              <InputLabel>Select Library Source</InputLabel>
              <Select
                value={config.librarySource || ''}
                label="Select Library Source"
                onChange={(e) => handleUpdate('librarySource', e.target.value)}
              >
                {/* This would be a recursive function in a real app, but for now we map */}
                <MenuItem value={"Secondary School/Year 9 (Key Stage 3)/Science/Activate for AQA KS3 Science - GCSE-Ready/1. Biology_B1_Chapter1_Cells.txt"}>
                  KS3 Science - Biology Chapter 1: Cells
                </MenuItem>
                <MenuItem value={"GCSE/Years 10 & 11/English Language/Pearson Edexcel GCSE (9-1) English Language Student Book/1. Reading_Skills.txt"}>
                  GCSE English - Reading Skills
                </MenuItem>
              </Select>
            </FormControl>
          )}
        </Box>
      )}
    </FormControl>
  );
};

export default GradingModeSelector;

--- File: .\ata-frontend\src\components\assessments\uploader\ManualUploader.jsx ---

import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  List,
  ListItem,
  ListItemText,
  Button,
  CircularProgress,
  Alert,
  Typography,
  Divider,
  Paper,
  Chip,
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import UploadFileIcon from '@mui/icons-material/UploadFile';

import classService from '../../../services/classService';

const ManualUploader = ({ classId, onFilesStaged, onAddOutsider, stagedFiles = {}, outsiders = [], disabled = false }) => {
  const [students, setStudents] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  const fileInputRef = useRef(null);
  const currentUploadTarget = useRef(null); // { type: 'student' | 'outsider', id: string }

  useEffect(() => {
    if (!classId) {
      setError('No class selected. Please go back to the setup step.');
      setIsLoading(false);
      return;
    }
    const fetchStudents = async () => {
      try {
        setIsLoading(true);
        const fetchedClass = await classService.getClassById(classId);
        setStudents(fetchedClass.students || []);
        setError(null);
      } catch (err) {
        setError(err.message || 'Failed to load student roster.');
        setStudents([]);
      } finally {
        setIsLoading(false);
      }
    };
    fetchStudents();
  }, [classId]);

  const handleUploadClick = (type, id) => {
    currentUploadTarget.current = { type, id };
    fileInputRef.current.click();
  };

  const handleOutsiderClick = () => {
    const outsiderName = prompt("Please enter the name for this outsider student:", "Unknown Student");
    if (outsiderName && onAddOutsider) {
      onAddOutsider(outsiderName);
    }
  };

  const handleFileChange = (event) => {
    const files = Array.from(event.target.files);
    if (files.length === 0 || !currentUploadTarget.current) return;

    const { type, id } = currentUploadTarget.current;

    if (onFilesStaged) {
      onFilesStaged({
        entityType: type,
        entityId: id,
        files: files,
      });
    }

    // Reset file input to allow uploading the same file again
    event.target.value = null;
    currentUploadTarget.current = null;
  };

  const renderUploadAction = (type, entityId) => {
    const numFiles = stagedFiles[entityId]?.length || 0;

    return (
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
        {numFiles > 0 && <Chip label={`${numFiles} file(s)`} color="primary" size="small" />}
        <Button
          variant="outlined"
          startIcon={<UploadFileIcon />}
          onClick={() => handleUploadClick(type, entityId)}
          disabled={disabled}
        >
          {numFiles > 0 ? 'Add More' : 'Upload'}
        </Button>
      </Box>
    );
  };

  if (isLoading) return <CircularProgress />;
  if (error) return <Alert severity="error">{error}</Alert>;

  return (
    <Box>
      <input
        type="file"
        multiple
        ref={fileInputRef}
        onChange={handleFileChange}
        style={{ display: 'none' }}
        accept="image/*"
        disabled={disabled}
      />
      <Typography variant="h6" gutterBottom>Student Roster</Typography>
      <Paper>
        <List>
          {students.map((student, index) => (
            <React.Fragment key={student.id}>
              <ListItem secondaryAction={renderUploadAction('student', student.id)}>
                <ListItemText primary={student.name} secondary={`ID: ${student.studentId}`} />
              </ListItem>
              {index < students.length - 1 && <Divider />}
            </React.Fragment>
          ))}
        </List>
      </Paper>

      <Divider sx={{ my: 2 }}><Typography variant="overline">Or</Typography></Divider>

      <Button
        variant="contained"
        color="secondary"
        startIcon={<AddIcon />}
        onClick={handleOutsiderClick}
        disabled={disabled}
      >
        Add Outsider Submission
      </Button>

      {outsiders.length > 0 && (
        <Box mt={3}>
          <Typography variant="h6" gutterBottom>Outsider Submissions</Typography>
          <Paper>
            <List>
              {outsiders.map((outsider, index) => (
                <React.Fragment key={outsider.id}>
                  <ListItem secondaryAction={renderUploadAction('outsider', outsider.id)}>
                    <ListItemText primary={outsider.name} secondary={`Temp ID: ${outsider.id}`} />
                  </ListItem>
                  {index < outsiders.length - 1 && <Divider />}
                </React.Fragment>
              ))}
            </List>
          </Paper>
        </Box>
      )}
    </Box>
  );
};

export default ManualUploader;

--- File: .\ata-frontend\src\components\assessments\uploader\ScoringConfigurator.jsx ---

// /src/components/assessments/uploader/ScoringConfigurator.jsx

import React from 'react';
import { FormControl, FormLabel, RadioGroup, FormControlLabel, Radio, TextField } from '@mui/material';

const ScoringConfigurator = ({ config, dispatch, disabled }) => {
  const handleUpdate = (field, value) => {
    dispatch({ type: 'UPDATE_CONFIG_FIELD', payload: { field, value } });
  };
  
  return (
    <FormControl component="fieldset" fullWidth sx={{ mt: 4 }} disabled={disabled}>
      <FormLabel component="legend">Scoring Configuration</FormLabel>
      <RadioGroup
        row
        value={config.scoringMethod || 'per_question'}
        onChange={(e) => handleUpdate('scoringMethod', e.target.value)}
      >
        <FormControlLabel value="per_question" control={<Radio />} label="Per-Question Marks" />
        <FormControlLabel value="total_score" control={<Radio />} label="Single Total Score" />
      </RadioGroup>

      {config.scoringMethod === 'total_score' && (
        <TextField
          label="Total Score for Assessment"
          type="number"
          value={config.totalScore || 100}
          onChange={(e) => handleUpdate('totalScore', parseInt(e.target.value, 10) || 0)}
          sx={{ mt: 2, maxWidth: '250px' }}
          inputProps={{ min: 1 }}
        />
      )}
    </FormControl>
  );
};

export default ScoringConfigurator;

--- File: .\ata-frontend\src\components\assessments\uploader\StructureReviewer.jsx ---

// /src/components/assessments/uploader/StructureReviewer.jsx (WITH MAX SCORE HIDDEN)

import React from 'react';
import {
  Box, Typography, Paper, TextField, Stack, IconButton, Fab, Divider,
  Accordion, AccordionSummary, AccordionDetails, List, ListItem, ListItemText
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';

const StructureReviewer = ({ config, dispatch, disabled }) => {
  // All handler functions are correct and remain unchanged.
  const handleSectionUpdate = (sectionId, field, value) => {
    dispatch({ type: 'UPDATE_SECTION_FIELD', payload: { sectionId, field, value } });
  };
  
  const handleQuestionUpdate = (sectionId, questionId, field, value) => {
    dispatch({ type: 'UPDATE_QUESTION_FIELD', payload: { sectionId, questionId, field, value } });
  };

  const handleAddQuestion = (sectionId) => {
    dispatch({ type: 'ADD_QUESTION', payload: { sectionId } });
  };

  const handleDeleteQuestion = (sectionId, questionId) => {
    dispatch({ type: 'REMOVE_QUESTION', payload: { sectionId, questionId } });
  };

  return (
    <Stack spacing={2}>
      <Typography variant="body1" color="text.secondary" sx={{ mb: 2 }}>
        Our AI has analyzed your document and structured it into the sections and questions below. Please review, edit, and confirm the details before proceeding.
      </Typography>
      
      {config.sections.map((section, sectionIndex) => (
        <Paper key={section.id} elevation={2} sx={{ overflow: 'hidden' }}>
          <Accordion defaultExpanded>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography variant="h6">{`Section ${sectionIndex + 1}: ${section.title}`}</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <List>
                {section.questions.map((q, questionIndex) => (
                  <React.Fragment key={q.id}>
                    <ListItem
                      secondaryAction={
                        <IconButton edge="end" onClick={() => handleDeleteQuestion(section.id, q.id)} disabled={disabled}>
                          <DeleteIcon />
                        </IconButton>
                      }
                    >
                      <ListItemText primary={<Typography variant="subtitle1" component="div">{`Question ${questionIndex + 1}`}</Typography>} />
                    </ListItem>
                    <Stack spacing={2} sx={{ pl: 4, pt: 1, pb: 2 }}>
                      <TextField fullWidth multiline rows={3} label="Question Text" value={q.text || ''} onChange={(e) => handleQuestionUpdate(section.id, q.id, 'text', e.target.value)} disabled={disabled} />
                      <TextField fullWidth multiline rows={5} label="Grading Rubric / Answer" value={q.rubric || ''} onChange={(e) => handleQuestionUpdate(section.id, q.id, 'rubric', e.target.value)} disabled={disabled} />
                      
                      <TextField
                        type="number"
                        label="Max Score"
                        value={q.maxScore || ''}
                        onChange={(e) => handleQuestionUpdate(section.id, q.id, 'maxScore', parseInt(e.target.value, 10) || 0)}
                        disabled={disabled}
                        sx={{ maxWidth: '150px' }}
                        inputProps={{ min: 1 }}
                        placeholder="e.g., 10"
                      />

                    </Stack>
                    {questionIndex < section.questions.length - 1 && <Divider sx={{ my: 2 }} />}
                  </React.Fragment>
                ))}
              </List>
              <Box sx={{ display: 'flex', justifyContent: 'center', mt: 2 }}>
                <Fab size="small" color="secondary" aria-label="add question" onClick={() => handleAddQuestion(section.id)} disabled={disabled}>
                  <AddIcon />
                </Fab>
              </Box>
            </AccordionDetails>
          </Accordion>
        </Paper>
      ))}
    </Stack>
  );
};

export default StructureReviewer;

--- File: .\ata-frontend\src\components\assessments\wizard\Step1Setup.jsx ---

// ata-frontend/src/components/assessments/wizard/Step1Setup.jsx
import React from 'react';
import { Stack, TextField, FormControl, InputLabel, Select, MenuItem } from '@mui/material';

const Step1Setup = ({ state, handleUpdateField, classes, disabled }) => (
    <Stack spacing={3}>
        <TextField label="Assessment Name" value={state.assessmentName} onChange={(e) => handleUpdateField('assessmentName', e.target.value)} required autoFocus disabled={disabled} />
        <FormControl fullWidth required disabled={disabled}>
            <InputLabel>Select Class</InputLabel>
            <Select value={state.classId} label="Select Class" onChange={(e) => handleUpdateField('classId', e.target.value)}>
                {classes.map(c => <MenuItem key={c.id} value={c.id}>{c.name}</MenuItem>)}
            </Select>
        </FormControl>
    </Stack>
);
export default Step1Setup;

--- File: .\ata-frontend\src\components\assessments\wizard\Step2Questions.jsx ---

// ata-frontend/src/components/assessments/wizard/Step2Questions.jsx

import React from 'react';
import { Box, Stack, TextField, ToggleButtonGroup, ToggleButton, Typography, FormGroup, FormControlLabel, Checkbox } from '@mui/material';
import FileUploadZone from '../../../components/common/FileUploadZone';

const Step2Questions = ({ state, handleUpdateField, disabled }) => (
    <Stack spacing={4}>
      <Box>
        <Typography variant="h4" gutterBottom>Exam Questions</Typography>
        <ToggleButtonGroup value={state.questionsSourceType} exclusive onChange={(_, v) => v && handleUpdateField('questionsSourceType', v)} disabled={disabled}>
          <ToggleButton value="text">Text Input</ToggleButton>
          <ToggleButton value="file">File Upload</ToggleButton>
        </ToggleButtonGroup>
        {state.questionsSourceType === 'text' ? (
          <TextField fullWidth multiline rows={6} sx={{ mt: 2 }} value={state.questionsText} onChange={(e) => handleUpdateField('questionsText', e.target.value)} disabled={disabled} />
        ) : (
          <Box sx={{ mt: 2 }}><FileUploadZone onDrop={files => handleUpdateField('questionsFile', files[0])} disabled={disabled} /></Box>
        )}
      </Box>
      <Box>
        <Typography variant="h4" gutterBottom>Grading Rubric</Typography>
        <ToggleButtonGroup value={state.rubricSourceType} exclusive onChange={(_, v) => v && handleUpdateField('rubricSourceType', v)} disabled={disabled}>
          <ToggleButton value="text">Text Input</ToggleButton>
          <ToggleButton value="file">File Upload</ToggleButton>
        </ToggleButtonGroup>
        {state.rubricSourceType === 'text' ? (
          <TextField fullWidth multiline rows={6} sx={{ mt: 2 }} value={state.rubricText} onChange={(e) => handleUpdateField('rubricText', e.target.value)} disabled={disabled} />
        ) : (
          <Box sx={{ mt: 2 }}><FileUploadZone onDrop={files => handleUpdateField('rubricFile', files[0])} disabled={disabled} /></Box>
        )}
      </Box>
      <Box>
         <Typography variant="h4" gutterBottom>Grading Options</Typography>
         <TextField type="number" label="Max Score per Question" value={state.maxScore} onChange={e => handleUpdateField('maxScore', e.target.value)} sx={{mr: 2, width: '200px'}} disabled={disabled} />
         <FormControlLabel control={<Checkbox checked={state.includeImprovementTips} onChange={e => handleUpdateField('includeImprovementTips', e.target.checked)} disabled={disabled} />} label="Include Improvement Tips" />
      </Box>
    </Stack>
);
export default Step2Questions;

--- File: .\ata-frontend\src\components\assessments\wizard\Step3Upload.jsx ---

// ata-frontend/src/components/assessments/wizard/Step3Upload.jsx

import React from 'react';
import { List, ListItem, ListItemText, IconButton } from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import FileUploadZone from '../../../components/common/FileUploadZone';

const Step3Upload = ({ state, dispatch, disabled }) => (
    <>
        <FileUploadZone onDrop={acceptedFiles => dispatch({ type: 'ADD_ANSWER_SHEETS', payload: acceptedFiles })} disabled={disabled} />
        <List sx={{ mt: 2, maxHeight: 300, overflow: 'auto' }}>
          {state.answerSheetFiles.map(file => (
            <ListItem key={file.path || file.name} secondaryAction={<IconButton edge="end" onClick={() => dispatch({ type: 'REMOVE_ANSWER_SHEET', payload: file.name })} disabled={disabled}><DeleteIcon /></IconButton>}>
              <ListItemText primary={file.name} secondary={`${Math.round(file.size / 1024)} KB`} />
            </ListItem>
          ))}
        </List>
    </>
);
export default Step3Upload;

--- File: .\ata-frontend\src\components\assessments\wizard\Step4Review.jsx ---

// ata-frontend/src/components/assessments/wizard/Step4Review.jsx

import React from 'react';
import { List, ListItem, ListItemText } from '@mui/material';

const Step4Review = ({ state, classes }) => (
    <List>
      <ListItem><ListItemText primary="Assessment Name" secondary={state.assessmentName} /></ListItem>
      <ListItem><ListItemText primary="Class" secondary={classes.find(c => c.id === state.classId)?.name || 'N/A'} /></ListItem>
      <ListItem><ListItemText primary="Questions Source" secondary={state.questionsFile?.name || 'Text Input'} /></ListItem>
      <ListItem><ListItemText primary="Rubric Source" secondary={state.rubricFile?.name || 'Text Input'} /></ListItem>
      <ListItem><ListItemText primary="Answer Sheets" secondary={`${state.answerSheetFiles.length} files uploaded`} /></ListItem>
    </List>
);
export default Step4Review;

--- File: .\ata-frontend\src\components\assessments\wizard\Step4ReviewV2.jsx ---

// /src/components/assessments/wizard/Step4ReviewV2.jsx

import React from 'react';
import { List, ListItem, ListItemText, Typography, Divider } from '@mui/material';

const Step4ReviewV2 = ({ state, classes }) => {
  // Helper to count total questions from the new V2 config structure.
  const totalQuestions = state.config?.sections?.reduce((acc, section) => acc + section.questions.length, 0) || 0;

  return (
    <List>
      <ListItem>
        <ListItemText 
          primary="Assessment Name" 
          secondary={state.assessmentName} 
        />
      </ListItem>
      <Divider />
      <ListItem>
        <ListItemText 
          primary="Class" 
          secondary={classes.find(c => c.id === state.classId)?.name || 'N/A'} 
        />
      </ListItem>
      <Divider />
      <ListItem>
        <ListItemText 
          primary="Assessment Structure" 
          secondary={
            <Typography variant="body2" color="text.secondary">
              {state.config?.sections?.length || 0} Sections, {totalQuestions} Questions
            </Typography>
          }
        />
      </ListItem>
      <Divider />
      <ListItem>
        <ListItemText 
          primary="Student Answer Sheets" 
          secondary={`${state.answerSheetFiles.length} files uploaded`} 
        />
      </ListItem>
    </List>
  );
};

export default Step4ReviewV2;

--- File: .\ata-frontend\src\components\chatbot\ChatHistoryPanel.jsx ---

// /ata-frontend/src/components/chatbot/ChatHistoryPanel.jsx

import React, { useState } from 'react';
import { Box, List, ListItem, ListItemButton, ListItemText, Typography, Button, CircularProgress, IconButton, Menu, MenuItem, Drawer, useTheme } from '@mui/material';
import AddCommentOutlined from '@mui/icons-material/AddCommentOutlined';
import MoreVertIcon from '@mui/icons-material/MoreVert';

// A new sub-component for a single history item with its menu
const HistoryItem = ({ session, active, onSelect, onDelete }) => {
    const [anchorEl, setAnchorEl] = useState(null);
    const open = Boolean(anchorEl);

    const handleMenuClick = (event) => {
        event.stopPropagation(); // Prevent the main button click
        setAnchorEl(event.currentTarget);
    };
    const handleMenuClose = () => {
        setAnchorEl(null);
    };
    const handleDelete = () => {
        onDelete(session.id);
        handleMenuClose();
    };

    return (
        <ListItem disablePadding>
            <ListItemButton selected={active} onClick={() => onSelect(session.id)}>
                <ListItemText
                    primary={session.name}
                    primaryTypographyProps={{ noWrap: true, variant: 'body2' }}
                    secondary={new Date(session.created_at).toLocaleDateString()}
                />
                <IconButton
                    size="small"
                    aria-label={`options for chat ${session.name}`}
                    onClick={handleMenuClick}
                >
                    <MoreVertIcon fontSize="inherit" />
                </IconButton>
            </ListItemButton>
            <Menu anchorEl={anchorEl} open={open} onClose={handleMenuClose}>
                <MenuItem onClick={handleDelete} sx={{color: 'error.main'}}>Delete Chat</MenuItem>
            </Menu>
        </ListItem>
    );
};

const ChatHistoryPanel = ({
  sessions,
  activeSessionId,
  onSessionSelect,
  onNewChat,
  onDeleteSession,
  isLoading,
  mobileOpen, // New prop for mobile drawer state
  onMobileClose, // New prop for closing mobile drawer
}) => {
  const theme = useTheme();
  const drawerWidth = 280;

  // --- [THE REFACTOR IS HERE: REUSABLE CONTENT] ---
  // Define the content once, so we can render it in both the mobile drawer and desktop panel.
  const historyContent = (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      <Box sx={{ p: 2, borderBottom: 1, borderColor: 'divider' }}>
        <Button fullWidth variant="outlined" startIcon={<AddCommentOutlined />} onClick={onNewChat}>
          New Chat
        </Button>
      </Box>
      <Box sx={{ flexGrow: 1, overflowY: 'auto' }}>
        {isLoading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
            <CircularProgress />
          </Box>
        ) : (
          <List>
            {sessions.map((session) => (
              <HistoryItem
                key={session.id}
                session={session}
                active={session.id === activeSessionId}
                onSelect={(sessionId) => {
                    onSessionSelect(sessionId);
                    onMobileClose(); // Also close drawer on selection
                }}
                onDelete={onDeleteSession}
              />
            ))}
          </List>
        )}
      </Box>
    </Box>
  );
  // --- [END OF REFACTOR] ---

  return (
    <Box
      component="nav"
      sx={{ width: { md: drawerWidth }, flexShrink: { md: 0 } }}
    >
      {/* --- MOBILE DRAWER --- */}
      <Drawer
        variant="temporary"
        open={mobileOpen}
        onClose={onMobileClose}
        ModalProps={{ keepMounted: true }}
        sx={{
          display: { xs: 'block', md: 'none' },
          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
        }}
      >
        {historyContent}
      </Drawer>

      {/* --- DESKTOP PANEL --- */}
      <Box
        sx={{
          display: { xs: 'none', md: 'flex' },
          height: '100%',
          width: drawerWidth,
          borderRight: 1,
          borderColor: 'divider',
        }}
      >
        {historyContent}
      </Box>
    </Box>
  );
};

export default ChatHistoryPanel;

--- File: .\ata-frontend\src\components\chatbot\ChatInput.jsx ---

// /ata-frontend/src/components/chatbot/ChatInput.jsx

import React, { useState, useRef } from 'react';
import { Box, TextField, IconButton, InputAdornment, Stack, Button } from '@mui/material';

import SendOutlined from '@mui/icons-material/SendOutlined';
import AttachFileOutlined from '@mui/icons-material/AttachFileOutlined';
import StopCircleOutlined from '@mui/icons-material/StopCircleOutlined';

/**
 * A controlled component that provides a text input, file attachment,
 * and submit button for the chat.
 *
 * @param {object} props
 * @param {function} props.onSendMessage - Callback to send a message.
 * @param {boolean} props.disabled - Whether the input and button should be disabled.
 * @param {boolean} props.isResponding - Whether the bot is currently streaming a response.
 * @param {function} props.onStopGeneration - Callback to stop the bot's streaming response.
 * @param {function} props.onFileUpload - Callback to handle file selection.
 */
const ChatInput = ({ onSendMessage, disabled, isResponding, onStopGeneration, onFileUpload }) => {
  const [text, setText] = useState('');
  const fileInputRef = useRef(null);

  const handleSubmit = (event) => {
    event.preventDefault();
    const trimmedText = text.trim();
    if (trimmedText && !disabled) {
      onSendMessage(trimmedText);
      setText('');
    }
  };

  const handleKeyDown = (event) => {
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      handleSubmit(event);
    }
  };

  const handleFileIconClick = () => {
    fileInputRef.current.click();
  };

  const handleFileChange = (event) => {
    const file = event.target.files[0];
    if (file) {
      onFileUpload(file);
    }
    // Reset the input value to allow uploading the same file again
    event.target.value = null;
  };

  return (
    <Box sx={{ p: 2, flexShrink: 0, bgcolor: 'background.paper', borderTop: 1, borderColor: 'divider' }}>
      <form onSubmit={handleSubmit} noValidate>
        <Stack spacing={1}>
          {/* Conditionally render the "Stop Generating" button */}
          {isResponding && (
            <Button
              variant="outlined"
              size="small"
              startIcon={<StopCircleOutlined />}
              onClick={onStopGeneration}
              sx={{ alignSelf: 'center' }}
            >
              Stop Generating
            </Button>
          )}
          <TextField
            fullWidth
            multiline
            maxRows={5}
            value={text}
            onChange={(e) => setText(e.target.value)}
            onKeyDown={handleKeyDown}
            disabled={disabled}
            placeholder={disabled ? "ATA is thinking..." : "Ask a question, or attach a file..."}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <IconButton onClick={handleFileIconClick} disabled={disabled} aria-label="attach file">
                    <AttachFileOutlined />
                  </IconButton>
                  <input
                    type="file"
                    ref={fileInputRef}
                    onChange={handleFileChange}
                    style={{ display: 'none' }}
                    accept=".pdf,.docx,.png,.jpeg,.jpg"
                  />
                </InputAdornment>
              ),
              endAdornment: (
                <InputAdornment position="end" sx={{ alignSelf: 'flex-end', mb: 1 }}>
                  <IconButton
                    type="submit"
                    disabled={!text.trim() || disabled}
                    color="primary"
                    aria-label="send message"
                  >
                    <SendOutlined />
                  </IconButton>
                </InputAdornment>
              ),
            }}
          />
        </Stack>
      </form>
    </Box>
  );
};

export default ChatInput;

--- File: .\ata-frontend\src\components\chatbot\ExamplePrompts.jsx ---

// /ata-frontend/src/components/chatbot/ExamplePrompts.jsx

import React from 'react';
import { Box, Typography, Grid, Card, CardActionArea } from '@mui/material';

// The static data for the prompts. In V2, this could come from an API.
const prompts = [
  "List all students in my '10th Grade World History' class.",
  "What was the class average on the 'Mid-Term Biology Exam'?",
  "Show me students who scored below 70% on the 'Chapter 5 Quiz'.",
  "Which student has the highest overall grade in '11th Grade Physics'?",
];

/**
 * A UI component that displays a grid of clickable example prompts
 * to help guide the user.
 *
 * @param {object} props
 * @param {function} props.onPromptClick - Callback function invoked when a prompt is clicked.
 */
const ExamplePrompts = ({ onPromptClick }) => {
  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h4" color="text.secondary" sx={{ mb: 2, fontWeight: 500 }}>
        Not sure where to start? Try one of these:
      </Typography>
      <Grid container spacing={2}>
        {prompts.map((prompt, index) => (
          <Grid item xs={12} md={6} key={index}>
            <Card
              variant="outlined"
              sx={{
                height: '100%',
                borderColor: 'divider',
                transition: 'border-color 300ms ease, box-shadow 300ms ease',
                '&:hover': {
                  borderColor: 'primary.main',
                  boxShadow: 2,
                },
              }}
            >
              <CardActionArea
                onClick={() => onPromptClick(prompt)}
                sx={{ p: 2, height: '100%' }}
              >
                <Typography variant="body1" color="text.primary">
                  {prompt}
                </Typography>
              </CardActionArea>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};

export default ExamplePrompts;

--- File: .\ata-frontend\src\components\chatbot\MessageList.jsx ---

// /ata-frontend/src/components/chatbot/MessageList.jsx (DEFINITIVELY CORRECTED)

import React, { useEffect, useRef, memo } from 'react';
import { Box, Stack, Typography, Avatar } from '@mui/material';
import { styled } from '@mui/material/styles';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';

import SmartToyOutlined from '@mui/icons-material/SmartToyOutlined';
import { useAuth } from '../../hooks/useAuth';

// --- Sub-Components (These are correct and need no changes) ---
const ThinkingIndicator = () => (
  <Stack direction="row" spacing={1.5} alignItems="center">
    <Avatar sx={{ width: 40, height: 40, bgcolor: 'secondary.light', color: 'primary.main' }}><SmartToyOutlined /></Avatar>
    <Box sx={{ p: '12px 16px', bgcolor: 'background.paper', borderRadius: 4, display: 'flex', gap: '6px', border: '1px solid', borderColor: 'divider' }}>
      <TypingDot delay="0s" />
      <TypingDot delay="0.2s" />
      <TypingDot delay="0.4s" />
    </Box>
  </Stack>
);

const TypingDot = styled('div')(({ theme, delay }) => ({ /* ...styles... */ }));
const BlinkingCursor = styled('span')({ /* ...styles... */ });


// --- MessageBubble Component (THIS IS WHERE THE FIX IS) ---
const MessageBubble = memo(({ message }) => {
  const { user } = useAuth();
  
  // --- [THE FIX - STEP 1: Use 'role' instead of 'author'] ---
  const isBot = message.role === 'bot';
  // --- [END OF FIX] ---

  return (
    <Stack
      direction="row"
      spacing={2}
      sx={{
        justifyContent: isBot ? 'flex-start' : 'flex-end',
        width: '100%',
      }}
    >
      {isBot && (
        <Avatar sx={{ width: 40, height: 40, bgcolor: 'secondary.light', color: 'primary.main' }}>
          <SmartToyOutlined />
        </Avatar>
      )}
      <Box
        sx={{
          p: '12px 16px',
          bgcolor: isBot ? 'background.paper' : 'primary.main',
          color: isBot ? 'text.primary' : 'primary.contrastText',
          borderRadius: 4,
          border: isBot ? '1px solid' : 'none',
          borderColor: 'divider',
          maxWidth: '80%',
        }}
      >
        <Box className="markdown-body">
          <ReactMarkdown
            remarkPlugins={[remarkGfm]}
            components={{
              code({ node, inline, className, children, ...props }) {
                const match = /language-(\w+)/.exec(className || '');
                return !inline && match ? (
                  <SyntaxHighlighter style={vscDarkPlus} language={match[1]} PreTag="div" {...props}>
                    {String(children).replace(/\n$/, '')}
                  </SyntaxHighlighter>
                ) : (
                  <code className={className} {...props}>{children}</code>
                );
              },
              p: ({node, ...props}) => <Typography variant="body1" component="p" {...props} />,
              li: ({node, ...props}) => <li><Typography variant="body1" component="span" {...props} /></li>,
            }}
          >
            {/* --- [THE FIX - STEP 2: Use 'content' instead of 'text'] --- */}
            {message.content}
            {/* --- [END OF FIX] --- */}
          </ReactMarkdown>
          {message.isStreaming && <BlinkingCursor />}
        </Box>
      </Box>
      {!isBot && (
        <Avatar sx={{ width: 40, height: 40, bgcolor: 'primary.main' }}>
          {user?.name?.charAt(0) || 'U'}
        </Avatar>
      )}
    </Stack>
  );
});


// --- Main MessageList Component (This is correct and needs no changes) ---
const MessageList = ({ messages, isThinking, children }) => {
  const scrollRef = useRef(null);

  useEffect(() => {
    scrollRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages, isThinking]);

  return (
    <Box sx={{ flexGrow: 1, overflowY: 'auto', p: 2 }}>
      <Stack spacing={3}>
        {children}
        {messages.map((msg) => (
          <MessageBubble key={msg.id} message={msg} />
        ))}
        {isThinking && <ThinkingIndicator />}
        <div ref={scrollRef} />
      </Stack>
    </Box>
  );
};

export default MessageList;

--- File: .\ata-frontend\src\components\classes\AddClassModal.jsx ---

// /src/components/classes/AddClassModal.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import {
  Dialog, DialogTitle, DialogContent, DialogActions, Button, Stack, TextField,
  Tabs, Tab, Box, Typography, IconButton, CircularProgress, Alert
} from '@mui/material';
import CloseOutlined from '@mui/icons-material/CloseOutlined';
import FileUploadOutlined from '@mui/icons-material/FileUploadOutlined';
import DescriptionOutlined from '@mui/icons-material/DescriptionOutlined';

const TabPanel = ({ children, value, index }) => (
  <div role="tabpanel" hidden={value !== index}>
    {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
  </div>
);

const FileUploadZone = ({ file, setFile, isLoading }) => {
  const onDrop = useCallback(acceptedFiles => {
    if (acceptedFiles.length > 0) setFile(acceptedFiles[0]);
  }, [setFile]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop, maxFiles: 1, disabled: isLoading,
    accept: { // <<< THE CRITICAL FIX IS HERE
      'image/jpeg': [],
      'image/png': [],
      'application/pdf': [],
      'application/msword': ['.doc'],
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'application/vnd.ms-excel': ['.xls'],
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
      'text/csv': ['.csv'],
    }
  });

  if (file) {
    return (
      <Box sx={{ p: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1, display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        <Box sx={{ display: 'flex', alignItems: 'center', overflow: 'hidden' }}>
          <DescriptionOutlined color="action" />
          <Typography noWrap sx={{ ml: 1.5 }}>{file.name}</Typography>
        </Box>
        <Button size="small" onClick={() => setFile(null)} disabled={isLoading}>Clear</Button>
      </Box>
    );
  }

  return (
    <Box {...getRootProps()} sx={{ p: 4, border: '2px dashed', borderColor: isDragActive ? 'primary.main' : 'divider', borderRadius: 1, textAlign: 'center', cursor: 'pointer', backgroundColor: isDragActive ? 'action.hover' : 'transparent', opacity: isLoading ? 0.5 : 1 }}>
      <input {...getInputProps()} />
      <FileUploadOutlined sx={{ fontSize: 48, color: 'text.secondary', mb: 1 }} />
      <Typography>Drag & drop your roster file</Typography>
      <Typography color="text.secondary">or click to select a file</Typography>
    </Box>
  );
};

const AddClassModal = ({ open, onClose, onSubmit, isLoading, error }) => {
  const [activeTab, setActiveTab] = useState(0);
  const [className, setClassName] = useState('');
  const [description, setDescription] = useState('');
  const [file, setFile] = useState(null);

  useEffect(() => {
    if (!open) {
      const timer = setTimeout(() => {
        setActiveTab(0);
        setClassName('');
        setDescription('');
        setFile(null);
      }, 300);
      return () => clearTimeout(timer);
    }
  }, [open]);

  const handleTabChange = (event, newValue) => setActiveTab(newValue);
  const handleSubmit = (event) => {
    event.preventDefault();
    onSubmit({ name: className, description, file });
  };

  const isSubmitDisabled = isLoading || (activeTab === 0 ? className.trim() === '' : className.trim() === '' || file === null);

  return (
    <Dialog open={open} onClose={onClose} fullWidth maxWidth="sm" disableEscapeKeyDown={isLoading}>
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        Add New Class
        <IconButton aria-label="close" onClick={onClose} disabled={isLoading}><CloseOutlined /></IconButton>
      </DialogTitle>
      <form onSubmit={handleSubmit}>
        <DialogContent>
          {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
          <Tabs value={activeTab} onChange={handleTabChange} centered>
            <Tab label="Create Manually" disabled={isLoading} />
            <Tab label="Upload Roster" disabled={isLoading} />
          </Tabs>
          <TabPanel value={activeTab} index={0}>
            <Stack spacing={3}>
              <TextField autoFocus required name="classNameManual" label="Class Name" value={className} onChange={(e) => setClassName(e.target.value)} fullWidth disabled={isLoading} />
              <TextField name="description" label="Description (Optional)" value={description} onChange={(e) => setDescription(e.target.value)} fullWidth multiline rows={3} disabled={isLoading} />
            </Stack>
          </TabPanel>
          <TabPanel value={activeTab} index={1}>
            <Stack spacing={3}>
              <TextField required name="classNameUpload" label="Class Name" value={className} onChange={(e) => setClassName(e.target.value)} fullWidth disabled={isLoading} />
              <FileUploadZone file={file} setFile={setFile} isLoading={isLoading} />
            </Stack>
          </TabPanel>
        </DialogContent>
        <DialogActions sx={{ p: 3 }}>
          <Button onClick={onClose} variant="outlined" disabled={isLoading}>Cancel</Button>
          <Button type="submit" variant="contained" disabled={isSubmitDisabled} startIcon={isLoading ? <CircularProgress size={20} color="inherit" /> : null}>
            {activeTab === 0 ? 'Create Class' : 'Create & Upload'}
          </Button>
        </DialogActions>
      </form>
    </Dialog>
  );
};

export default AddClassModal;

--- File: .\ata-frontend\src\components\classes\ClassCard.jsx ---

// /src/components/classes/ClassCard.jsx

// --- Core React & Router Imports ---
import React from 'react';
import { useNavigate } from 'react-router-dom';

// --- MUI Component Imports ---
import { Grid, Card, CardActionArea, Typography, Box } from '@mui/material';

// --- Icon Imports ---
import PeopleAltOutlined from '@mui/icons-material/PeopleAltOutlined';
import SchoolOutlined from '@mui/icons-material/SchoolOutlined';

/**
 * A presentational card component that displays summary information for a single class
 * and navigates to the class details page on click.
 *
 * @param {object} props
 * @param {object} props.classData - The data object for the class to display.
 */
const ClassCard = ({ classData }) => {
  const navigate = useNavigate();

  // The handler for when the user clicks anywhere on the card's interactive area.
  const handleCardClick = () => {
    navigate(`/classes/${classData.id}`);
  };

  return (
    // This component defines its own responsive grid behavior.
    <Grid item xs={12} sm={6} md={4} lg={3}>
      <Card
        sx={{
          minHeight: 200,
          position: 'relative', // Establishes a positioning context for the background icon.
          overflow: 'hidden',   // Prevents the large icon from overflowing the card's rounded corners.
        }}
      >
        <CardActionArea
          onClick={handleCardClick}
          sx={{
            height: '100%',
            p: 3, // 24px padding.
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'space-between', // Pushes content to the top and bottom.
            alignItems: 'flex-start', // Aligns content to the left.
          }}
        >
          {/* --- Top Content: The Class Name --- */}
          <Box>
            <Typography variant="h3">{classData.name}</Typography>
          </Box>

          {/* --- Bottom Content: The Student Count --- */}
          <Box sx={{ display: 'flex', alignItems: 'center', color: 'text.secondary', zIndex: 1 }}>
            <PeopleAltOutlined sx={{ fontSize: '1rem', mr: 1 }} />
            <Typography variant="body1" component="span">
              {classData.studentCount} Students
            </Typography>
          </Box>
        </CardActionArea>

        {/* --- Decorative Background Icon --- */}
        {/* This icon sits behind the content to add visual flair without clutter. */}
        <SchoolOutlined
          sx={{
            position: 'absolute',
            right: 16,
            bottom: 16,
            fontSize: 96,
            color: 'action.hover', // Uses a very light, theme-aware gray.
            zIndex: 0, // Ensures it is behind the text content.
            transform: 'rotate(-15deg)', // Adds a slight rotation for style.
          }}
        />
      </Card>
    </Grid>
  );
};

export default ClassCard;

--- File: .\ata-frontend\src\components\classes\ClassEditModal.jsx ---

// /src/components/classes/ClassEditModal.jsx

// --- Core React Imports ---
import React, { useState, useEffect } from 'react';

// --- MUI Component Imports ---
import { Dialog, DialogTitle, DialogContent, DialogActions, TextField, Button, Stack, IconButton, CircularProgress, Alert } from '@mui/material';

// --- Icon Imports ---
import CloseOutlined from '@mui/icons-material/CloseOutlined';

/**
 * A controlled modal component for editing an existing class's details.
 * It is a near-copy of the StudentModal, demonstrating a reusable pattern.
 *
 * @param {object} props
 * @param {boolean} props.open - Controls whether the modal is visible.
 * @param {function} props.onClose - Callback to close the modal.
 * @param {function} props.onSubmit - Async callback to handle form submission.
 * @param {object|null} props.initialData - The current class data for pre-filling the form.
 * @param {boolean} props.isLoading - Whether a submission is in progress.
 * @param {string|null} props.error - An error message from a failed submission.
 */
const ClassEditModal = ({ open, onClose, onSubmit, initialData, isLoading, error }) => {
  // --- Internal State Management for Form Fields ---
  const [formData, setFormData] = useState({ name: '', description: '' });

  // --- Side Effect to Synchronize Form State ---
  // This populates the form with the current class data when the modal opens.
  useEffect(() => {
    if (open && initialData) {
      setFormData({ 
        name: initialData.name || '', 
        description: initialData.description || '' 
      });
    }
  }, [open, initialData]);

  // --- Event Handlers ---
  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    onSubmit(formData);
  };

  // --- Real-time Client-Side Validation ---
  const isFormValid = formData.name.trim() !== '';

  return (
    <Dialog open={open} onClose={onClose} fullWidth maxWidth="sm" disableEscapeKeyDown={isLoading}>
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        Edit Class Details
        <IconButton aria-label="close" onClick={onClose} disabled={isLoading}>
          <CloseOutlined />
        </IconButton>
      </DialogTitle>
      
      <form onSubmit={handleSubmit}>
        <DialogContent>
          <Stack spacing={3} sx={{ pt: 1 }}>
            {error && <Alert severity="error">{error}</Alert>}
            
            <TextField
              autoFocus
              required
              id="name"
              name="name"
              label="Class Name"
              type="text"
              fullWidth
              value={formData.name}
              onChange={handleChange}
              disabled={isLoading}
            />
            <TextField
              id="description"
              name="description"
              label="Description (Optional)"
              multiline
              rows={4}
              fullWidth
              value={formData.description}
              onChange={handleChange}
              disabled={isLoading}
            />
          </Stack>
        </DialogContent>
        <DialogActions sx={{ p: 3 }}>
          <Button onClick={onClose} variant="outlined" disabled={isLoading}>Cancel</Button>
          <Button
            type="submit"
            variant="contained"
            disabled={!isFormValid || isLoading}
            startIcon={isLoading ? <CircularProgress size={20} color="inherit" /> : null}
          >
            Save Changes
          </Button>
        </DialogActions>
      </form>
    </Dialog>
  );
};

export default ClassEditModal;

--- File: .\ata-frontend\src\components\classes\StudentModal.jsx ---

// /src/components/classes/StudentModal.jsx

// --- Core React Imports ---
import React, { useState, useEffect } from 'react';

// --- MUI Component Imports ---
import { Dialog, DialogTitle, DialogContent, DialogActions, TextField, Button, Stack, IconButton, CircularProgress, Alert } from '@mui/material';

// --- Icon Imports ---
import CloseOutlined from '@mui/icons-material/CloseOutlined';

/**
 * A controlled modal component for adding a new student or editing an existing one.
 * It manages its own form state but is controlled by its parent for visibility,
 * submission logic, and loading/error states.
 *
 * @param {object} props
 * @param {boolean} props.open - Controls whether the modal is visible.
 * @param {function} props.onClose - Callback to close the modal.
 * @param {function} props.onSubmit - Async callback to handle form submission.
 * @param {'add' | 'edit'} props.mode - Determines the modal's behavior and titles.
 * @param {object|null} props.initialData - Student data for pre-filling the form in 'edit' mode.
 * @param {boolean} props.isLoading - Whether a submission is in progress.
 * @param {string|null} props.error - An error message from a failed submission.
 */
const StudentModal = ({ open, onClose, onSubmit, mode, initialData, isLoading, error }) => {
  // --- Internal State Management for Form Fields ---
  const [formData, setFormData] = useState({ name: '', studentId: '' });

  // --- Side Effect to Synchronize Form State ---
  // This useEffect hook runs whenever the modal's 'open' status changes.
  // It correctly populates the form when opening in 'edit' mode, and clears
  // it for 'add' mode, ensuring the form is always in the correct state.
  useEffect(() => {
    if (open) { // Only run this logic when the modal is opened.
      if (mode === 'edit' && initialData) {
        setFormData({ name: initialData.name, studentId: initialData.studentId });
      } else {
        setFormData({ name: '', studentId: '' });
      }
    }
  }, [open, mode, initialData]); // Dependencies for the effect.

  // --- Event Handlers ---
  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = (event) => {
    event.preventDefault(); // Prevent default browser form submission.
    onSubmit(formData);    // Delegate the submission logic to the parent component.
  };

  // --- Real-time Client-Side Validation ---
  const isFormValid = formData.name.trim() !== '' && formData.studentId.trim() !== '';

  return (
    <Dialog open={open} onClose={onClose} fullWidth maxWidth="sm" disableEscapeKeyDown={isLoading}>
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        {mode === 'add' ? 'Add New Student' : 'Edit Student Details'}
        <IconButton aria-label="close" onClick={onClose} disabled={isLoading}>
          <CloseOutlined />
        </IconButton>
      </DialogTitle>
      
      {/* The form tag enables submission via the 'Enter' key. */}
      <form onSubmit={handleSubmit}>
        <DialogContent>
          <Stack spacing={3} sx={{ pt: 1 }}>
            {/* Display any submission error passed down from the parent. */}
            {error && <Alert severity="error">{error}</Alert>}
            
            <TextField
              autoFocus // Automatically focus the first field when the modal opens.
              required
              id="name"
              name="name" // The 'name' must match the key in the formData state.
              label="Student Full Name"
              type="text"
              fullWidth
              value={formData.name}
              onChange={handleChange}
              disabled={isLoading}
            />
            <TextField
              required
              id="studentId"
              name="studentId"
              label="Student ID Number"
              type="text"
              fullWidth
              value={formData.studentId}
              onChange={handleChange}
              disabled={isLoading}
            />
          </Stack>
        </DialogContent>
        <DialogActions sx={{ p: 3 }}>
          <Button onClick={onClose} variant="outlined" disabled={isLoading}>Cancel</Button>
          <Button
            type="submit"
            variant="contained"
            disabled={!isFormValid || isLoading}
            startIcon={isLoading ? <CircularProgress size={20} color="inherit" /> : null}
          >
            {/* The button text dynamically changes based on the mode. */}
            {mode === 'add' ? 'Add Student' : 'Save Changes'}
          </Button>
        </DialogActions>
      </form>
    </Dialog>
  );
};

export default StudentModal;

--- File: .\ata-frontend\src\components\classes\StudentTable.jsx ---

// /src/components/classes/StudentTable.jsx

// --- Core React Import ---
import React from 'react';
import { useNavigate } from 'react-router-dom';

// --- MUI Component Imports ---
import { Box, Card, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Typography, IconButton, Tooltip, useTheme } from '@mui/material';

// --- Icon Imports ---
import EditOutlined from '@mui/icons-material/EditOutlined';
import DeleteOutlineOutlined from '@mui/icons-material/DeleteOutlineOutlined';
import PersonAddOutlined from '@mui/icons-material/PersonAddOutlined';
import VisibilityOutlined from '@mui/icons-material/VisibilityOutlined';

/**
 * A purely presentational component that renders a table of students.
 * It receives the student data and action handlers for editing and deleting as props.
 * It is a "dumb" component that only knows how to display data and delegate events.
 *
 * @param {object} props
 * @param {Array<object>} props.students - The list of student objects to display.
 * @param {function} props.onEdit - Callback function for when the edit button is clicked.
 * @param {function} props.onDelete - Callback function for when the delete button is clicked.
 */
const StudentTable = ({ students, onEdit, onDelete }) => {
  const theme = useTheme();
  const navigate = useNavigate();

  /**
   * A helper function to determine the text color for a grade based on its value.
   * This encapsulates presentational logic within the component.
   */
  const getGradeColor = (grade) => {
    if (grade >= 85) return theme.palette.success.dark;
    if (grade < 70) return theme.palette.error.dark;
    return theme.palette.text.primary;
  };

  // --- Conditional Rendering for the Empty State ---
  // If the students array is empty, we render a helpful message instead of an empty table.
  if (!students || students.length === 0) {
    return (
      <Card>
        <Box sx={{ textAlign: 'center', p: 8 }}>
          <PersonAddOutlined sx={{ fontSize: 64, color: 'text.secondary', mb: 2 }} />
          <Typography variant="h3" gutterBottom>
            No Students in this Class
          </Typography>
          <Typography color="text.secondary">
            Get started by clicking the "Add Student" button to build your roster.
          </Typography>
        </Box>
      </Card>
    );
  }

  return (
    <Card>
      <TableContainer>
        <Table aria-label="student roster table">
          {/* --- Table Header --- */}
          <TableHead sx={{ backgroundColor: theme.palette.grey[100] }}>
            <TableRow>
              <TableCell sx={{ fontWeight: 600 }}>Student Name</TableCell>
              <TableCell sx={{ fontWeight: 600 }}>Student ID</TableCell>
              <TableCell sx={{ fontWeight: 600 }}>Overall Grade</TableCell>
              <TableCell sx={{ fontWeight: 600 }} align="right">Actions</TableCell>
            </TableRow>
          </TableHead>

          {/* --- Table Body --- */}
          <TableBody>
            {students.map((student) => (
              <TableRow
                key={student.id} // The key is critical for React's rendering performance.
                hover // Adds a hover effect to the row.
                sx={{ '&:last-child td, &:last-child th': { border: 0 } }}
              >
                <TableCell component="th" scope="row">
                  <Typography variant="body1">{student.name}</Typography>
                </TableCell>
                <TableCell>
                  <Typography variant="body2" color="text.secondary">{student.studentId}</Typography>
                </TableCell>
                <TableCell>
                  <Typography variant="body1" sx={{ fontWeight: 600, color: getGradeColor(student.overallGrade || 0) }}>
                    {/* The || 0 handles cases where a new student may not have a grade yet. */}
                    {student.overallGrade || 0}% 
                  </Typography>
                </TableCell>
                <TableCell align="right">
                  {/* --- Action Delegation Buttons --- */}
                  <Tooltip title="View Profile">
                    <IconButton onClick={() => navigate(`/students/${student.id}`)} aria-label={`view ${student.name} profile`}>
                      <VisibilityOutlined fontSize="small" />
                    </IconButton>
                  </Tooltip>
                  <Tooltip title="Edit Student">
                    {/* The onClick handler calls the onEdit prop, passing the specific student object up. */}
                    <IconButton onClick={() => onEdit(student)} aria-label={`edit ${student.name}`}>
                      <EditOutlined fontSize="small" />
                    </IconButton>
                  </Tooltip>
                  <Tooltip title="Remove Student">
                    <IconButton onClick={() => onDelete(student)} aria-label={`remove ${student.name}`}>
                      <DeleteOutlineOutlined fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Card>
  );
};

export default StudentTable;

--- File: .\ata-frontend\src\components\common\ConfirmationModal.jsx ---

// /src/components/common/ConfirmationModal.jsx

import React from 'react';
import { Dialog, DialogTitle, DialogContent, DialogContentText, DialogActions, Button } from '@mui/material';

/**
 * A generic, reusable modal for confirming a user action.
 *
 * @param {object} props
 * @param {boolean} props.open - Controls whether the modal is visible.
 * @param {function} props.onClose - Callback to close the modal (e.g., clicking Cancel).
 * @param {function} props.onConfirm - Callback to execute when the confirm button is clicked.
 * @param {string} props.title - The title to display in the modal header.
 * @param {string} props.description - The descriptive text/question for the modal body.
 */
const ConfirmationModal = ({ open, onClose, onConfirm, title, description }) => {
  return (
    <Dialog
      open={open}
      onClose={onClose}
      aria-labelledby="confirmation-dialog-title"
      aria-describedby="confirmation-dialog-description"
    >
      <DialogTitle id="confirmation-dialog-title">
        {title}
      </DialogTitle>
      <DialogContent>
        <DialogContentText id="confirmation-dialog-description">
          {description}
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose} variant="outlined">
          Cancel
        </Button>
        <Button onClick={onConfirm} color="error" variant="contained" autoFocus>
          Confirm
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default ConfirmationModal;

--- File: .\ata-frontend\src\components\common\ErrorBoundary.jsx ---

// /src/components/common/ErrorBoundary.jsx

import React from 'react';
import { Box, Typography, Button, Container, Paper } from '@mui/material';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log error to console in development
    console.error('Error caught by boundary:', error, errorInfo);

    // Store error details in state
    this.state = {
      hasError: true,
      error,
      errorInfo
    };
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
    window.location.href = '/';
  };

  render() {
    if (this.state.hasError) {
      return (
        <Container maxWidth="md" sx={{ mt: 8 }}>
          <Paper
            elevation={3}
            sx={{
              p: 4,
              textAlign: 'center',
              borderTop: '4px solid',
              borderColor: 'error.main'
            }}
          >
            <ErrorOutlineIcon sx={{ fontSize: 80, color: 'error.main', mb: 2 }} />

            <Typography variant="h4" gutterBottom fontWeight="bold">
              Oops! Something went wrong
            </Typography>

            <Typography variant="body1" color="text.secondary" paragraph>
              We're sorry for the inconvenience. The application encountered an unexpected error.
            </Typography>

            <Box sx={{ my: 3 }}>
              <Button
                variant="contained"
                size="large"
                onClick={this.handleReset}
                sx={{ mr: 2 }}
              >
                Go to Home
              </Button>
              <Button
                variant="outlined"
                size="large"
                onClick={() => window.location.reload()}
              >
                Reload Page
              </Button>
            </Box>

            {process.env.NODE_ENV === 'development' && this.state.error && (
              <Box
                sx={{
                  mt: 4,
                  p: 2,
                  bgcolor: 'grey.100',
                  borderRadius: 1,
                  textAlign: 'left',
                  overflow: 'auto'
                }}
              >
                <Typography variant="subtitle2" fontWeight="bold" gutterBottom>
                  Error Details (Development Only):
                </Typography>
                <Typography variant="body2" component="pre" sx={{ whiteSpace: 'pre-wrap' }}>
                  {this.state.error.toString()}
                </Typography>
                {this.state.errorInfo && (
                  <Typography variant="body2" component="pre" sx={{ whiteSpace: 'pre-wrap', mt: 1 }}>
                    {this.state.errorInfo.componentStack}
                  </Typography>
                )}
              </Box>
            )}
          </Paper>
        </Container>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;


--- File: .\ata-frontend\src\components\common\FileUploadZone.jsx ---

// /src/components/common/FileUploadZone.jsx
import React, { useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { Box, Typography } from '@mui/material';
import FileUploadOutlined from '@mui/icons-material/FileUploadOutlined';

const FileUploadZone = ({ onDrop, accept, disabled }) => {
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept,
    disabled,
  });

  return (
    <Box
      {...getRootProps()}
      sx={{
        p: 4,
        border: '2px dashed',
        borderColor: isDragActive ? 'primary.main' : 'divider',
        borderRadius: 1,
        textAlign: 'center',
        cursor: 'pointer',
        backgroundColor: isDragActive ? 'action.hover' : 'transparent',
        opacity: disabled ? 0.5 : 1,
        transition: 'border-color 0.3s, background-color 0.3s',
      }}
    >
      <input {...getInputProps()} />
      <FileUploadOutlined sx={{ fontSize: 48, color: 'text.secondary', mb: 1 }} />
      <Typography>Drag & drop files here</Typography>
      <Typography color="text.secondary">or click to select files</Typography>
    </Box>
  );
};

export default FileUploadZone;

--- File: .\ata-frontend\src\components\common\Header.jsx ---

// /src/components/common/Header.jsx (FINAL, SECURE, SUPERVISOR-APPROVED VERSION)

// --- Core React Imports ---
import React, { useState } from 'react';
// Import the useNavigate hook to redirect to the login page.
import { useNavigate } from 'react-router-dom'; 

// --- MUI Component Imports ---
import {
  AppBar, Toolbar, IconButton, Typography, Box,
  Menu, MenuItem, Tooltip, ListItemIcon, Button, // Added Button for Login
} from '@mui/material';

// --- [CRITICAL MODIFICATION 1/4: IMPORT HOOKS & ICONS] ---
// Import our custom hooks to consume global state.
import { useAuth } from '../../hooks/useAuth';
import { useThemeMode } from '../../hooks/useThemeMode';

// --- Icon Imports ---
import MenuIcon from '@mui/icons-material/Menu';
import AccountCircleOutlined from '@mui/icons-material/AccountCircleOutlined';
import Brightness4Icon from '@mui/icons-material/Brightness4';
import Brightness7Icon from '@mui/icons-material/Brightness7';
import Logout from '@mui/icons-material/Logout'; // Added Logout icon

/**
 * The application's top-level context bar.
 * This component is now fully dynamic and context-aware. It renders different
 * content based on whether a user is authenticated.
 */
const Header = ({ onDrawerToggle, desktopSidebarWidth }) => {
  // --- Hook Initialization ---
  const [anchorEl, setAnchorEl] = useState(null);
  const isMenuOpen = Boolean(anchorEl);
  const navigate = useNavigate();

  // --- [CRITICAL MODIFICATION 2/4: CONSUME AUTH CONTEXT] ---
  // Consume the global authentication state. This is the key to making the
  // Header dynamic. We get the user object, a flag to know if they're authenticated,
  // and the logout function.
  const { user, isAuthenticated, logout } = useAuth();
  const { mode, toggleThemeMode } = useThemeMode();

  // --- Event Handlers (Unchanged, but `handleLogout` is new) ---
  const handleProfileMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };
  
  const handleThemeToggle = () => {
    toggleThemeMode();
    handleMenuClose();
  };
  
  // --- [CRITICAL MODIFICATION 3/4: IMPLEMENT LOGOUT HANDLER] ---
  const handleLogout = () => {
    logout();      // Call the function from our useAuth context.
    handleMenuClose(); // Close the menu.
  };

  return (
    <>
      <AppBar
        position="fixed"
        sx={{
          // Styling logic remains the same.
          width: { md: `calc(100% - ${desktopSidebarWidth}px)` },
          ml: { md: `${desktopSidebarWidth}px` },
          boxShadow: 'none',
          backgroundColor: 'background.paper', // Changed to paper for better contrast
          borderBottom: '1px solid',
          borderColor: 'divider',
          transition: (theme) => theme.transitions.create(['width', 'margin'], {
            easing: theme.transitions.easing.sharp,
            duration: theme.transitions.duration.enteringScreen,
          }),
        }}
      >
        <Toolbar>
          <IconButton
            color="default" // Changed to inherit to match theme text color
            aria-label="open drawer"
            edge="start"
            onClick={onDrawerToggle}
            sx={{ mr: 2, display: { md: 'none' } }}
          >
            <MenuIcon />
          </IconButton>

          {/* This spacer pushes all content to the right */}
          <Box sx={{ flexGrow: 1 }} />
          
          {/* --- [CRITICAL MODIFICATION 4/4: CONDITIONAL RENDERING] --- */}
          {isAuthenticated ? (
            // --- RENDER THIS IF THE USER IS AUTHENTICATED ---
            <Tooltip title="Account settings">
              <IconButton
                size="large"
                edge="end"
                onClick={handleProfileMenuOpen}
                color="default"
              >
                <Typography variant="button" sx={{ display: { xs: 'none', sm: 'block' }, color: 'text.primary', mr: 1 }}>
                  {/* Display the user's actual email or name */}
                  {user?.fullName || user?.email || 'User'}
                </Typography>
                <AccountCircleOutlined />
              </IconButton>
            </Tooltip>
          ) : (
            // --- RENDER THIS IF THE USER IS NOT AUTHENTICATED ---
            // This is a defensive UI. Users will likely be redirected before they
            // can see this, but it's good practice to have a clear login prompt.
            <Button color="inherit" onClick={() => navigate('/login')}>
              Login
            </Button>
          )}

        </Toolbar>
      </AppBar>

      {/* --- MENU MODIFICATION --- */}
      {/* The Menu is still here, but now its items are more dynamic. */}
      <Menu
        id="primary-account-menu"
        anchorEl={anchorEl}
        open={isMenuOpen}
        onClose={handleMenuClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
        transformOrigin={{ vertical: 'top', horizontal: 'right' }}
        PaperProps={{ elevation: 2, sx: { mt: 1.5, minWidth: 180 } }}
      >
        {/* Profile MenuItem (for future use) */}
        <MenuItem onClick={handleMenuClose} disabled>Profile</MenuItem>
        
        {/* Theme Toggle MenuItem (Unchanged) */}
        <MenuItem onClick={handleThemeToggle}>
          <ListItemIcon>
            {mode === 'dark' ? <Brightness7Icon fontSize="small" /> : <Brightness4Icon fontSize="small" />}
          </ListItemIcon>
          {mode === 'dark' ? 'Light Mode' : 'Dark Mode'}
        </MenuItem>
        
        {/* Logout MenuItem (Now functional) */}
        <MenuItem onClick={handleLogout}>
          <ListItemIcon>
            <Logout fontSize="small" />
          </ListItemIcon>
          Logout
        </MenuItem>
      </Menu>
    </>
  );
};

export default Header;


--- File: .\ata-frontend\src\components\common\Layout.jsx ---

// /src/components/common/Layout.jsx

// --- Core React Imports ---
import React, { useState } from 'react';

// --- MUI Component Imports ---
import { Box, Toolbar, useTheme } from '@mui/material';

// --- Custom Component Imports ---
import Header from './Header';
import Sidebar from './Sidebar';

// --- Centralized Layout Constant ---
const SIDEBAR_WIDTH = 240;

/**
 * The main structural component for the entire application.
 * It now manages the state for both the mobile and collapsible sidebars.
 */
const Layout = ({ children }) => {
  // --- Hooks ---
  const theme = useTheme();

  // --- State Management ---
  const [mobileOpen, setMobileOpen] = useState(false);
  const [isCollapsed, setIsCollapsed] = useState(false);
  
  const collapsedSidebarWidth = theme.spacing(9);

  // --- Event Handlers ---
  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };
  
  const handleToggleCollapse = () => {
    setIsCollapsed(!isCollapsed);
  };
  
  const currentDesktopSidebarWidth = isCollapsed ? collapsedSidebarWidth : SIDEBAR_WIDTH;

  return (
    <Box sx={{ display: 'flex' }}>
      
      {/* The application Header */}
      <Header 
        onDrawerToggle={handleDrawerToggle} 
        desktopSidebarWidth={currentDesktopSidebarWidth} 
        isSidebarCollapsed={isCollapsed}
      />

      {/* The application Sidebar */}
      <Sidebar 
        mobileOpen={mobileOpen} 
        onDrawerToggle={handleDrawerToggle} 
        sidebarWidth={SIDEBAR_WIDTH}
        isCollapsed={isCollapsed}
        onToggleCollapse={handleToggleCollapse}
      />

      {/* The Main Content Area wrapper */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: 3,
          // --- [THE FINAL FIX IS HERE] ---
          // This property now explicitly defines the width for ALL screen sizes.
          // On 'xs', it's 100%. From 'md' and up, it calculates space for the sidebar.
          // This prevents child components from ever forcing the main layout to overflow.
          width: { 
            xs: '100%', 
            md: `calc(100% - ${currentDesktopSidebarWidth}px)` 
          },
          // --- [END OF FIX] ---
          bgcolor: 'background.default',
          minHeight: '100vh',
          transition: theme.transitions.create('width', {
            easing: theme.transitions.easing.sharp,
            duration: theme.transitions.duration.enteringScreen,
          }),
        }}
      >
        {/* CRITICAL SPACER: Pushes content below the fixed Header */}
        <Toolbar />
        
        {/* The actual page content, passed from the Router, is rendered here. */}
        {children}
      </Box>
    </Box>
  );
};

export default Layout;

--- File: .\ata-frontend\src\components\common\ProtectedRoute.jsx ---

// /src/components/common/ProtectedRoute.jsx

// --- Core React & Router Imports ---
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';

// --- MUI Component Imports for Loading State ---
import { Box, CircularProgress } from '@mui/material';

// --- Custom Hook Import for Authentication State ---
// This is the critical link to our global authentication context.
import { useAuth } from '../../hooks/useAuth';

/**
 * A wrapper component that acts as a security checkpoint for private routes.
 *
 * It performs three essential checks:
 * 1. Checks if the initial authentication status is still being determined.
 * 2. If not loading, it checks if the user is authenticated.
 * 3. If authenticated, it renders the requested child component (the page).
 * 4. If not authenticated, it redirects the user to the login page.
 *
 * @param {object} props
 * @param {React.ReactNode} props.children - The component/page to render if the user is authenticated.
 */
const ProtectedRoute = ({ children }) => {
  // --- Consume Global Authentication State ---
  // We get both the authentication status and the initial loading status from our context.
  const { isAuthenticated, isAuthLoading } = useAuth();
  
  // The `useLocation` hook from React Router gives us information about the current URL.
  // We need this to remember where the user was trying to go before we redirected them.
  const location = useLocation();

  // --- 1. Handle the Initial Loading State ---
  // This is a crucial UX feature. While the `useAuth` hook is performing its initial
  // check (e.g., verifying a token from localStorage with the backend), we show a
  // full-page loading spinner. This prevents a "flash of unauthenticated content"
  // and provides clear feedback to the user that the application is loading.
  if (isAuthLoading) {
    return (
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh', // Take up the full viewport height
        }}
      >
        <CircularProgress />
      </Box>
    );
  }

  // --- 2. Handle the Unauthenticated State ---
  // If the initial loading is finished AND the user is NOT authenticated,
  // we must redirect them to the login page.
  if (!isAuthenticated) {
    // The `<Navigate>` component from React Router is the declarative way to
    // perform a redirect.
    // - `to="/login"`: The destination path.
    // - `replace`: This replaces the current entry in the history stack instead of
    //   pushing a new one. This means the user won't be able to click the "back"
    //   button to get back to the protected page they were just redirected from.
    // - `state={{ from: location }}`: This is a critical piece of UX. We pass the
    //   current `location` object along with the redirect. The Login page can
    //   then access this state to redirect the user back to their original
    //   destination after they successfully log in.
    return <Navigate to="/login" replace state={{ from: location }} />;
  }

  // --- 3. Handle the Authenticated State ---
  // If the loading is finished AND the user is authenticated, we simply render
  // the child components that were passed into this ProtectedRoute.
  return children;
};

export default ProtectedRoute;


--- File: .\ata-frontend\src\components\common\Sidebar.jsx ---

// /src/components/common/Sidebar.jsx (FINAL, WITH COPYRIGHT NOTICE)

// --- Core React & Router Imports ---
import React from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

// --- MUI Component Imports ---
import { Box, Drawer, List, ListItem, ListItemButton, ListItemIcon, ListItemText, Toolbar, Typography, useTheme, Tooltip, Divider, IconButton } from '@mui/material';
import ChevronLeftIcon from '@mui/icons-material/ChevronLeft';

// --- Icon & Asset Imports ---
import HomeOutlined from '@mui/icons-material/HomeOutlined';
import SchoolOutlined from '@mui/icons-material/SchoolOutlined';
import AutoAwesomeOutlined from '@mui/icons-material/AutoAwesomeOutlined';
import GradingOutlined from '@mui/icons-material/GradingOutlined';
import SmartToyOutlined from '@mui/icons-material/SmartToyOutlined';
import lightLogo from '../../assets/mst_logo_no_bg.png';
import darkLogo from '../../assets/mst_logo_dark_no_bg.png';
import { useThemeMode } from '../../hooks/useThemeMode';

const navItems = [
  { text: 'Home', icon: <HomeOutlined />, path: '/' },
  { text: 'Your Classes', icon: <SchoolOutlined />, path: '/classes' },
  { text: 'AI Tools', icon: <AutoAwesomeOutlined />, path: '/tools' },
  { text: 'Assessments', icon: <GradingOutlined />, path: '/assessments' },
  { text: 'Chatbot', icon: <SmartToyOutlined />, path: '/chat' },
];

const copyrightText = "Copyright Â© 2025 Unique Tech Solution Ltd. All Rights Reserved";

/**
 * The primary navigation component. Supports a collapsible "mini" state on desktop.
 */
const Sidebar = ({ mobileOpen, onDrawerToggle, sidebarWidth, isCollapsed, onToggleCollapse }) => {
  const theme = useTheme();
  const location = useLocation();
  const navigate = useNavigate();
  const { mode } = useThemeMode();
  
  const collapsedSidebarWidth = theme.spacing(9); // 72px

  const drawerContent = (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      <Toolbar sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', p: 1, height: '64px' }}>
        <img 
          src={mode === 'light' ? lightLogo : darkLogo} 
          alt="ATA Logo" 
          style={{ 
            height: isCollapsed ? '32px' : '50px',
            objectFit: 'contain',
            transition: 'height 0.3s ease-in-out',
          }} 
        />
      </Toolbar>

      <List sx={{ flexGrow: 1 }}>
        {navItems.map((item) => {
          const isActive = location.pathname === item.path || (item.path !== '/' && location.pathname.startsWith(item.path));
          
          return (
            <Tooltip title={isCollapsed ? item.text : ''} placement="right" key={item.text}>
              <ListItem disablePadding sx={{ p: theme.spacing(1, 2) }}>
                <ListItemButton
                  onClick={() => {
                    navigate(item.path);
                    if (mobileOpen) { onDrawerToggle(); }
                  }}
                  sx={{
                    borderRadius: 1,
                    backgroundColor: isActive ? theme.palette.secondary.light : 'transparent',
                    justifyContent: isCollapsed ? 'center' : 'initial',
                    '&:hover': {
                      backgroundColor: isActive ? theme.palette.secondary.light : theme.palette.action.hover,
                    },
                  }}
                >
                  <ListItemIcon sx={{ 
                    color: isActive ? 'primary.main' : 'text.secondary',
                    minWidth: 0,
                    mr: isCollapsed ? 'auto' : 3,
                    justifyContent: 'center',
                  }}>
                    {item.icon}
                  </ListItemIcon>
                  {!isCollapsed && (
                    <ListItemText
                      primary={item.text}
                      primaryTypographyProps={{
                        fontWeight: isActive ? 600 : 500,
                        color: isActive ? 'primary.main' : 'text.primary',
                      }}
                    />
                  )}
                </ListItemButton>
              </ListItem>
            </Tooltip>
          );
        })}
      </List>
      
      {/* --- [START OF COPYRIGHT AND COLLAPSE SECTION] --- */}
      <Box>
        <Divider />
        
        {/* --- THE NEW COPYRIGHT NOTICE --- */}
        <Box sx={{ p: 2, textAlign: 'center' }}>
          {isCollapsed ? (
            // In collapsed mode, show only the icon with a tooltip.
            <Tooltip title={copyrightText} placement="right">
              <Typography variant="caption" color="text.secondary">
                Â©
              </Typography>
            </Tooltip>
          ) : (
            // In expanded mode, show the full text.
            <Typography variant="caption" color="text.secondary">
              {copyrightText}
            </Typography>
          )}
        </Box>
        
        {/* The collapse button is now only visible on desktop. */}
        <Box sx={{ display: { xs: 'none', md: 'block' } }}>
          <Divider />
          <ListItem disablePadding>
            <ListItemButton onClick={onToggleCollapse} sx={{ justifyContent: 'center', py: 2 }}>
              <ListItemIcon sx={{ minWidth: 0, justifyContent: 'center', 
                transition: 'transform 0.3s',
                transform: isCollapsed ? 'rotate(180deg)' : 'rotate(0deg)',
              }}>
                <ChevronLeftIcon />
              </ListItemIcon>
            </ListItemButton>
          </ListItem>
        </Box>
      </Box>
      {/* --- [END OF COPYRIGHT AND COLLAPSE SECTION] --- */}
    </Box>
  );

  return (
    <Box
      component="nav"
      sx={{ width: { md: isCollapsed ? collapsedSidebarWidth : sidebarWidth }, flexShrink: { md: 0 } }}
      aria-label="main navigation"
    >
      {/* Mobile Drawer */}
      <Drawer
        variant="temporary"
        open={mobileOpen}
        onClose={onDrawerToggle}
        ModalProps={{ keepMounted: true }}
        sx={{
          display: { xs: 'block', md: 'none' },
          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: sidebarWidth },
        }}
      >
        {drawerContent}
      </Drawer>
      
      {/* Desktop Drawer */}
      <Drawer
        variant="permanent"
        sx={{
          display: { xs: 'none', md: 'block' },
          '& .MuiDrawer-paper': {
            boxSizing: 'border-box',
            width: isCollapsed ? collapsedSidebarWidth : sidebarWidth,
            transition: theme.transitions.create('width', {
              easing: theme.transitions.easing.sharp,
              duration: theme.transitions.duration.enteringScreen,
            }),
            overflowX: 'hidden',
          },
        }}
        open
      >
        {drawerContent}
      </Drawer>
    </Box>
  );
};

export default Sidebar;

--- File: .\ata-frontend\src\components\home\GreetingBanner.jsx ---

// /src/components/home/GreetingBanner.jsx

// --- Core React & Hook Imports ---
import React from 'react';

// --- MUI Component Imports ---
import { Box, Typography } from '@mui/material';

// --- Custom Hook Import for Global State ---
// This component consumes the global authentication state to get the user's name.
import { useAuth } from '../../hooks/useAuth';

/**
 * A purely presentational component that displays a personalized banner.
 * It greets the user by name with a message that changes based on the time of day.
 */
const GreetingBanner = () => {
  // --- Consume Global State ---
  const { user } = useAuth();

  // --- Internal Helper Functions for Dynamic Content ---
  
  /**
   * Determines the correct greeting based on the current hour.
   * @returns {string} The greeting string (e.g., "Good morning,").
   */
  const getGreeting = () => {
    const currentHour = new Date().getHours();
    if (currentHour < 12) {
      return 'Good morning,';
    } else if (currentHour < 17) { // 5 PM
      return 'Good afternoon,';
    } else {
      return 'Good evening,';
    }
  };

  /**
   * Gets the user's display name, with a graceful fallback.
   * @returns {string} The user's name or a generic fallback.
   */
  const getUserDisplayName = () => {
    // In V2, this could be updated to parse the first name from the full name.
    // For now, it simply returns a placeholder.
    // now i just comment  user.name, so we can show a simple name, later we should make it based on users
    if (user && user.name) {
      // return user.name;
      return 'Dear Teacher'
    }
    // This fallback prevents the UI from breaking if the user object is not yet loaded.
    return 'there';
  };

  return (
    // Add a bottom margin for spacing from the elements below it.
    <Box sx={{ mb: 4 }}>
      {/* 
        The 'h1' variant is used for the main page heading for semantic HTML.
        'display: inline' is used to allow the two Typography components to sit
        on the same line, overriding the default block behavior of the h1 tag.
      */}
      <Typography variant="h1" color="text.primary" sx={{ display: 'inline' }}>
        {getGreeting()}
      </Typography>
      
      {/* This ensures a space is rendered between the two components. */}
      {' '}
      
      <Typography variant="h1" color="primary" sx={{ display: 'inline' }}>
        {`${getUserDisplayName()}!`}
      </Typography>
    </Box>
  );
};

export default GreetingBanner;

--- File: .\ata-frontend\src\components\home\InfoCard.jsx ---

// /src/components/home/InfoCard.jsx

// --- Core React Import ---
import React from 'react';

// --- MUI Component Imports ---
import { Card, CardContent, Typography, Box } from '@mui/material';

/**
 * A small, non-interactive, purely presentational card to display a single,
 * high-level statistic with an icon.
 *
 * @param {object} props
 * @param {React.ReactElement} props.icon - The icon element to display.
 * @param {string | number} props.value - The primary statistic value to display.
 * @param {string} props.title - The descriptive label for the statistic.
 */
const InfoCard = ({ icon, value, title }) => {
  return (
    // The Card component uses the global styles defined in our theme.
    // 'flex: 1' allows the cards in a flex container to grow equally to fill the space.
    <Card sx={{ flex: 1, width: '100%' }}>
      <CardContent>
        {/* Use a horizontal flexbox to align the icon and text content. */}
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          
          {/* --- Icon with circular background --- */}
          <Box
            sx={{
              width: 48,
              height: 48,
              borderRadius: '50%', // Creates the circle shape.
              backgroundColor: 'secondary.light', // Uses a color from our theme palette.
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              mr: 2, // Margin-right for spacing from the text.
            }}
          >
            {/* 
              React.cloneElement is used to add a 'color' prop to the icon
              element that was passed in as a prop. This is a clean way to
              style a child prop without the parent needing to know about it.
            */}
            {React.cloneElement(icon, { color: 'primary' })}
          </Box>

          {/* --- Text content (Value and Title) --- */}
          <Box>
            <Typography variant="h2" color="text.primary">
              {value}
            </Typography>
            <Typography variant="body1" color="text.secondary">
              {title}
            </Typography>
          </Box>
        </Box>
      </CardContent>
    </Card>
  );
};

export default InfoCard;

--- File: .\ata-frontend\src\components\home\NavCard.jsx ---

// /src/components/home/NavCard.jsx

// --- Core React & Router Imports ---
import React from 'react';
import { useNavigate } from 'react-router-dom';

// --- MUI Component Imports ---
import { Grid, Card, CardActionArea, Typography, Box } from '@mui/material';

/**
 * A large, responsive, clickable navigation card for the Home page.
 */
const NavCard = ({ item }) => {
  const navigate = useNavigate();

  return (
    // <<< CORRECTION: Changed 'xs' from 12 to 6.
    // This makes the card take up half the width on the smallest screens,
    // creating a 2x2 grid on mobile instead of a 1x4 vertical stack.
    <Grid item xs={6} md={6}>
      <Card
        sx={{
          minHeight: 180,
          transition: 'transform 300ms ease, box-shadow 300ms ease',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: 6,
          },
        }}
      >
        <CardActionArea
          onClick={() => navigate(item.path)}
          sx={{
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            p: { xs: 2, sm: 3 }, // Use slightly less padding on very small screens
          }}
        >
          <Box
            sx={{
              width: { xs: 48, sm: 56 }, // Make icon slightly smaller on mobile
              height: { xs: 48, sm: 56 },
              borderRadius: '50%',
              backgroundColor: item.iconBgColor,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            {React.cloneElement(item.icon, {
              sx: { color: item.iconColor, fontSize: { xs: '28px', sm: '32px' } },
            })}
          </Box>
          <Typography 
            variant="h3" 
            sx={{ 
              mt: 2,
              fontSize: { xs: '1rem', sm: '1.25rem' } // Scale down font size on mobile
            }}
          >
            {item.title}
          </Typography>
          <Typography
            variant="body1"
            color="text.secondary"
            sx={{ 
              mt: 0.5, 
              textAlign: 'center', 
              maxWidth: '90%',
              display: { xs: 'none', sm: 'block' } // Hide description on smallest screens
            }}
          >
            {item.description}
          </Typography>
        </CardActionArea>
      </Card>
    </Grid>
  );
};

export default NavCard;

--- File: .\ata-frontend\src\components\tools\FileUploadZone.jsx ---

// /src/components/tools/FileUploadZone.jsx

import React, { useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { Box, Typography, Button } from '@mui/material';
import FileUploadOutlined from '@mui/icons-material/FileUploadOutlined';
import DescriptionOutlined from '@mui/icons-material/DescriptionOutlined';

/**
 * A reusable UI component for handling file selection via drag-and-drop or click.
 *
 * @param {object} props
 * @param {File | null} props.file - The currently selected file object.
 * @param {function} props.setFile - Callback function to update the parent's file state.
 * @param {boolean} props.isLoading - Whether the parent form is in a loading state.
 */
const FileUploadZone = ({ file, setFile, isLoading }) => {
  const onDrop = useCallback(acceptedFiles => {
    if (acceptedFiles.length > 0) {
      setFile(acceptedFiles[0]);
    }
  }, [setFile]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    maxFiles: 1,
    disabled: isLoading,
    accept: {
      'image/jpeg': [],
      'image/png': [],
      'application/pdf': [],
      'application/msword': ['.doc'],
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
    }
  });

  if (file) {
    return (
      <Box sx={{ p: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1, display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        <Box sx={{ display: 'flex', alignItems: 'center', overflow: 'hidden' }}>
          <DescriptionOutlined color="action" />
          <Typography noWrap sx={{ ml: 1.5 }} title={file.name}>{file.name}</Typography>
        </Box>
        <Button size="small" onClick={() => setFile(null)} disabled={isLoading}>Clear</Button>
      </Box>
    );
  }

  return (
    <Box
      {...getRootProps()}
      sx={{
        p: 4,
        border: '2px dashed',
        borderColor: isDragActive ? 'primary.main' : 'divider',
        borderRadius: 1,
        textAlign: 'center',
        cursor: 'pointer',
        backgroundColor: isDragActive ? 'action.hover' : 'transparent',
        transition: 'border-color 300ms, background-color 300ms',
        opacity: isLoading ? 0.5 : 1,
      }}
    >
      <input {...getInputProps()} />
      <FileUploadOutlined sx={{ fontSize: 48, color: 'text.secondary', mb: 1 }} />
      <Typography>Drag & drop a file</Typography>
      <Typography color="text.secondary">or click to select a file (.pdf, .docx, .png, .jpeg)</Typography>
    </Box>
  );
};

export default FileUploadZone;

--- File: .\ata-frontend\src\components\tools\HistoryModal.jsx ---

import React, { useState, useEffect, useCallback } from 'react';
import {
  Dialog, DialogTitle, DialogContent, IconButton, Typography, Box, List, Accordion,
  AccordionSummary, AccordionDetails, TextField, MenuItem, Select, InputLabel,
  FormControl, CircularProgress, Stack, Divider, Button, Alert, Tooltip
} from '@mui/material';

// Import Icons
import CloseOutlined from '@mui/icons-material/CloseOutlined';
import ExpandMoreOutlined from '@mui/icons-material/ExpandMoreOutlined';
import SearchOutlined from '@mui/icons-material/SearchOutlined';
import QuestionAnswerOutlined from '@mui/icons-material/QuestionAnswerOutlined';
import SlideshowOutlined from '@mui/icons-material/SlideshowOutlined';
import RuleOutlined from '@mui/icons-material/RuleOutlined';
import AutoAwesomeOutlined from '@mui/icons-material/AutoAwesomeOutlined';
import ContentCopyOutlined from '@mui/icons-material/ContentCopyOutlined';
import DeleteOutlineOutlined from '@mui/icons-material/DeleteOutlineOutlined';

// Import Services and Hooks
import historyService from '../../services/historyService';
import { useDebounce } from '../../hooks/useDebounce';
import { useSnackbar } from '../../hooks/useSnackbar';
import ConfirmationModal from '../common/ConfirmationModal';

// Helper to get an icon based on the tool ID from the API
const getToolIcon = (toolId) => {
  switch (toolId) {
    case 'question-generator': return <QuestionAnswerOutlined fontSize="small" />;
    case 'slide-generator': return <SlideshowOutlined fontSize="small" />;
    case 'rubric-generator': return <RuleOutlined fontSize="small" />;
    default: return <AutoAwesomeOutlined fontSize="small" />;
  }
};

const HistoryModal = ({ open, onClose }) => {
  const { showSnackbar } = useSnackbar();
  const [items, setItems] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  // Filter and Search State
  const [searchTerm, setSearchTerm] = useState('');
  const [filterTool, setFilterTool] = useState('all');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  // State for Delete Confirmation
  const [isConfirmOpen, setIsConfirmOpen] = useState(false);
  const [itemToDelete, setItemToDelete] = useState(null);

  const fetchHistory = useCallback(async () => {
    setIsLoading(true);
    setError(null); // Reset error on new fetch
    try {
      const params = {
        search: debouncedSearchTerm || undefined,
        tool_id: filterTool === 'all' ? undefined : filterTool,
      };
      const data = await historyService.getHistory(params);
      setItems(data.results);
    } catch (err) {
      setError('Failed to load generation history.');
      showSnackbar('Failed to load generation history.', 'error');
    } finally {
      setIsLoading(false);
    }
  }, [debouncedSearchTerm, filterTool, showSnackbar]);

  useEffect(() => {
    if (open) {
      fetchHistory();
    }
  }, [open, fetchHistory]);

  const handleCopy = (content) => {
    navigator.clipboard.writeText(content);
    showSnackbar('Copied to clipboard!', 'success');
  };

  // Handlers for Delete Flow
  const openDeleteConfirm = (item) => {
    setItemToDelete(item);
    setIsConfirmOpen(true);
  };

  const closeDeleteConfirm = () => {
    setItemToDelete(null);
    setIsConfirmOpen(false);
  };

  const handleDelete = async () => {
    if (!itemToDelete) return;
    try {
      await historyService.deleteGeneration(itemToDelete.id);
      // Optimistic UI update: remove the item from local state
      setItems(prevItems => prevItems.filter(item => item.id !== itemToDelete.id));
      showSnackbar('History item deleted successfully.', 'success');
    } catch (err) {
      showSnackbar(err.message || 'Failed to delete item.', 'error');
    } finally {
      closeDeleteConfirm();
    }
  };

  return (
    <>
      <Dialog
        open={open}
        onClose={onClose}
        fullWidth
        maxWidth="lg"
      >
        <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', py: 1.5 }}>
          Generation History
          <IconButton edge="end" color="inherit" onClick={onClose} aria-label="close">
            <CloseOutlined />
          </IconButton>
        </DialogTitle>
        <DialogContent dividers sx={{ p: { xs: 1.5, sm: 2, md: 3 } }}>
          {/* Filter and Search UI */}
          <Stack direction={{ xs: 'column', md: 'row' }} spacing={2} sx={{ mb: 2 }}>
            <TextField
              fullWidth
              label="Search history..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              InputProps={{ startAdornment: <SearchOutlined sx={{ mr: 1, color: 'text.disabled' }} /> }}
            />
            <FormControl sx={{ minWidth: 200 }}>
              <InputLabel>Filter by Tool</InputLabel>
              <Select value={filterTool} label="Filter by Tool" onChange={(e) => setFilterTool(e.target.value)}>
                <MenuItem value="all">All Tools</MenuItem>
                <MenuItem value="question-generator">Question Generator</MenuItem>
                <MenuItem value="slide-generator">Slide Generator</MenuItem>
                <MenuItem value="rubric-generator">Rubric Generator</MenuItem>
              </Select>
            </FormControl>
          </Stack>

          {/* Content Display */}
          {isLoading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>
          ) : error ? (
            <Alert severity="error">{error}</Alert>
          ) : items.length === 0 ? (
            <Typography sx={{ textAlign: 'center', mt: 4 }}>No history found for the selected filters.</Typography>
          ) : (
            <Box sx={{ maxHeight: '60vh', overflowY: 'auto', pr: 1 }}>
              <List>
                {items.map((item) => (
                  <Accordion key={item.id} sx={{ mb: 1, '&:before': { display: 'none' } }}>
                    <AccordionSummary expandIcon={<ExpandMoreOutlined />}>
                      <Stack direction="row" alignItems="center" spacing={1.5} sx={{ flexGrow: 1, overflow: 'hidden' }}>
                        {getToolIcon(item.tool_id)}
                        <Typography variant="body1" sx={{ fontWeight: 500 }} noWrap>
                          {item.title || 'Untitled Generation'}
                        </Typography>
                      </Stack>
                      <Typography color="text.secondary" sx={{ flexShrink: 0, ml: 2, display: { xs: 'none', sm: 'block' } }}>
                        {new Date(item.created_at).toLocaleDateString()}
                      </Typography>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb: 2 }}>
                        <Button
                          size="small"
                          variant="outlined"
                          startIcon={<ContentCopyOutlined />}
                          onClick={() => handleCopy(item.generated_content)}
                        >
                          Copy
                        </Button>
                        <Tooltip title="Delete this item">
                          <IconButton color="error" onClick={() => openDeleteConfirm(item)}>
                            <DeleteOutlineOutlined />
                          </IconButton>
                        </Tooltip>
                      </Stack>
                      <Divider />
                      <Box sx={{ mt: 2, maxHeight: 400, overflowY: 'auto', whiteSpace: 'pre-wrap', bgcolor: 'grey.50', p: 2, borderRadius: 1, fontFamily: 'monospace' }}>
                        {item.generated_content}
                      </Box>
                    </AccordionDetails>
                  </Accordion>
                ))}
              </List>
            </Box>
          )}
        </DialogContent>
      </Dialog>

      <ConfirmationModal
        open={isConfirmOpen}
        onClose={closeDeleteConfirm}
        onConfirm={handleDelete}
        title="Delete History Item"
        description={`Are you sure you want to permanently delete the item titled "${itemToDelete?.title || 'this item'}"? This action cannot be undone.`}
      />
    </>
  );
};

export default HistoryModal;

--- File: .\ata-frontend\src\components\tools\OutputPanel.jsx ---

// /src/components/tools/OutputPanel.jsx

import React, { useState, useEffect } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

// MUI Component Imports (with Table components added)
import {
  Card, CardContent, Box, Typography, Button, IconButton, Tooltip,
  Divider, Stack, Skeleton, Alert, AlertTitle, CircularProgress,
  Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper
} from '@mui/material';

// MUI Icon Imports
import AutoAwesomeOutlined from '@mui/icons-material/AutoAwesomeOutlined';
import ContentCopyOutlined from '@mui/icons-material/ContentCopyOutlined';
import CheckOutlined from '@mui/icons-material/CheckOutlined';
import RestartAltOutlined from '@mui/icons-material/RestartAltOutlined';
import SaveOutlined from '@mui/icons-material/SaveOutlined';
import CloudDoneOutlined from '@mui/icons-material/CloudDoneOutlined';

// Internal State Component for when the panel is empty
const EmptyState = () => (
    <Box sx={{ textAlign: 'center', p: 4, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100%' }}>
      <AutoAwesomeOutlined sx={{ fontSize: 64, color: 'text.disabled', mb: 2 }} />
      <Typography variant="h3" gutterBottom>Content will appear here</Typography>
      <Typography color="text.secondary">Configure your settings on the left and click 'Generate' to get started.</Typography>
    </Box>
);

// Internal State Component for when the content is loading
const LoadingState = () => (
    <Box sx={{ p: 3 }}>
        <Skeleton variant="text" width="40%" sx={{ fontSize: '1.25rem' }} />
        <Skeleton variant="text" width="20%" sx={{ fontSize: '1rem', mb: 2 }} />
        <Divider />
        <Skeleton variant="text" sx={{ mt: 2 }} />
        <Skeleton variant="text" width="80%" />
        <Skeleton variant="text" />
        <Skeleton variant="text" width="90%" />
        <Skeleton variant="text" width="75%" />
    </Box>
);

// Internal State Component for when an error has occurred
const ErrorState = ({ error }) => (
    <Box sx={{ p: 3, height: '100%' }}>
      <Alert severity="error" sx={{height: '100%'}}>
        <AlertTitle>Generation Failed</AlertTitle>
        {error || 'An unknown error occurred.'}
      </Alert>
    </Box>
);

/**
 * A state-aware panel for displaying AI-generated content.
 * UPGRADED to correctly render themed Markdown tables.
 */
const OutputPanel = ({ isLoading, error, generatedContent, onClear, onSave, isSaving, isSaved }) => {
  const [copied, setCopied] = useState(false);

  useEffect(() => {
    setCopied(false);
  }, [generatedContent]);

  const handleCopy = () => {
    if (!generatedContent) return;
    navigator.clipboard.writeText(generatedContent);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const renderContent = () => {
    if (isLoading) return <LoadingState />;
    if (error) return <ErrorState error={error} />;
    if (!generatedContent) return <EmptyState />;
    
    // Success State: Display the content and action buttons
    return (
      <>
        {/* Header with Title and Action Buttons */}
        <Box sx={{ p: 2, display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexShrink: 0 }}>
          <Typography variant="h4">Generated Output</Typography>
          <Stack direction="row" spacing={1} alignItems="center">
            
            <Button
              variant={isSaved ? "contained" : "outlined"}
              size="small"
              color={isSaved ? "success" : "primary"}
              startIcon={
                isSaving ? <CircularProgress size={16} color="inherit" />
                : isSaved ? <CloudDoneOutlined />
                : <SaveOutlined />
              }
              onClick={onSave}
              disabled={isSaving || isSaved}
            >
              {isSaving ? 'Saving...' : isSaved ? 'Saved' : 'Save'}
            </Button>

            <Button
              variant="outlined"
              size="small"
              startIcon={copied ? <CheckOutlined /> : <ContentCopyOutlined />}
              onClick={handleCopy}
              color={copied ? 'success' : 'primary'}
              sx={{ minWidth: '90px' }}
              disabled={isLoading || isSaving}
            >
              {copied ? 'Copied!' : 'Copy'}
            </Button>
            
            <Tooltip title="Clear and start over">
              <span>
                <IconButton
                  onClick={onClear}
                  aria-label="clear output"
                  disabled={isLoading || isSaving}
                >
                  <RestartAltOutlined />
                </IconButton>
              </span>
            </Tooltip>
          </Stack>
        </Box>
        <Divider />

        {/* Content Area with Upgraded Markdown Rendering */}
        <CardContent sx={{ flexGrow: 1, overflowY: 'auto' }}>
          <ReactMarkdown
            remarkPlugins={[remarkGfm]}
            components={{
              // Text and Header overrides
              p: ({node, ...props}) => <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }} {...props} />,
              strong: ({node, ...props}) => <Typography component="span" sx={{ fontWeight: 'bold' }} {...props} />,
              li: ({node, ...props}) => <li><Typography variant="body1" component="span" sx={{ whiteSpace: 'pre-wrap' }} {...props} /></li>,
              h1: ({node, ...props}) => <Typography variant="h1" gutterBottom {...props} />,
              h2: ({node, ...props}) => <Typography variant="h2" gutterBottom {...props} />,
              h3: ({node, ...props}) => <Typography variant="h3" gutterBottom {...props} />,
              h4: ({node, ...props}) => <Typography variant="h4" gutterBottom {...props} />,
              h5: ({node, ...props}) => <Typography variant="h5" gutterBottom {...props} />,
              h6: ({node, ...props}) => <Typography variant="h6" gutterBottom {...props} />,

              // --- [CRITICAL FIX] Overrides for Table Elements ---
              table: ({node, ...props}) => <TableContainer component={Paper} variant="outlined" sx={{ my: 2 }}><Table {...props} /></TableContainer>,
              thead: ({node, ...props}) => <TableHead sx={{ bgcolor: 'action.hover' }} {...props} />,
              tbody: ({node, ...props}) => <TableBody {...props} />,
              tr: ({node, ...props}) => <TableRow {...props} />,
              th: ({node, ...props}) => <TableCell sx={{ fontWeight: 'bold' }} {...props} />,
              td: ({node, ...props}) => <TableCell {...props} />,
            }}
          >
            {generatedContent}
          </ReactMarkdown>
        </CardContent>
      </>
    );
  };

  return (
    <Card sx={{ minHeight: 450, height: '100%', display: 'flex', flexDirection: 'column' }}>
      {renderContent()}
    </Card>
  );
};

export default OutputPanel;

--- File: .\ata-frontend\src\components\tools\QuestionSettingsModal.jsx ---

// /src/components/tools/QuestionSettingsModal.jsx

import React, { useState, useEffect } from 'react';
import {
  Dialog, DialogTitle, DialogContent, DialogActions, Button, Stack, Typography, IconButton,
  List, ListItemButton, ListItemIcon, ListItemText, Checkbox, Divider,
  FormControl, InputLabel, Select, MenuItem, TextField, Grid, Paper, Box
} from '@mui/material'; // CORRECTED: Grid, Paper, and Box are now imported.
import CloseOutlined from '@mui/icons-material/CloseOutlined';

// The canonical list of all available question types.
const ALL_QUESTION_TYPES = [
    { id: 'mcq', label: 'Multiple-choice questions', defaultCount: 5, enabled: true },
    { id: 'true-false', label: 'True/False questions', defaultCount: 5, enabled: true },
    { id: 'matching', label: 'Matching questions', defaultCount: 5, enabled: true },
    { id: 'short-answer', label: 'Short-answer questions', defaultCount: 5, enabled: true },
    { id: 'fill-in-the-blank', label: 'Fill-in-the-blank (Cloze) questions', defaultCount: 5, enabled: true },
    { id: 'essay', label: 'Essay/Long-answer questions', defaultCount: 1, enabled: true },
    { id: 'oral', label: 'Oral questions/Viva voce', defaultCount: 3, enabled: false },
    { id: 'numerical', label: 'Computational/Numerical problems', defaultCount: 5, enabled: false },
    { id: 'diagram-labeling', label: 'Diagram-labeling/Construction tasks', defaultCount: 1, enabled: false },
    { id: 'image-graph', label: 'Image/Graph-based questions', defaultCount: 3, enabled: false },
    { id: 'lab-practical', label: 'Laboratory practicals/Skill demonstrations', defaultCount: 1, enabled: false },
    { id: 'project', label: 'Project/Coursework assessments', defaultCount: 1, enabled: false },
    { id: 'presentation', label: 'Presentations/Performances', defaultCount: 1, enabled: false },
];

const QuestionSettingsModal = ({ open, onClose, onSave, initialConfigs }) => {
  const [selectedConfigs, setSelectedConfigs] = useState(initialConfigs);

  useEffect(() => {
    if (open) {
      setSelectedConfigs(initialConfigs);
    }
  }, [open, initialConfigs]);

  const handleToggleType = (type) => {
    const currentIndex = selectedConfigs.findIndex(c => c.type === type.id);
    const newSelectedConfigs = [...selectedConfigs];

    if (currentIndex === -1) {
      if (selectedConfigs.length < 5) {
        newSelectedConfigs.push({
          type: type.id,
          label: type.label,
          count: type.defaultCount,
          difficulty: 'medium',
        });
      }
    } else {
      newSelectedConfigs.splice(currentIndex, 1);
    }
    setSelectedConfigs(newSelectedConfigs);
  };
  
  const handleConfigChange = (typeId, field, value) => {
      setSelectedConfigs(prev => prev.map(config => 
          config.type === typeId ? { ...config, [field]: value } : config
      ));
  };
  
  const handleSave = () => {
    onSave(selectedConfigs);
    onClose();
  };

  return (
    <Dialog open={open} onClose={onClose} fullWidth maxWidth="md">
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        Configure Question Settings
        <IconButton aria-label="close" onClick={onClose}><CloseOutlined /></IconButton>
      </DialogTitle>
      <DialogContent dividers>
        <Grid container spacing={4}>
          <Grid item xs={12} md={5}>
            <Typography variant="h4" gutterBottom>Question Types</Typography>
            <Typography color="text.secondary" sx={{mb: 2}}>Select 1 to 5 types.</Typography>
            <List sx={{ width: '100%', bgcolor: 'background.paper', maxHeight: '60vh', overflowY: 'auto' }}>
              {ALL_QUESTION_TYPES.map((type) => {
                const isSelected = selectedConfigs.some(c => c.type === type.id);
                return (
                  <ListItemButton 
                    key={type.id} 
                    role={undefined} 
                    onClick={() => handleToggleType(type)} 
                    dense 
                    disabled={!type.enabled || (!isSelected && selectedConfigs.length >= 5)}
                  >
                    <ListItemIcon>
                      <Checkbox
                        edge="start"
                        checked={isSelected}
                        tabIndex={-1}
                        disableRipple
                        disabled={!type.enabled || (!isSelected && selectedConfigs.length >= 5)}
                      />
                    </ListItemIcon>
                    <ListItemText primary={type.label} secondary={!type.enabled ? 'Coming soon' : ''} />
                  </ListItemButton>
                );
              })}
            </List>
          </Grid>
          
          <Grid item xs={12} md={7}>
            <Typography variant="h4" gutterBottom>Your Selections</Typography>
            <Typography color="text.secondary" sx={{mb: 2}}>
                Adjust the count and difficulty for each selected question type.
            </Typography>
            <Stack spacing={3} sx={{maxHeight: '60vh', overflowY: 'auto', p: 0.5}}>
                {selectedConfigs.length > 0 ? (
                    selectedConfigs.map(config => (
                        <Paper key={config.type} variant="outlined" sx={{ p: 2 }}>
                            <Typography variant="h5" gutterBottom>{config.label}</Typography>
                            <Stack direction="row" spacing={2} sx={{mt: 2}}>
                                <TextField
                                    label="Number of Questions"
                                    type="number"
                                    name="count"
                                    value={config.count}
                                    // IMPROVEMENT: Robustly handle empty input before parseInt
                                    onChange={(e) => handleConfigChange(config.type, 'count', e.target.value === '' ? '' : parseInt(e.target.value, 10))}
                                    InputProps={{ inputProps: { min: 1, max: 20 } }}
                                    sx={{width: '50%'}}
                                />
                                <FormControl fullWidth sx={{width: '50%'}}>
                                    <InputLabel>Difficulty</InputLabel>
                                    <Select
                                        name="difficulty"
                                        value={config.difficulty}
                                        label="Difficulty"
                                        onChange={(e) => handleConfigChange(config.type, 'difficulty', e.target.value)}
                                    >
                                        <MenuItem value="very easy">Very Easy</MenuItem>
                                        <MenuItem value="easy">Easy</MenuItem>
                                        <MenuItem value="medium">Medium</MenuItem>
                                        <MenuItem value="hard">Hard</MenuItem>
                                        <MenuItem value="very hard">Very Hard</MenuItem>
                                    </Select>
                                </FormControl>
                            </Stack>
                        </Paper>
                    ))
                ) : (
                    <Box sx={{textAlign: 'center', p: 4, border: '1px dashed', borderColor: 'divider', borderRadius: 1}}>
                        <Typography color="text.secondary">Select a question type from the left to begin.</Typography>
                    </Box>
                )}
            </Stack>
          </Grid>
        </Grid>
      </DialogContent>
      <DialogActions sx={{ p: 3 }}>
        <Button onClick={onClose}>Cancel</Button>
        <Button 
            variant="contained" 
            onClick={handleSave} 
            disabled={selectedConfigs.length === 0}
        >
            Save Settings
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default QuestionSettingsModal;

--- File: .\ata-frontend\src\components\tools\SourceInputBlock.jsx ---

// /src/components/tools/SourceInputBlock.jsx

import React, { useState, useMemo } from 'react';

// MUI Component Imports
import {
  Box,
  Typography,
  Tabs,
  Tab,
  Stack,
  TextField,
  Autocomplete,
  CircularProgress,
} from '@mui/material';

// Custom Component Imports
import FileUploadZone from './FileUploadZone';

/**
 * A reusable, controlled component that provides the full 3-tab UI
 * for selecting a source material (Text, File, or Library).
 */
const SourceInputBlock = ({
  label,
  // State values from parent
  textValue,
  fileValue,
  librarySelection,
  // State setters from parent
  onTextChange,
  onFileChange,
  onLibraryChange,
  // Library data from parent
  libraryTree,
  libraryLoading,
  // General disabled state
  disabled = false,
}) => {
  const [activeTab, setActiveTab] = useState(0);

  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
    // When switching tabs, we must call the parent handlers to clear
    // the state of the other source types.
    onTextChange('');
    onFileChange(null);
    onLibraryChange('selected_level', null); // This will trigger the cascade reset
  };

  // Memoized options for the cascading library dropdowns
  const yearOptions = useMemo(() => librarySelection.selected_level?.children || [], [librarySelection.selected_level]);
  const subjectOptions = useMemo(() => librarySelection.selected_year?.children || [], [librarySelection.selected_year]);
  const bookOptions = useMemo(() => librarySelection.selected_subject?.children || [], [librarySelection.selected_subject]);
  const chapterOptions = useMemo(() => librarySelection.selected_book?.children || [], [librarySelection.selected_book]);

  return (
    <Box>
      <Typography variant="overline" color="text.secondary">
        {label}
      </Typography>
      <Tabs
        value={activeTab}
        onChange={handleTabChange}
        variant="fullWidth"
        sx={{ borderBottom: 1, borderColor: 'divider' }}
      >
        <Tab label="Type Text" disabled={disabled} />
        <Tab label="Upload File" disabled={disabled} />
        <Tab label="From Library" disabled={disabled || libraryLoading} />
      </Tabs>
      <Box sx={{ pt: 2, minHeight: 290 }}>
        {activeTab === 0 && (
          <TextField
            label="Topic or Source Text"
            multiline
            rows={10}
            fullWidth
            value={textValue}
            onChange={(e) => onTextChange(e.target.value)}
            disabled={disabled}
          />
        )}
        {activeTab === 1 && (
          <FileUploadZone
            file={fileValue}
            setFile={onFileChange}
            isLoading={disabled}
          />
        )}
        {activeTab === 2 && (
          libraryLoading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', pt: 4 }}>
              <CircularProgress />
            </Box>
          ) : (
            <Stack spacing={2}>
              <Autocomplete
                options={libraryTree}
                getOptionLabel={(option) => option.name}
                value={librarySelection.selected_level}
                onChange={(e, val) => onLibraryChange('selected_level', val)}
                renderInput={(params) => <TextField {...params} label="Select Level" />}
                disabled={disabled}
              />
              <Autocomplete
                options={yearOptions}
                getOptionLabel={(option) => option.name}
                value={librarySelection.selected_year}
                onChange={(e, val) => onLibraryChange('selected_year', val)}
                disabled={!librarySelection.selected_level || disabled}
                renderInput={(params) => <TextField {...params} label="Select Year" />}
              />
              <Autocomplete
                options={subjectOptions}
                getOptionLabel={(option) => option.name}
                value={librarySelection.selected_subject}
                onChange={(e, val) => onLibraryChange('selected_subject', val)}
                disabled={!librarySelection.selected_year || disabled}
                renderInput={(params) => <TextField {...params} label="Select Subject" />}
              />
              <Autocomplete
                options={bookOptions}
                getOptionLabel={(option) => option.name}
                value={librarySelection.selected_book}
                onChange={(e, val) => onLibraryChange('selected_book', val)}
                disabled={!librarySelection.selected_subject || disabled}
                renderInput={(params) => <TextField {...params} label="Select Book" />}
              />
              <Autocomplete
                multiple
                options={chapterOptions}
                getOptionLabel={(option) => option.name}
                value={librarySelection.selected_chapters}
                onChange={(e, val) => onLibraryChange('selected_chapters', val)}
                disabled={!librarySelection.selected_book || disabled}
                renderInput={(params) => <TextField {...params} label="Select Chapters (up to 5)" />}
                limitTags={3}
              />
            </Stack>
          )
        )}
      </Box>
    </Box>
  );
};

export default SourceInputBlock;

--- File: .\ata-frontend\src\components\tools\ToolCard.jsx ---

// /src/components/tools/ToolCard.jsx

import React from 'react';
import { useNavigate } from 'react-router-dom';
import { Grid, Card, CardActionArea, Typography, Box } from '@mui/material';

/**
 * A presentational card for displaying a single AI Tool in a grid.
 * It is a fully interactive target that navigates to the specific tool's
 * page on click.
 *
 * @param {object} props
 * @param {object} props.tool - The data object for the tool.
 */
const ToolCard = ({ tool }) => {
  const navigate = useNavigate();

  return (
    // Grid item defines its own responsive behavior
    <Grid item xs={12} md={6} lg={4}>
      <Card
        sx={{
          height: '100%',
          // Use a transparent border that gains color on hover for a smooth transition
          border: '1px solid transparent',
          transition: 'border-color 300ms ease, box-shadow 300ms ease',
          '&:hover': {
            borderColor: 'primary.main',
            boxShadow: 4, // Use a standard theme elevation for the hover shadow
          },
        }}
      >
        <CardActionArea
          onClick={() => navigate(tool.path)}
          sx={{
            height: '100%',
            p: 3, // 24px padding
          }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            {/* The Icon, cloned to apply specific styles */}
            {React.cloneElement(tool.icon, {
              sx: { color: 'primary.main', fontSize: 40 },
            })}

            {/* The Text Content */}
            <Box sx={{ ml: 2 }}>
              <Typography variant="h3">{tool.title}</Typography>
              <Typography variant="body1" color="text.secondary" sx={{ mt: 0.5 }}>
                {tool.description}
              </Typography>
            </Box>
          </Box>
        </CardActionArea>
      </Card>
    </Grid>
  );
};

export default ToolCard;

--- File: .\ata-frontend\src\components\tools\ToolPageLayout.jsx ---

// /src/components/tools/ToolPageLayout.jsx

import React from 'react';
import { Box, Typography, Grid, Breadcrumbs, Link as MuiLink } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';

/**
 * A standard, reusable two-column layout for all individual AI tool pages.
 * It provides a consistent structure with a settings panel and an output panel.
 *
 * @param {object} props
 * @param {string} props.title - The title of the tool.
 * @param {React.ReactElement} props.icon - The icon for the tool.
 * @param {React.ReactElement} props.settingsPanel - The component for the left settings column.
 * @param {React.ReactElement} props.outputPanel - The component for the right output column.
 */
const ToolPageLayout = ({ title, icon, settingsPanel, outputPanel }) => {
  return (
    <Box>
      {/* 1. Page Header with Breadcrumbs for navigational context */}
      <Breadcrumbs aria-label="breadcrumb" sx={{ mb: 2 }}>
        <MuiLink component={RouterLink} underline="hover" color="inherit" to="/tools">
          AI Tools
        </MuiLink>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          {React.cloneElement(icon, { sx: { mr: 1, fontSize: '1.25rem' } })}
          <Typography color="text.primary">{title}</Typography>
        </Box>
      </Breadcrumbs>

      <Typography variant="h2" sx={{ mb: 4 }}>
        {title}
      </Typography>

      {/* 2. Responsive Two-Column Grid */}
      <Grid container spacing={4}>
        {/* Left Column: Settings Panel Slot */}
        <Grid item xs={12} md={4}>
          {settingsPanel}
        </Grid>

        {/* Right Column: Output Panel Slot */}
        <Grid item xs={12} md={8}>
          {outputPanel}
        </Grid>
      </Grid>
    </Box>
  );
};

export default ToolPageLayout;

--- File: .\ata-frontend\src\hooks\useAuth.jsx ---

// /src/hooks/useAuth.jsx (FINAL, SUPERVISOR-APPROVED - UNIFIED AND FLAWLESS)

// --- Core React Imports ---
import React, { createContext, useContext, useState, useMemo, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';

// --- Service Imports ---
// This file will orchestrate calls to the authentication service.
import authService from '../services/authService';

// --- Create the Context ---
// The context is initialized with a default shape that reflects the provider's value.
const AuthContext = createContext({
  user: null,
  isAuthenticated: false,
  isAuthLoading: true, // Application starts in an "auth-loading" state.
  login: async (email, password) => {},
  logout: () => {},
  register: async (fullName, email, password) => {},
});

/**
 * The Provider component that makes the authentication state and actions
 * available to the entire application. This is the single source of truth for
 * the user's session.
 */
export const AuthProvider = ({ children }) => {
  const navigate = useNavigate();

  // --- State Management ---
  const [user, setUser] = useState(null);
  // This state is critical for `ProtectedRoute` to prevent UI flashes.
  const [isAuthLoading, setIsAuthLoading] = useState(true);

  // --- Session Initialization Effect ---
  // This effect runs only ONCE when the application first loads.
  // Its purpose is to check for an existing token and validate it with the backend.
  useEffect(() => {
    const initializeAuth = async () => {
      const token = localStorage.getItem('authToken');

      if (token) {
        try {
          // A token exists. We must verify it by fetching the user's profile.
          // The request interceptor in `api.js` will automatically attach this token.
          const currentUser = await authService.getMe();
          setUser(currentUser); // On success, the user is logged in.
        } catch (error) {
          // If this fails, the token is invalid (e.g., expired, user deleted).
          // We must clear the bad token and ensure the user is logged out.
          console.error("Initial session validation failed:", error);
          localStorage.removeItem('authToken');
          setUser(null);
        }
      }
      
      // Signal to the rest of the app that the initial authentication check is complete.
      setIsAuthLoading(false);
    };

    initializeAuth();
  }, []); // The empty dependency array ensures this runs only once.


  // --- Core Authentication Actions ---

  // useCallback memoizes these functions, which is a performance best practice.
  const login = useCallback(async (email, password) => {
    try {
      // 1. Get the token from the backend.
      const { access_token } = await authService.login(email, password);
      // 2. Persist the token.
      localStorage.setItem('authToken', access_token);
      // 3. Fetch the user profile.
      const currentUser = await authService.getMe();
      // 4. Update the global state.
      setUser(currentUser);
      // The calling component (`Login.jsx`) will be responsible for navigation.
    } catch (error) {
      // Re-throw the error so the Login page can display it to the user.
      throw error;
    }
  }, []);

  const register = useCallback(async (fullName, email, password) => {
    // We re-throw the error so the Register page can display it.
    // On success, this function does nothing further. The user must manually log in.
    await authService.register(fullName, email, password);
  }, []);

  const logout = useCallback(() => {
    setUser(null);
    localStorage.removeItem('authToken');
    // For a clean logout, we navigate to the login page.
    navigate('/login');
  }, [navigate]);

  // --- Context Value ---
  // useMemo ensures this object is stable and only recreated when necessary.
  const value = useMemo(() => ({
    user,
    isAuthenticated: !!user, // Derived boolean flag for convenience.
    isAuthLoading,
    login,
    logout,
    register,
  }), [user, isAuthLoading, login, logout, register]);

  // Render the provider, making the value available to all children.
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

/**
 * The custom hook for consuming the AuthContext.
 */
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

--- File: .\ata-frontend\src\hooks\useChatWebSocket.js ---


// /ata-frontend/src/hooks/useChatWebSocket.js (FINAL, SECURE, SUPERVISOR-APPROVED)

import { useState, useRef, useCallback } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { config } from '../config';

/**
 * A custom React hook to manage a real-time WebSocket connection for the chatbot.
 *
 * This hook is now fully "user-aware." It is responsible for securely authenticating
 * the WebSocket connection by retrieving the user's JWT from localStorage and
 * appending it as a query parameter to the connection URL, fulfilling the backend's
 * security contract.
 *
 * @param {function} setMessages - The state setter function from the parent component's
 *                                 `useState` for managing the list of chat messages.
 * @returns {object} An object containing the connection state and functions to interact
 *                   with the WebSocket.
 */
const useChatWebSocket = (setMessages) => {
  // --- State Management (Unchanged) ---
  // These states track the UI/UX of the chat interaction.
  const [isThinking, setIsThinking] = useState(false);      // True from user send until first token arrives.
  const [isResponding, setIsResponding] = useState(false);  // True while the AI is streaming tokens.
  const [isConnected, setIsConnected] = useState(false);

  // --- Refs for Stable References (Unchanged) ---
  const socketRef = useRef(null);         // Holds the current WebSocket object.
  const messageQueueRef = useRef([]);     // Queues messages if `sendMessage` is called before connection.
  const currentSessionId = useRef(null);  // Tracks the current session to prevent redundant connections.

  /**
   * The core function to establish a WebSocket connection.
   * This function is now responsible for authentication.
   */
  const connect = useCallback((sessionId) => {
    // Prevent re-connecting to the same session or connecting without an ID.
    if (!sessionId || (socketRef.current && currentSessionId.current === sessionId && socketRef.current.readyState < 2)) {
      return;
    }
    
    currentSessionId.current = sessionId;
    
    // If there's an old connection, close it first.
    if (socketRef.current) {
      socketRef.current.close();
    }

    // --- [CRITICAL SECURITY MODIFICATION 1/3: RETRIEVE THE TOKEN] ---
    // Get the user's authentication token from the same place the api.js interceptor does.
    const token = localStorage.getItem('authToken');

    // --- [CRITICAL SECURITY MODIFICATION 2/3: HANDLE MISSING TOKEN] ---
    // If no token exists, the user is not logged in. We cannot proceed.
    // This is a crucial client-side check to prevent an unnecessary and
    // guaranteed-to-fail connection attempt.
    if (!token) {
      console.error("useChatWebSocket: No auth token found. Cannot connect.");
      // In a real app, you might want to show a snackbar error here as well.
      return;
    }

    // --- [CRITICAL SECURITY MODIFICATION 3/3: CONSTRUCT THE SECURE URL] ---
    // Append the token as a query parameter named 'token'. The backend's
    // chatbot_router is specifically designed to look for this parameter.
    const wsUrl = `${config.wsBaseUrl}/api/chatbot/ws/${sessionId}?token=${token}`;

    const ws = new WebSocket(wsUrl);
    socketRef.current = ws;

    // --- WebSocket Event Handlers (Logic is unchanged, but now operate on a secure connection) ---
    ws.onopen = () => {
      setIsConnected(true);
      messageQueueRef.current.forEach(msg => ws.send(JSON.stringify(msg)));
      messageQueueRef.current = [];
    };

    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      switch (message.type) {
        case 'stream_start':
          setIsThinking(false);
          setIsResponding(true);
          setMessages(prev => [...prev, { id: `msg_bot_${uuidv4()}`, role: 'bot', content: '', isStreaming: true }]);
          break;
        case 'stream_token':
          setMessages(prev => prev.map((m, i) => i === prev.length - 1 ? { ...m, content: m.content + message.payload.token } : m));
          break;
        case 'stream_end':
          setIsResponding(false);
          setMessages(prev => prev.map((m, i) => {
              if (i === prev.length - 1) {
                  const { isStreaming, ...finalMsg } = m;
                  return finalMsg;
              }
              return m;
          }));
          break;
        case 'error':
          setIsThinking(false);
          setIsResponding(false);
          setMessages(prev => [...prev, { id: `msg_bot_${uuidv4()}`, role: 'bot', content: message.payload.message }]);
          break;
        default:
          console.warn("Received unknown WebSocket message type:", message.type);
      }
    };

    ws.onclose = (event) => {
      // If the close code is 1008, it's likely an auth failure from the backend.
      if (event.code === 1008) {
          // WebSocket closed due to policy violation - likely auth error
      }
      setIsConnected(false);
      setIsThinking(false);
      setIsResponding(false);
    };
    
    ws.onerror = (error) => {
      console.error("WebSocket error:", error);
      setIsConnected(false);
      setIsThinking(false);
      setIsResponding(false);
    };

  }, [setMessages]); // The dependency array is correct.

  // The sendMessage function remains unchanged.
  const sendMessage = useCallback((messageText, fileId = null) => {
    const payload = { 
      type: 'user_message', 
      payload: { 
        text: messageText,
        file_id: fileId
      } 
    };

    if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {
      socketRef.current.send(JSON.stringify(payload));
    } else {
      messageQueueRef.current.push(payload);
    }
    setIsThinking(true);
  }, []);

  return { isThinking, isResponding, isConnected, connect, sendMessage };
};

export default useChatWebSocket;

--- File: .\ata-frontend\src\hooks\useDebounce.js ---

// /src/hooks/useDebounce.js
import { useState, useEffect } from 'react';

/**
 * A custom hook to debounce a value.
 * @param {*} value The value to debounce.
 * @param {number} delay The debounce delay in milliseconds.
 * @returns {*} The debounced value.
 */
export function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

--- File: .\ata-frontend\src\hooks\useSnackbar.jsx ---

// /src/hooks/useSnackbar.jsx

// --- Core React Imports ---
import React, { useState, createContext, useContext, useMemo } from 'react';

// --- MUI Component Imports ---
// Import the components needed to render the notification UI.
import { Snackbar, Alert } from '@mui/material';

// --- Create the Context ---
// This context will only hold the function to show a snackbar.
const SnackbarContext = createContext(null);

/**
 * The Provider component that makes the snackbar functionality available to the entire app.
 * It is also responsible for rendering the actual MUI Snackbar and Alert components.
 */
export const SnackbarProvider = ({ children }) => {
  // --- State Management ---
  // This state holds the properties of the snackbar to be displayed.
  const [snackbarState, setSnackbarState] = useState({
    open: false,
    message: '',
    severity: 'info', // Can be 'error', 'warning', 'info', or 'success'
  });

  // --- Core Functions ---
  // This is the function that will be exposed to the rest of the app.
  // It takes a message and severity and updates the state to show the snackbar.
  const showSnackbar = (message, severity = 'info') => {
    setSnackbarState({ open: true, message, severity });
  };

  // This function handles the closing of the snackbar, either by timeout or close button.
  const handleClose = (event, reason) => {
    // We don't want to close the snackbar if the user clicks away.
    if (reason === 'clickaway') {
      return;
    }
    // Set 'open' to false to hide the snackbar.
    setSnackbarState(prev => ({ ...prev, open: false }));
  };

  // --- Memoize the Context Value ---
  // We memoize the context value to prevent consumers from re-rendering
  // every time the provider's internal state changes.
  const contextValue = useMemo(() => ({ showSnackbar }), []);

  return (
    <SnackbarContext.Provider value={contextValue}>
      {children}
      
      {/*
        The Snackbar component is rendered here, at the top level.
        It listens to the 'snackbarState' and shows/hides itself accordingly.
      */}
      <Snackbar
        open={snackbarState.open}
        autoHideDuration={6000} // Hide automatically after 6 seconds.
        onClose={handleClose}
        // Position the snackbar at the bottom center of the screen.
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        {/*
          The Alert component provides the actual visual style (color, icon)
          for the message, based on the 'severity' state. The onClose prop
          adds the 'X' close button to the alert.
        */}
        <Alert onClose={handleClose} severity={snackbarState.severity} sx={{ width: '100%' }}>
          {snackbarState.message}
        </Alert>
      </Snackbar>
    </SnackbarContext.Provider>
  );
};

/**
 * The custom hook that components will use to access the showSnackbar function.
 */
export const useSnackbar = () => {
  const context = useContext(SnackbarContext);
  if (context === undefined) {
    throw new Error('useSnackbar must be used within a SnackbarProvider');
  }
  return context;
};

--- File: .\ata-frontend\src\hooks\useThemeMode.jsx ---

// /src/hooks/useThemeMode.jsx

// --- Core React Imports ---
import React, { createContext, useContext, useState, useMemo, useEffect } from 'react';

// --- Create the Context ---
// This context object will hold the current theme mode and the toggle function.
const ThemeModeContext = createContext(null);

/**
 * The Provider component that makes the theme mode and toggle function
 * available to the entire application tree.
 */
export const ThemeModeProvider = ({ children }) => {
  // --- State Management ---
  // Initialize the state by trying to read the value from localStorage.
  // If nothing is found, it defaults to 'light'. This makes the choice persistent.
  const [mode, setMode] = useState(
    () => localStorage.getItem('themeMode') || 'light'
  );

  // --- Side Effect for Persistence ---
  // This useEffect hook runs every time the 'mode' state changes.
  // It saves the new mode to localStorage, so the choice is remembered
  // across browser refreshes and sessions.
  useEffect(() => {
    localStorage.setItem('themeMode', mode);
  }, [mode]);

  // --- The Toggle Function ---
  // This is the function that other components will call to switch themes.
  const toggleThemeMode = () => {
    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));
  };

  // --- Memoize the Context Value ---
  // The 'useMemo' hook ensures that the 'value' object is only recreated
  // when the 'mode' state changes. This is a performance optimization that
  // prevents unnecessary re-renders of components that consume this context.
  const value = useMemo(() => ({ mode, toggleThemeMode }), [mode]);

  // Provide the memoized value to all children of this component.
  return (
    <ThemeModeContext.Provider value={value}>
      {children}
    </ThemeModeContext.Provider>
  );
};

/**
 * The custom hook that components will use to easily access the theme context.
 * This is a best practice that simplifies consumption and adds a check
 * to ensure the context is used within its provider.
 */
export const useThemeMode = () => {
  const context = useContext(ThemeModeContext);
  if (context === undefined) {
    // This error will be thrown if a component tries to use this hook
    // outside of the ThemeModeProvider, which helps catch bugs early.
    throw new Error('useThemeMode must be used within a ThemeModeProvider');
  }
  return context;
};

--- File: .\ata-frontend\src\pages\AdminDashboard.jsx ---

// /src/pages/AdminDashboard.jsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Container,
  Typography,
  Paper,
  Grid,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  CircularProgress,
  Alert,
  Chip,
  Card,
  CardContent,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import adminService from '../services/adminService';

const AdminDashboard = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    try {
      setLoading(true);
      const result = await adminService.getDashboardData();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="80vh">
        <CircularProgress size={60} />
      </Box>
    );
  }

  if (error) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4 }}>
        <Alert severity="error">{error}</Alert>
      </Container>
    );
  }

  const { summary, users, classes, students, assessments, results, outsider_students, chat_sessions, generations, ai_runs } = data;

  return (
    <Container maxWidth="xl" sx={{ mt: 4, mb: 4 }}>
      <Typography variant="h3" gutterBottom fontWeight="bold" color="primary">
        ðŸ”’ Super Admin Dashboard
      </Typography>

      {/* SUMMARY STATISTICS - BOLD AND PROMINENT */}
      <Paper elevation={3} sx={{ p: 3, mb: 4, bgcolor: 'primary.main', color: 'white' }}>
        <Typography variant="h5" gutterBottom fontWeight="bold">
          ðŸ“Š DATABASE SUMMARY
        </Typography>
        <Grid container spacing={2}>
          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ bgcolor: 'rgba(255,255,255,0.9)' }}>
              <CardContent>
                <Typography variant="h4" fontWeight="bold" color="primary">
                  {summary.total_users}
                </Typography>
                <Typography variant="body1" fontWeight="bold">
                  Total Users
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ bgcolor: 'rgba(255,255,255,0.9)' }}>
              <CardContent>
                <Typography variant="h4" fontWeight="bold" color="primary">
                  {summary.total_classes}
                </Typography>
                <Typography variant="body1" fontWeight="bold">
                  Total Classes
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ bgcolor: 'rgba(255,255,255,0.9)' }}>
              <CardContent>
                <Typography variant="h4" fontWeight="bold" color="primary">
                  {summary.total_students}
                </Typography>
                <Typography variant="body1" fontWeight="bold">
                  Total Students
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ bgcolor: 'rgba(255,255,255,0.9)' }}>
              <CardContent>
                <Typography variant="h4" fontWeight="bold" color="primary">
                  {summary.total_assessments}
                </Typography>
                <Typography variant="body1" fontWeight="bold">
                  Total Assessments
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ bgcolor: 'rgba(255,255,255,0.9)' }}>
              <CardContent>
                <Typography variant="h4" fontWeight="bold" color="success.main">
                  {summary.total_results}
                </Typography>
                <Typography variant="body1" fontWeight="bold">
                  Total Results
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ bgcolor: 'rgba(255,255,255,0.9)' }}>
              <CardContent>
                <Typography variant="h4" fontWeight="bold" color="success.main">
                  {summary.total_chat_sessions}
                </Typography>
                <Typography variant="body1" fontWeight="bold">
                  Chat Sessions
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ bgcolor: 'rgba(255,255,255,0.9)' }}>
              <CardContent>
                <Typography variant="h4" fontWeight="bold" color="success.main">
                  {summary.total_generations}
                </Typography>
                <Typography variant="body1" fontWeight="bold">
                  AI Generations
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ bgcolor: 'rgba(255,255,255,0.9)' }}>
              <CardContent>
                <Typography variant="h4" fontWeight="bold" color="success.main">
                  {summary.total_memberships}
                </Typography>
                <Typography variant="body1" fontWeight="bold">
                  Class Memberships
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      </Paper>

      {/* EXPANDABLE SECTIONS */}

      {/* USERS TABLE */}
      <Accordion defaultExpanded>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography variant="h6" fontWeight="bold">
            ðŸ‘¥ Users ({users.length})
          </Typography>
        </AccordionSummary>
        <AccordionDetails>
          <TableContainer component={Paper}>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell><strong>Email</strong></TableCell>
                  <TableCell><strong>Full Name</strong></TableCell>
                  <TableCell><strong>Active</strong></TableCell>
                  <TableCell><strong>Classes</strong></TableCell>
                  <TableCell><strong>Assessments</strong></TableCell>
                  <TableCell><strong>Chat Sessions</strong></TableCell>
                  <TableCell><strong>Created</strong></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {users.map((user) => (
                  <TableRow key={user.id}>
                    <TableCell>{user.email}</TableCell>
                    <TableCell>{user.full_name || 'N/A'}</TableCell>
                    <TableCell>
                      <Chip label={user.is_active ? 'Yes' : 'No'} color={user.is_active ? 'success' : 'error'} size="small" />
                    </TableCell>
                    <TableCell>{user.classes_count}</TableCell>
                    <TableCell>{user.assessments_count}</TableCell>
                    <TableCell>{user.chat_sessions_count}</TableCell>
                    <TableCell>{user.created_at ? new Date(user.created_at).toLocaleDateString() : 'N/A'}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </AccordionDetails>
      </Accordion>

      {/* CLASSES TABLE */}
      <Accordion>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography variant="h6" fontWeight="bold">
            ðŸ« Classes ({classes.length})
          </Typography>
        </AccordionSummary>
        <AccordionDetails>
          <TableContainer component={Paper}>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell><strong>Name</strong></TableCell>
                  <TableCell><strong>Description</strong></TableCell>
                  <TableCell><strong>Owner</strong></TableCell>
                  <TableCell><strong>Students</strong></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {classes.map((cls) => (
                  <TableRow key={cls.id}>
                    <TableCell>{cls.name}</TableCell>
                    <TableCell>{cls.description || 'N/A'}</TableCell>
                    <TableCell>{cls.owner_email}</TableCell>
                    <TableCell>{cls.student_count}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </AccordionDetails>
      </Accordion>

      {/* STUDENTS TABLE */}
      <Accordion>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography variant="h6" fontWeight="bold">
            ðŸŽ“ Students ({students.length})
          </Typography>
        </AccordionSummary>
        <AccordionDetails>
          <TableContainer component={Paper}>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell><strong>Name</strong></TableCell>
                  <TableCell><strong>Student ID</strong></TableCell>
                  <TableCell><strong>Overall Grade</strong></TableCell>
                  <TableCell><strong>Classes</strong></TableCell>
                  <TableCell><strong>Class Names</strong></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {students.map((student) => (
                  <TableRow key={student.id}>
                    <TableCell>{student.name}</TableCell>
                    <TableCell>{student.studentId}</TableCell>
                    <TableCell>{student.overallGrade || 'N/A'}</TableCell>
                    <TableCell>{student.classes_count}</TableCell>
                    <TableCell>{student.classes.join(', ') || 'None'}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </AccordionDetails>
      </Accordion>

      {/* ASSESSMENTS TABLE */}
      <Accordion>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography variant="h6" fontWeight="bold">
            ðŸ“ Assessments ({assessments.length})
          </Typography>
        </AccordionSummary>
        <AccordionDetails>
          <TableContainer component={Paper}>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell><strong>ID</strong></TableCell>
                  <TableCell><strong>Status</strong></TableCell>
                  <TableCell><strong>Owner</strong></TableCell>
                  <TableCell><strong>Total Pages</strong></TableCell>
                  <TableCell><strong>Results</strong></TableCell>
                  <TableCell><strong>Created</strong></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {assessments.map((assessment) => (
                  <TableRow key={assessment.id}>
                    <TableCell>{assessment.id.substring(0, 8)}...</TableCell>
                    <TableCell>
                      <Chip label={assessment.status} color="primary" size="small" />
                    </TableCell>
                    <TableCell>{assessment.owner_email}</TableCell>
                    <TableCell>{assessment.total_pages || 'N/A'}</TableCell>
                    <TableCell>{assessment.results_count}</TableCell>
                    <TableCell>{assessment.created_at ? new Date(assessment.created_at).toLocaleDateString() : 'N/A'}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </AccordionDetails>
      </Accordion>

      {/* RESULTS TABLE (Limited to 100) */}
      <Accordion>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography variant="h6" fontWeight="bold">
            âœ… Results (Showing first 100 of {summary.total_results})
          </Typography>
        </AccordionSummary>
        <AccordionDetails>
          <TableContainer component={Paper}>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell><strong>Student</strong></TableCell>
                  <TableCell><strong>Question ID</strong></TableCell>
                  <TableCell><strong>Grade</strong></TableCell>
                  <TableCell><strong>Status</strong></TableCell>
                  <TableCell><strong>Finalized By</strong></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {results.map((result) => (
                  <TableRow key={result.id}>
                    <TableCell>{result.student_name || 'Unknown'}</TableCell>
                    <TableCell>{result.question_id}</TableCell>
                    <TableCell>{result.grade !== null ? result.grade : 'N/A'}</TableCell>
                    <TableCell>
                      <Chip label={result.status} size="small" />
                    </TableCell>
                    <TableCell>{result.finalized_by || 'N/A'}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </AccordionDetails>
      </Accordion>

      {/* OUTSIDER STUDENTS TABLE */}
      <Accordion>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography variant="h6" fontWeight="bold">
            ðŸ‘¤ Outsider Students ({outsider_students.length})
          </Typography>
        </AccordionSummary>
        <AccordionDetails>
          <TableContainer component={Paper}>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell><strong>Name</strong></TableCell>
                  <TableCell><strong>Job ID</strong></TableCell>
                  <TableCell><strong>Results Count</strong></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {outsider_students.map((student) => (
                  <TableRow key={student.id}>
                    <TableCell>{student.name}</TableCell>
                    <TableCell>{student.job_id.substring(0, 8)}...</TableCell>
                    <TableCell>{student.results_count}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </AccordionDetails>
      </Accordion>

      {/* CHAT SESSIONS TABLE */}
      <Accordion>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography variant="h6" fontWeight="bold">
            ðŸ’¬ Chat Sessions ({chat_sessions.length})
          </Typography>
        </AccordionSummary>
        <AccordionDetails>
          <TableContainer component={Paper}>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell><strong>Title</strong></TableCell>
                  <TableCell><strong>Owner</strong></TableCell>
                  <TableCell><strong>Messages</strong></TableCell>
                  <TableCell><strong>Created</strong></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {chat_sessions.map((session) => (
                  <TableRow key={session.id}>
                    <TableCell>{session.title || 'Untitled'}</TableCell>
                    <TableCell>{session.owner_email}</TableCell>
                    <TableCell>{session.messages_count}</TableCell>
                    <TableCell>{session.created_at ? new Date(session.created_at).toLocaleDateString() : 'N/A'}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </AccordionDetails>
      </Accordion>

      {/* AI GENERATIONS TABLE */}
      <Accordion>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography variant="h6" fontWeight="bold">
            ðŸ¤– AI Generations ({generations.length})
          </Typography>
        </AccordionSummary>
        <AccordionDetails>
          <TableContainer component={Paper}>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell><strong>Tool Type</strong></TableCell>
                  <TableCell><strong>Owner</strong></TableCell>
                  <TableCell><strong>Created</strong></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {generations.map((gen) => (
                  <TableRow key={gen.id}>
                    <TableCell>{gen.tool_type}</TableCell>
                    <TableCell>{gen.owner_email}</TableCell>
                    <TableCell>{gen.created_at ? new Date(gen.created_at).toLocaleDateString() : 'N/A'}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </AccordionDetails>
      </Accordion>

      {/* AI MODEL RUNS TABLE */}
      <Accordion>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography variant="h6" fontWeight="bold">
            ðŸ§  AI Model Runs ({ai_runs.length})
          </Typography>
        </AccordionSummary>
        <AccordionDetails>
          <TableContainer component={Paper}>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell><strong>Job ID</strong></TableCell>
                  <TableCell><strong>Question ID</strong></TableCell>
                  <TableCell><strong>Run Index</strong></TableCell>
                  <TableCell><strong>Grade</strong></TableCell>
                  <TableCell><strong>Created</strong></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {ai_runs.map((run) => (
                  <TableRow key={run.id}>
                    <TableCell>{run.job_id.substring(0, 8)}...</TableCell>
                    <TableCell>{run.question_id}</TableCell>
                    <TableCell>{run.run_index}</TableCell>
                    <TableCell>{run.grade !== null ? run.grade : 'N/A'}</TableCell>
                    <TableCell>{run.created_at ? new Date(run.created_at).toLocaleDateString() : 'N/A'}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </AccordionDetails>
      </Accordion>
    </Container>
  );
};

export default AdminDashboard;


--- File: .\ata-frontend\src\pages\AITools.jsx ---

// /src/pages/AITools.jsx

import React, { useState } from 'react'; // <<< IMPORT useState
import { Box, Typography, Grid, Button } from '@mui/material'; // <<< IMPORT Button

// Custom Component Imports
import ToolCard from '../components/tools/ToolCard';
import HistoryModal from '../components/tools/HistoryModal'; // <<< NEW IMPORT

// Icon Imports
import QuestionAnswerOutlined from '@mui/icons-material/QuestionAnswerOutlined';
import SlideshowOutlined from '@mui/icons-material/SlideshowOutlined';
import RuleOutlined from '@mui/icons-material/RuleOutlined';
import HistoryOutlined from '@mui/icons-material/HistoryOutlined'; // <<< NEW IMPORT

const aiToolsData = [
  {
    id: 'question-generator',
    title: 'Question Generator',
    description: 'Create quizzes and checks for understanding.',
    icon: <QuestionAnswerOutlined />,
    path: '/tools/question-generator',
  },
  {
    id: 'slide-generator',
    title: 'Slide Generator',
    description: 'Produce structured presentation outlines.',
    icon: <SlideshowOutlined />,
    path: '/tools/slide-generator',
  },
  {
    id: 'rubric-generator',
    title: 'Rubric Generator',
    description: 'Build detailed grading rubrics for assignments.',
    icon: <RuleOutlined />,
    path: '/tools/rubric-generator',
  },
];

/**
 * The main page for the "AI Tools" feature.
 * UPGRADED to manage and display the Generation History modal.
 */
const AITools = () => {
  // --- [START] NEW STATE MANAGEMENT ---
  const [isHistoryOpen, setIsHistoryOpen] = useState(false);
  // --- [END] NEW STATE MANAGEMENT ---

  return (
    <>
      <Box>
        {/* --- [START] UPGRADED PAGE HEADER --- */}
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
          <Typography variant="h2">
            AI Tools
          </Typography>
          <Button
            variant="outlined"
            startIcon={<HistoryOutlined />}
            onClick={() => setIsHistoryOpen(true)}
          >
            View History
          </Button>
        </Box>
        {/* --- [END] UPGRADED PAGE HEADER --- */}

        <Grid container spacing={3}>
          {aiToolsData.map((tool) => (
            <ToolCard key={tool.id} tool={tool} />
          ))}
        </Grid>
      </Box>

      {/* --- [START] NEW MODAL RENDER --- */}
      <HistoryModal
        open={isHistoryOpen}
        onClose={() => setIsHistoryOpen(false)}
      />
      {/* --- [END] NEW MODAL RENDER --- */}
    </>
  );
};

export default AITools;

--- File: .\ata-frontend\src\pages\Assessments.jsx ---

// /src/pages/Assessments.jsx (COMPLETE MERGED CODE)

import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { Box, Button, Typography, Stack, Skeleton, Alert, AlertTitle } from '@mui/material';
import AddOutlined from '@mui/icons-material/AddOutlined';
import AssignmentTurnedInOutlined from '@mui/icons-material/AssignmentTurnedInOutlined';

import AssessmentCard from '../components/assessments/AssessmentCard';
import ConfirmationModal from '../components/common/ConfirmationModal';
import assessmentService from '../services/assessmentService';
import { useSnackbar } from '../hooks/useSnackbar';

// --- [MISSING PART 1: ADDED BACK] ---
const EmptyState = ({ onGradeNew }) => (
  <Box sx={{ textAlign: 'center', mt: 8, p: 4, backgroundColor: 'grey.50', borderRadius: 2 }}>
    <AssignmentTurnedInOutlined sx={{ fontSize: 64, color: 'text.secondary', mb: 2 }} />
    <Typography variant="h3" gutterBottom>
      Grade your first assessment
    </Typography>
    <Typography color="text.secondary" sx={{ mb: 3, maxWidth: '500px', mx: 'auto' }}>
      Save hours of time by letting the AI do the heavy lifting. Create a new grading job to get started.
    </Typography>
    <Button variant="contained" startIcon={<AddOutlined />} onClick={onGradeNew}>
      Grade New Assessment
    </Button>
  </Box>
);
// --- [END OF MISSING PART 1] ---

// --- [MISSING PART 2: ADDED BACK] ---
const LoadingSkeletons = () => (
  <Stack spacing={3}>
    {Array.from(new Array(3)).map((_, index) => (
      <Skeleton key={index} variant="rectangular" height={150} sx={{ borderRadius: 2 }} />
    ))}
  </Stack>
);
// --- [END OF MISSING PART 2] ---

const Assessments = () => {
  const navigate = useNavigate();
  const { showSnackbar } = useSnackbar();
  const [assessments, setAssessments] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [jobToDelete, setJobToDelete] = useState(null);
  const [isConfirmOpen, setIsConfirmOpen] = useState(false);

  // --- [MISSING PART 3: ADDED BACK] ---
  const fetchAssessments = useCallback(async (isInitialLoad = false) => {
    if (isInitialLoad) setIsLoading(true);
    try {
      const data = await assessmentService.getAssessments();
      setAssessments(data || []);
      if (isInitialLoad) setError(null);
    } catch (err) {
      console.error("Failed to fetch assessments:", err);
      if (isInitialLoad) {
        setError("Could not load your assessments. Please try refreshing the page.");
      }
    } finally {
      if (isInitialLoad) setIsLoading(false);
    }
  }, []);
  // --- [END OF MISSING PART 3] ---

  // --- [MISSING PART 4: ADDED BACK] ---
  useEffect(() => {
    fetchAssessments(true); // Initial fetch
    const intervalId = setInterval(() => fetchAssessments(false), 10000);
    return () => clearInterval(intervalId);
  }, [fetchAssessments]);
  // --- [END OF MISSING PART 4] ---

  const handleOpenConfirm = (job) => {
    setJobToDelete(job);
    setIsConfirmOpen(true);
  };

  const handleCloseConfirm = () => {
    setJobToDelete(null);
    setIsConfirmOpen(false);
  };

  const handleConfirmDelete = async () => {
    if (!jobToDelete) return;
    try {
      await assessmentService.deleteAssessment(jobToDelete.id);
      showSnackbar('Assessment deleted successfully.', 'success');
      fetchAssessments(true);
    } catch (err) {
      showSnackbar(err.message || 'Failed to delete assessment.', 'error');
    } finally {
      handleCloseConfirm();
    }
  };

  const handleNavigateToNew = () => {
    navigate('/assessments/new');
  };

  const renderContent = () => {
    if (isLoading) return <LoadingSkeletons />;
    if (error) return <Alert severity="error"><AlertTitle>Error</AlertTitle>{error}</Alert>;
    if (assessments.length === 0) return <EmptyState onGradeNew={handleNavigateToNew} />;
    
    return (
      <Stack spacing={3}>
        {assessments.map((job) => (
          <AssessmentCard 
            key={job.id} 
            job={job}
            onDelete={() => handleOpenConfirm(job)} 
          />
        ))}
      </Stack>
    );
  };

  return (
    <Box>
      <Box sx={{
          display: 'flex',
          justifyContent: 'space-between',
          mb: 4,
          flexDirection: { xs: 'column', sm: 'row' },
          alignItems: { xs: 'stretch', sm: 'center' }
        }}>
        <Typography variant="h2" sx={{ mb: { xs: 2, sm: 0 } }}>
          Assessments
        </Typography>
        <Button variant="contained" startIcon={<AddOutlined />} onClick={handleNavigateToNew} sx={{ width: { xs: '100%', sm: 'auto' } }}>
          Grade New Assessment
        </Button>
      </Box>
      {renderContent()}
      
      <ConfirmationModal
        open={isConfirmOpen}
        onClose={handleCloseConfirm}
        onConfirm={handleConfirmDelete}
        title="Delete Assessment?"
        description={`Are you sure you want to permanently delete the assessment "${jobToDelete?.assessmentName}"? This action cannot be undone.`}
      />
    </Box>
  );
};

export default Assessments;

--- File: .\ata-frontend\src\pages\Chatbot.jsx ---

// /ata-frontend/src/pages/Chatbot.jsx (FINAL, DEFINITIVE, RACE-CONDITION-FREE)

import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Box, CircularProgress, Typography, IconButton } from '@mui/material';
import { v4 as uuidv4 } from 'uuid';
import HistoryIcon from '@mui/icons-material/History';

import MessageList from '../components/chatbot/MessageList';
import ChatInput from '../components/chatbot/ChatInput';
import ExamplePrompts from '../components/chatbot/ExamplePrompts';
import ChatHistoryPanel from '../components/chatbot/ChatHistoryPanel';
import useChatWebSocket from '../hooks/useChatWebSocket';
import chatService from '../services/chatService';
import { useSnackbar } from '../hooks/useSnackbar';

const Chatbot = () => {
  const { sessionId } = useParams();
  const navigate = useNavigate();
  const { showSnackbar } = useSnackbar();

  const [sessions, setSessions] = useState([]);
  const [messages, setMessages] = useState([]);
  const [isHistoryLoading, setIsHistoryLoading] = useState(true);
  const [isMessagesLoading, setIsMessagesLoading] = useState(false);
  const [isHistoryDrawerOpen, setIsHistoryDrawerOpen] = useState(false);
  
  // The hook is now simpler and only needs setMessages
  const { isThinking, isResponding, connect, sendMessage } = useChatWebSocket(setMessages);

  const fetchHistory = useCallback(async () => {
    setIsHistoryLoading(true);
    try {
      const data = await chatService.getChatSessions();
      setSessions(data);
    } catch (error) {
      showSnackbar(error.message, 'error');
    } finally {
      setIsHistoryLoading(false);
    }
  }, [showSnackbar]);

  useEffect(() => {
    fetchHistory();
  }, [fetchHistory]);

  useEffect(() => {
    // This effect connects the WebSocket when a session ID is present.
    if (sessionId) {
      connect(sessionId);
    }
  }, [sessionId, connect]);

  useEffect(() => {
    // This effect loads the message history for the current session.
    const loadSession = async () => {
      if (sessionId) {
        setIsMessagesLoading(true);
        try {
          const sessionDetails = await chatService.getChatSessionDetails(sessionId);
          const formattedMessages = sessionDetails.history.map(msg => ({
            id: msg.id || `msg_hist_${uuidv4()}`, // Prefer the real ID from the DB
            role: msg.role,
            content: msg.content,
            file_id: msg.file_id
          }));
          setMessages(formattedMessages);
        } catch (error) {
          showSnackbar(error.message, 'error');
          navigate('/chat');
        } finally {
          setIsMessagesLoading(false);
        }
      } else {
        // This is the initial state for a new, unsaved chat.
        setMessages([{
          id: `msg_bot_initial`,
          role: 'bot',
          content: "Hello! I'm My Smart Teach, your AI assistant. How can I help you with your teaching tasks today?"
        }]);
      }
    };
    loadSession();
  }, [sessionId, showSnackbar, navigate]);


  const handleHistoryDrawerToggle = () => setIsHistoryDrawerOpen(!isHistoryDrawerOpen);
  const handleNewChat = () => navigate('/chat');
  const handleSessionSelect = (selectedSessionId) => {
    if (sessionId !== selectedSessionId) {
      navigate(`/chat/${selectedSessionId}`);
    }
    setIsHistoryDrawerOpen(false);
  };

  const handleDeleteSession = async (sessionIdToDelete) => {
    try {
      await chatService.deleteChatSession(sessionIdToDelete);
      await fetchHistory();
      if (sessionId === sessionIdToDelete) {
          navigate('/chat', { replace: true });
      }
      showSnackbar('Chat deleted successfully', 'success');
    } catch (error) {
        showSnackbar(error.message, 'error');
    }
  };

  // --- [THE DEFINITIVE FIX IS HERE] ---
  const handleSendMessage = useCallback(async (messageText, fileId = null) => {
    if (!sessionId) {
      // --- Logic for the VERY FIRST message in a NEW chat ---
      try {
        // 1. Create the session on the backend. The backend now saves the first message.
        const { sessionId: newSessionId } = await chatService.createNewChatSession(messageText, fileId);
        
        // 2. Navigate to the new session's URL.
        // This will trigger the useEffect hooks to load the history (which now includes
        // the first message) and connect the WebSocket.
        navigate(`/chat/${newSessionId}`);
        
        // 3. After navigating, we also need to trigger the AI response for the first message.
        // We do this by sending the message over the WebSocket.
        sendMessage(messageText, fileId);

      } catch (error) {
        showSnackbar(error.message, 'error');
      }
    } else {
      // --- Logic for all SUBSEQUENT messages in an EXISTING chat ---
      // This is the standard optimistic update flow.
      const userMessage = {
        id: `msg_client_${uuidv4()}`,
        role: 'user',
        content: messageText,
        file_id: fileId,
      };
      setMessages(prev => [...prev, userMessage]);
      sendMessage(messageText, fileId);
    }
  }, [sessionId, navigate, showSnackbar, sendMessage]);
  // --- [END OF FIX] ---
  
  const handleStopGeneration = () => {
    // TODO: Implement stop generation functionality
  };
  const handleFileUpload = (file) => {
    // TODO: Implement file upload functionality
  };

  const isInputDisabled = isThinking || isResponding || isMessagesLoading;

  return (
    <Box sx={{ display: 'flex', height: 'calc(100vh - 64px - 48px)' }}>
      <ChatHistoryPanel
        sessions={sessions}
        activeSessionId={sessionId}
        onSessionSelect={handleSessionSelect}
        onNewChat={handleNewChat}
        onDeleteSession={handleDeleteSession}
        isLoading={isHistoryLoading}
        mobileOpen={isHistoryDrawerOpen}
        onMobileClose={() => setIsHistoryDrawerOpen(false)}
      />
      <Box sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
        <Box sx={{ display: 'flex', alignItems: 'center', p: 2, borderBottom: 1, borderColor: 'divider', flexShrink: 0 }}>
          <Typography variant="h3" sx={{ flexGrow: 1 }}>Chat</Typography>
          <IconButton
            color="inherit"
            aria-label="open history"
            edge="end"
            onClick={handleHistoryDrawerToggle}
            sx={{ display: { md: 'none' } }}
          >
            <HistoryIcon />
          </IconButton>
        </Box>

        {isMessagesLoading ? (
          <Box sx={{flexGrow: 1, display: 'flex', alignItems: 'center', justifyContent: 'center'}}>
            <CircularProgress />
          </Box>
        ) : (
          <MessageList messages={messages} isThinking={isThinking}>
            {/* ExamplePrompts are correctly disabled for V1 */}
            {false && !sessionId && messages.length <= 1 && (
              <ExamplePrompts onPromptClick={handleSendMessage} />
            )}
          </MessageList>
        )}
        <ChatInput
          onSendMessage={handleSendMessage}
          disabled={isInputDisabled}
          isResponding={isResponding}
          onStopGeneration={handleStopGeneration}
          onFileUpload={handleFileUpload}
        />
      </Box>
    </Box>
  );
};

export default Chatbot;

--- File: .\ata-frontend\src\pages\ClassDetails.jsx ---

// /src/pages/ClassDetails.jsx (FINAL ENHANCED VERSION)

// --- Core React & Router Imports ---
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, Link as RouterLink, useNavigate } from 'react-router-dom';

// --- MUI Component Imports ---
import { Box, Button, Typography, Grid, Skeleton, Alert, AlertTitle, Breadcrumbs, Link, Stack, IconButton, Tooltip, CircularProgress, Menu, MenuItem, ListItemIcon } from '@mui/material';

// --- Icon Imports ---
import AddOutlined from '@mui/icons-material/AddOutlined';
import EditOutlined from '@mui/icons-material/EditOutlined';
import DeleteOutlineOutlined from '@mui/icons-material/DeleteOutlineOutlined';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import DownloadOutlined from '@mui/icons-material/DownloadOutlined';
import PeopleAltOutlined from '@mui/icons-material/PeopleAltOutlined';
import FunctionsOutlined from '@mui/icons-material/FunctionsOutlined';
import FactCheckOutlined from '@mui/icons-material/FactCheckOutlined';

// --- Custom Component Imports ---
import InfoCard from '../components/home/InfoCard';
import StudentTable from '../components/classes/StudentTable';
import StudentModal from '../components/classes/StudentModal';
import ConfirmationModal from '../components/common/ConfirmationModal';
import ClassEditModal from '../components/classes/ClassEditModal';

// --- Service Import ---
import classService from '../services/classService';
import { useSnackbar } from '../hooks/useSnackbar';

/**
 * The "Class Details" page, with full advanced management capabilities.
 */
const ClassDetails = () => {
  // --- Hooks ---
  const { class_id } = useParams();
  const navigate = useNavigate();
  const { showSnackbar } = useSnackbar();

  // --- State Management ---
  const [classData, setClassData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  // State organized by feature for clarity
  const [studentModal, setStudentModal] = useState({ open: false, mode: 'add', data: null, state: { isLoading: false, error: null } });
  const [classEditModal, setClassEditModal] = useState({ open: false, state: { isLoading: false, error: null } });
  const [deleteConfirmation, setDeleteConfirmation] = useState({ open: false, type: null, data: null });
  const [menuAnchorEl, setMenuAnchorEl] = useState(null);

  // --- Data Fetching ---
  const fetchClassDetails = useCallback(async () => {
    try {
      setIsLoading(true);
      const data = await classService.getClassById(class_id);
      setClassData(data);
      setError(null);
    } catch (err) {
      console.error(`Error fetching class details:`, err);
      setError(err.message || "Could not load class details.");
    } finally {
      setIsLoading(false);
    }
  }, [class_id]);

  useEffect(() => { fetchClassDetails(); }, [fetchClassDetails]);

  // --- Event Handlers ---
  const handleOpenAddStudentModal = () => setStudentModal({ open: true, mode: 'add', data: null, state: { isLoading: false, error: null } });
  const handleOpenEditStudentModal = (student) => setStudentModal({ open: true, mode: 'edit', data: student, state: { isLoading: false, error: null } });
  const handleStudentModalClose = () => setStudentModal(prev => ({ ...prev, open: false }));

  const handleStudentModalSubmit = async (formData) => {
    setStudentModal(prev => ({ ...prev, state: { isLoading: true, error: null } }));
    try {
      if (studentModal.mode === 'add') {
        await classService.addStudentToClass(class_id, formData);
        showSnackbar('Student added successfully!', 'success');
      } else {
        await classService.updateStudent(class_id, studentModal.data.id, formData);
        showSnackbar('Student updated successfully!', 'success');
      }
      handleStudentModalClose();
      await fetchClassDetails();
    } catch (err) {
      setStudentModal(prev => ({ ...prev, state: { isLoading: false, error: err.message } }));
    }
  };

  const handleOpenConfirmStudentDelete = (student) => setDeleteConfirmation({ open: true, type: 'student', data: student });
  const handleDeleteStudent = async () => {
    try {
      await classService.removeStudent(class_id, deleteConfirmation.data.id);
      showSnackbar('Student removed successfully.', 'success');
      setDeleteConfirmation({ open: false, type: null, data: null });
      await fetchClassDetails();
    } catch (err)
{
      showSnackbar(err.message, 'error');
      setDeleteConfirmation({ open: false, type: null, data: null });
    }
  };

  const handleMenuOpen = (event) => setMenuAnchorEl(event.currentTarget);
  const handleMenuClose = () => setMenuAnchorEl(null);
  const handleOpenClassEditModal = () => { setClassEditModal({ open: true, state: { isLoading: false, error: null } }); handleMenuClose(); };
  const handleClassEditModalClose = () => setClassEditModal(prev => ({ ...prev, open: false }));

  const handleClassEditModalSubmit = async (formData) => {
    setClassEditModal(prev => ({ ...prev, state: { isLoading: true, error: null } }));
    try {
      await classService.updateClass(class_id, formData);
      showSnackbar('Class details updated successfully!', 'success');
      handleClassEditModalClose();
      await fetchClassDetails();
    } catch (err) {
      setClassEditModal(prev => ({ ...prev, state: { isLoading: false, error: err.message } }));
    }
  };

  const handleExportRoster = async () => {
    try {
      showSnackbar('Preparing your download...', 'info');
      await classService.exportClassRoster(class_id);
    } catch(err) {
      showSnackbar(err.message, 'error');
    }
    handleMenuClose();
  };

  const handleOpenConfirmClassDelete = () => { setDeleteConfirmation({ open: true, type: 'class', data: classData }); handleMenuClose(); };
  const handleDeleteClass = async () => {
    try {
      await classService.deleteClass(class_id);
      showSnackbar('Class deleted successfully.', 'success');
      setDeleteConfirmation({ open: false, type: null, data: null });
      navigate('/classes');
    } catch (err) {
      showSnackbar(err.message, 'error');
      setDeleteConfirmation({ open: false, type: null, data: null });
    }
  };
  const handleCloseConfirmDelete = () => setDeleteConfirmation({ open: false, type: null, data: null });

  // --- Render Logic ---
  if (isLoading) return <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}><CircularProgress /></Box>;
  if (error) return <Box sx={{ p: 3 }}><Alert severity="error"><AlertTitle>Error</AlertTitle>{error}</Alert></Box>;
  if (!classData) return <Box sx={{ p: 3 }}><Alert severity="warning">Could not find class data.</Alert></Box>;

  const confirmationDescription = deleteConfirmation.type === 'student'
    ? `Are you sure you want to remove ${deleteConfirmation.data?.name}? This action cannot be undone.`
    : `Are you sure you want to delete the class "${deleteConfirmation.data?.name}"? All associated students will also be removed. This action is irreversible.`;

  const analyticsCards = [
      { id: 'count', title: 'Total Students', value: classData.analytics.studentCount, icon: <PeopleAltOutlined /> },
      { id: 'avg', title: 'Class Average', value: `${classData.analytics.classAverage}%`, icon: <FunctionsOutlined /> },
      { id: 'graded', title: 'Assessments Graded', value: classData.analytics.assessmentsGraded, icon: <FactCheckOutlined /> },
  ];
  
  return (
    <>
      <Box sx={{ mb: 4 }}>
        <Breadcrumbs aria-label="breadcrumb" sx={{ mb: 2 }}>
          <Link component={RouterLink} underline="hover" color="inherit" to="/classes">Your Classes</Link>
          <Typography color="text.primary">{classData.name}</Typography>
        </Breadcrumbs>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: 2 }}>
            {/* FIX #1: Added wordBreak to prevent long class names from causing overflow */}
            <Typography variant="h2" sx={{ wordBreak: 'break-word' }}>{classData.name}</Typography>
            <Stack direction="row" spacing={1} alignItems="center">
                <Button variant="contained" startIcon={<AddOutlined />} onClick={handleOpenAddStudentModal}>Add Student</Button>
                <Tooltip title="Class Options"><IconButton onClick={handleMenuOpen}><MoreVertIcon /></IconButton></Tooltip>
            </Stack>
        </Box>
      </Box>

      <Grid container spacing={3} sx={{ mb: 4 }}>
        {analyticsCards.map(card => (<Grid item xs={12} sm={6} md={4} key={card.id}><InfoCard title={card.title} value={card.value} icon={card.icon} /></Grid>))}
      </Grid>
      
      {/* FIX #2: Made the table container more robust to ensure it contains the scroll */}
      <Box sx={{ width: '100%', overflow: 'auto' }}>
        <StudentTable students={classData.students} onEdit={handleOpenEditStudentModal} onDelete={handleOpenConfirmStudentDelete} />
      </Box>

      <Menu anchorEl={menuAnchorEl} open={Boolean(menuAnchorEl)} onClose={handleMenuClose}>
        <MenuItem onClick={handleOpenClassEditModal}><ListItemIcon><EditOutlined fontSize="small"/></ListItemIcon>Edit Details</MenuItem>
        <MenuItem onClick={handleExportRoster}><ListItemIcon><DownloadOutlined fontSize="small"/></ListItemIcon>Export Roster (.csv)</MenuItem>
        <MenuItem onClick={handleOpenConfirmClassDelete} sx={{ color: 'error.main' }}><ListItemIcon><DeleteOutlineOutlined fontSize="small" color="error"/></ListItemIcon>Delete Class</MenuItem>
      </Menu>

      <StudentModal open={studentModal.open} onClose={handleStudentModalClose} onSubmit={handleStudentModalSubmit} mode={studentModal.mode} initialData={studentModal.data} isLoading={studentModal.state.isLoading} error={studentModal.state.error}/>
      <ClassEditModal open={classEditModal.open} onClose={handleClassEditModalClose} onSubmit={handleClassEditModalSubmit} initialData={classData} isLoading={classEditModal.state.isLoading} error={classEditModal.state.error}/>
      <ConfirmationModal open={deleteConfirmation.open} onClose={handleCloseConfirmDelete} onConfirm={deleteConfirmation.type === 'student' ? handleDeleteStudent : handleDeleteClass} title={`Delete ${deleteConfirmation.type === 'student' ? 'Student' : 'Class'}`} description={confirmationDescription}/>
    </>
  );
};

export default ClassDetails;

--- File: .\ata-frontend\src\pages\Classes.jsx ---

// /src/pages/Classes.jsx (FINAL, ROBUST VERSION)

// --- Core React Imports ---
import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';

// --- MUI Component Imports ---
import { Box, Button, Typography, Grid, Skeleton, Alert, AlertTitle } from '@mui/material';
import AddOutlined from '@mui/icons-material/AddOutlined';

// --- Custom Component Imports ---
import ClassCard from '../components/classes/ClassCard';
import AddClassModal from '../components/classes/AddClassModal';

// --- Service Import for Backend Communication ---
import classService from '../services/classService';

// --- Sub-Component for the Empty State ---
const EmptyState = ({ onAddClass }) => (
  <Box sx={{ textAlign: 'center', mt: 8 }}>
    <Typography variant="h3" gutterBottom>Create your first class</Typography>
    <Typography color="text.secondary" sx={{ mb: 3 }}>
      Get started by adding a class and its students, either manually or by uploading a roster.
    </Typography>
    <Button variant="contained" startIcon={<AddOutlined />} onClick={onAddClass}>
      Add New Class
    </Button>
  </Box>
);

/**
 * The main dashboard page for the "Your Classes" feature. This is the final,
 * robust version with all bug fixes and defensive checks.
 */
const Classes = () => {
  const navigate = useNavigate();
  const [classes, setClasses] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalState, setModalState] = useState({ isLoading: false, error: null });

  const fetchClasses = useCallback(async () => {
    try {
      setIsLoading(true);
      const data = await classService.getAllClasses();
      setClasses(data);
      setError(null);
    } catch (err) {
      console.error("Failed to fetch classes:", err);
      setError(err.message || "Could not load your classes.");
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchClasses();
  }, [fetchClasses]);

  const handleOpenModal = () => {
    setModalState({ isLoading: false, error: null });
    setIsModalOpen(true);
  };
  const handleCloseModal = () => setIsModalOpen(false);

  const handleSubmit = async (classData) => {
    setModalState({ isLoading: true, error: null });
    try {
      if (classData.file) {
        await classService.createClassWithUpload(classData.name, classData.file);
      } else {
        await classService.createClass(classData);
      }
      handleCloseModal();
      await fetchClasses();
    } catch (err) {
      console.error("Failed to create class:", err);
      setModalState({ isLoading: false, error: err.message || "Failed to create class." });
    }
  };

  const renderContent = () => {
    if (isLoading) {
      return (
        <Grid container spacing={3}>
          {Array.from(new Array(3)).map((_, index) => (
            <Grid item xs={12} sm={6} md={4} lg={3} key={index}>
              <Skeleton variant="rectangular" height={200} sx={{ borderRadius: 2 }} />
            </Grid>
          ))}
        </Grid>
      );
    }
    if (error) {
      return <Alert severity="error"><AlertTitle>Error</AlertTitle>{error}</Alert>;
    }
    // <<< CORRECTION: Added a defensive check to prevent crashes if the API
    // ever returns something that isn't an array.
    if (!Array.isArray(classes)) {
      return <Alert severity="warning">Could not display class data due to an unexpected format.</Alert>;
    }
    if (classes.length === 0) {
      return <EmptyState onAddClass={handleOpenModal} />;
    }
    return (
      <Grid container spacing={3}>
        {classes.map((classItem) => (
          <ClassCard key={classItem.id} classData={classItem} />
        ))}
      </Grid>
    );
  };

  return (
    <>
      <Box>
        <Box sx={{
          display: 'flex',
          justifyContent: 'space-between',
          mb: 4,
          flexDirection: { xs: 'column', sm: 'row' },
          alignItems: { xs: 'stretch', sm: 'center' }
        }}>
          <Typography variant="h2" sx={{ mb: { xs: 2, sm: 0 } }}>
            Your Classes
          </Typography>
          <Button variant="contained" startIcon={<AddOutlined />} onClick={handleOpenModal} sx={{ width: { xs: '100%', sm: 'auto' } }}>
            Add New Class
          </Button>
        </Box>
        {renderContent()}
      </Box>

      <AddClassModal
        open={isModalOpen}
        onClose={handleCloseModal}
        onSubmit={handleSubmit}
        isLoading={modalState.isLoading}
        error={modalState.error}
      />
    </>
  );
};

export default Classes;

--- File: .\ata-frontend\src\pages\Home.jsx ---

// /src/pages/Home.jsx

// --- Core React Imports ---
import React, { useState, useEffect } from 'react';

// --- MUI Component Imports ---
import { Box, Stack, Grid, CircularProgress, Alert, AlertTitle } from '@mui/material';

// --- Custom Component Imports ---
// This "smart" page imports the "dumb" presentational components it will orchestrate.
import GreetingBanner from '../components/home/GreetingBanner';
import InfoCard from '../components/home/InfoCard';
import NavCard from '../components/home/NavCard';

// --- Service & Icon Imports ---
import dashboardService from '../services/dashboardService';
import SchoolOutlined from '@mui/icons-material/SchoolOutlined';
import PeopleAltOutlined from '@mui/icons-material/PeopleAltOutlined';
import AutoAwesomeOutlined from '@mui/icons-material/AutoAwesomeOutlined';
import GradingOutlined from '@mui/icons-material/GradingOutlined';
import SmartToyOutlined from '@mui/icons-material/SmartToyOutlined';

/**
 * The Home Page component. Acts as a smart container to orchestrate the layout,
 * fetch summary data from the backend, and render the primary navigation and info cards.
 */
const Home = () => {
  // --- State Management ---
  // State to hold the summary data fetched from the API.
  const [summaryData, setSummaryData] = useState(null);
  // State to track the loading status of the API call.
  const [isLoading, setIsLoading] = useState(true);
  // State to hold any potential error message from the API call.
  const [error, setError] = useState(null);

  // --- Data Fetching Side Effect ---
  // The useEffect hook with an empty dependency array [] runs only once
  // when the component first mounts.
  useEffect(() => {
    // Define an async function to fetch the data.
    const fetchSummaryData = async () => {
      try {
        // We don't need to set isLoading(true) here as it's the default.
        const data = await dashboardService.getSummary();
        setSummaryData(data); // On success, store the data in state.
        setError(null); // Clear any previous errors.
      } catch (err) {
        // If the service layer throws an error, we catch it here.
        console.error("Failed to fetch dashboard summary:", err);
        setError(err.message); // Store the user-friendly error message.
      } finally {
        // This block runs regardless of success or failure.
        setIsLoading(false); // Stop showing the loading indicator.
      }
    };

    fetchSummaryData();
  }, []); // The empty array means this effect does not re-run on component updates.

  // --- Data Structures for Child Components ---
  // We transform the raw API data into the specific shape our components expect.
  const infoCardData = [
    {
      id: 'classes',
      title: 'Active Classes',
      value: summaryData?.classCount ?? 0, // Use optional chaining and nullish coalescing for safety.
      icon: <SchoolOutlined />,
    },
    {
      id: 'students',
      title: 'Total Students',
      value: summaryData?.studentCount ?? 0,
      icon: <PeopleAltOutlined />,
    },
  ];

  // This data is static for V1 but defined here for easy maintenance.
  const navCardData = [
    {
      id: 'classes', title: 'Your Classes', description: 'Manage rosters and track student performance.',
      icon: <SchoolOutlined />, path: '/classes', iconBgColor: '#E9E4F8', iconColor: '#5403FF',
    },
    {
      id: 'tools', title: 'AI Tools', description: 'Generate questions, slides, and other materials.',
      icon: <AutoAwesomeOutlined />, path: '/tools', iconBgColor: '#E0F2F1', iconColor: '#00796B',
    },
    {
        id: 'assessments', title: 'Assessments', description: 'Grade exams and provide automated feedback.',
        icon: <GradingOutlined />, path: '/assessments', iconBgColor: '#E3F2FD', iconColor: '#1E88E5',
    },
    {
        id: 'chatbot', title: 'Chatbot', description: 'Ask questions and get insights from your data.',
        icon: <SmartToyOutlined />, path: '/chat', iconBgColor: '#FFF8E1', iconColor: '#FFA000',
    }
  ];

  // --- Conditional Rendering for Loading and Error States ---
  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '60vh' }}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Alert severity="error">
        <AlertTitle>Error Loading Dashboard</AlertTitle>
        {error}
      </Alert>
    );
  }

  // --- Main Render Output on Success ---
  return (
    <Box>
      <GreetingBanner />

      <Stack
        direction={{ xs: 'column', sm: 'row' }}
        spacing={3}
        sx={{ mb: 5 }}
      >
        {infoCardData.map((card) => (
          <InfoCard
            key={card.id}
            icon={card.icon}
            value={card.value}
            title={card.title}
          />
        ))}
      </Stack>

      <Grid container spacing={3}>
        {navCardData.map((card) => (
          <NavCard key={card.id} item={card} />
        ))}
      </Grid>
    </Box>
  );
};

export default Home;

--- File: .\ata-frontend\src\pages\Login.jsx ---

// /src/pages/Login.jsx (ENHANCED A+ VERSION)

// --- Core React & Router Imports ---
import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation, Link as RouterLink } from 'react-router-dom';

// --- MUI Component Imports ---
import {
  Box, Paper, Typography, TextField, Button, Stack,
  CircularProgress, Alert, Link, FormControlLabel, Checkbox,
  Grid, Dialog, DialogTitle, DialogContent, DialogActions, IconButton, InputAdornment
} from '@mui/material';

// --- MUI Icon Imports ---
import CloseIcon from '@mui/icons-material/Close';
import Visibility from '@mui/icons-material/Visibility';
import VisibilityOff from '@mui/icons-material/VisibilityOff';

// --- Custom Hook & Asset Imports ---
import { useAuth } from '../hooks/useAuth';
import { useSnackbar } from '../hooks/useSnackbar';
import { useThemeMode } from '../hooks/useThemeMode';
import lightLogo from '../assets/mst_logo_no_bg.png';
import darkLogo from '../assets/mst_logo_dark_no_bg.png';


/**
 * The A+ enhanced Login page component with "Remember Me", "Forgot Password",
 * and a password visibility toggle.
 */
const Login = () => {
  // --- Hook Initialization ---
  const navigate = useNavigate();
  const location = useLocation();
  const { login } = useAuth();
  const { showSnackbar } = useSnackbar();
  const { mode } = useThemeMode();

  // --- Local State Management ---
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [rememberMe, setRememberMe] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  
  // A+ ENHANCEMENT: State for password visibility
  const [showPassword, setShowPassword] = useState(false);

  const [isForgotModalOpen, setIsForgotModalOpen] = useState(false);
  const [recoveryEmail, setRecoveryEmail] = useState('');

  const from = location.state?.from?.pathname || '/';

  // --- Side Effect for "Remember Me" ---
  useEffect(() => {
    const savedEmail = localStorage.getItem('rememberedEmail');
    if (savedEmail) {
      setEmail(savedEmail);
      setRememberMe(true);
    }
  }, []);


  // --- Event Handlers ---
  const handleSubmit = async (event) => {
    event.preventDefault();
    setIsLoading(true);
    setError('');
    try {
      await login(email, password);
      showSnackbar('Login successful!', 'success');

      if (rememberMe) {
        localStorage.setItem('rememberedEmail', email);
      } else {
        localStorage.removeItem('rememberedEmail');
      }

      // Check if this is the admin user
      if (email === 'mehran.gharuni.admin@admin.com') {
        navigate('/admin', { replace: true });
      } else {
        navigate(from, { replace: true });
      }
    } catch (err) {
      setError(err.message || 'An unexpected error occurred. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };
  
  // A+ ENHANCEMENT: Handlers for the visibility toggle
  const handleClickShowPassword = () => setShowPassword((show) => !show);
  const handleMouseDownPassword = (event) => {
    event.preventDefault();
  };

  const handlePasswordRecovery = () => {
    if (recoveryEmail.trim() && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(recoveryEmail)) {
      showSnackbar('Password recovery is a future feature. Thank you for your interest!', 'info');
      setRecoveryEmail('');
      setIsForgotModalOpen(false);
    } else {
      showSnackbar('Please enter a valid email address.', 'warning');
    }
  };
  
  const canSubmit = email.trim() !== '' && password.trim() !== '';

  return (
    <>
      <Box
        sx={{
          display: 'flex', flexDirection: 'column', alignItems: 'center',
          justifyContent: 'center', minHeight: '100vh',
          backgroundColor: (theme) => theme.palette.mode === 'light' ? theme.palette.grey[100] : theme.palette.background.default,
        }}
      >
        <Paper
          elevation={3}
          sx={{
            padding: { xs: 3, sm: 4 }, display: 'flex', flexDirection: 'column',
            alignItems: 'center', maxWidth: '400px', width: '100%',
          }}
        >
          <Box
            component="img"
            src={mode === 'light' ? lightLogo : darkLogo}
            sx={{ height: 100, mb: 2 }}
            alt="My Smart Teach Logo"
          />

          <Typography component="h1" variant="h2" sx={{ mb: 3 }}>
            Sign In
          </Typography>

          {error && (
            <Alert severity="error" sx={{ width: '100%', mb: 2 }}>{error}</Alert>
          )}

          <Box component="form" onSubmit={handleSubmit} noValidate sx={{ width: '100%' }}>
            <Stack spacing={2}>
              <TextField required fullWidth id="email" label="Email Address" name="email"
                autoComplete="email" autoFocus value={email}
                onChange={(e) => setEmail(e.target.value)} disabled={isLoading}
              />
              <TextField required fullWidth name="password" label="Password"
                id="password" autoComplete="current-password" value={password}
                onChange={(e) => setPassword(e.target.value)} disabled={isLoading}
                // A+ ENHANCEMENT: Dynamic type and visibility toggle icon
                type={showPassword ? 'text' : 'password'}
                InputProps={{
                  endAdornment: (
                    <InputAdornment position="end">
                      <IconButton
                        aria-label="toggle password visibility"
                        onClick={handleClickShowPassword}
                        onMouseDown={handleMouseDownPassword}
                        edge="end"
                      >
                        {showPassword ? <VisibilityOff /> : <Visibility />}
                      </IconButton>
                    </InputAdornment>
                  ),
                }}
              />
              
              <Grid container alignItems="center" justifyContent="space-between">
                <Grid item>
                  <FormControlLabel
                    control={<Checkbox value="remember" color="primary"
                        checked={rememberMe}
                        onChange={(e) => setRememberMe(e.target.checked)}
                      />
                    }
                    label={<Typography variant="body2">Remember me</Typography>}
                  />
                </Grid>
                <Grid item>
                  <Button
                    variant="text" size="small"
                    onClick={() => setIsForgotModalOpen(true)}
                    sx={{ textTransform: 'none', fontWeight: 'normal' }}
                  >
                    Forgot password?
                  </Button>
                </Grid>
              </Grid>

              <Button
                type="submit" fullWidth variant="contained"
                disabled={isLoading || !canSubmit}
                sx={{ mt: 1, mb: 2, py: 1.5 }}
              >
                {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Sign In'}
              </Button>
            </Stack>
          </Box>

          <Typography variant="body2" color="text.secondary" align="center" sx={{ mt: 3 }}>
            {"Don't have an account? "}
            <Link component={RouterLink} to="/register" variant="body2">Sign Up</Link>
          </Typography>
        </Paper>
      </Box>

      {/* "Forgot Password" Modal Dialog */}
      <Dialog open={isForgotModalOpen} onClose={() => setIsForgotModalOpen(false)} fullWidth maxWidth="xs">
        <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          Reset Password
          <IconButton edge="end" onClick={() => setIsForgotModalOpen(false)} aria-label="close">
            <CloseIcon />
          </IconButton>
        </DialogTitle>
        <DialogContent>
          <Typography variant="body2" sx={{ mb: 2 }}>
            This feature is coming soon. For now, this is a placeholder.
          </Typography>
          <TextField
            autoFocus margin="dense" id="recovery-email" label="Email Address"
            type="email" fullWidth variant="outlined" value={recoveryEmail}
            onChange={(e) => setRecoveryEmail(e.target.value)}
          />
        </DialogContent>
        <DialogActions sx={{ p: 2, pt: 0 }}>
          <Button onClick={() => setIsForgotModalOpen(false)} variant="outlined">Cancel</Button>
          <Button onClick={handlePasswordRecovery} variant="contained">
            Send Recovery Link
          </Button>
        </DialogActions>
      </Dialog>
    </>
  );
};

export default Login;

--- File: .\ata-frontend\src\pages\Register.jsx ---

// /src/pages/Register.jsx (ENHANCED, UNIFIED, AND FLAWLESS)

// --- Core React & Router Imports ---
import React, { useState } from 'react';
import { useNavigate, Link as RouterLink } from 'react-router-dom';

// --- MUI Component Imports ---
import {
  Box, Paper, Typography, TextField, Button, Stack,
  CircularProgress, Alert, Link, Avatar, FormControlLabel, Checkbox
} from '@mui/material';
import PersonAddOutlinedIcon from '@mui/icons-material/PersonAddOutlined';

// --- Custom Hook & Asset Imports ---
import { useAuth } from '../hooks/useAuth';
import { useSnackbar } from '../hooks/useSnackbar';
import { useThemeMode } from '../hooks/useThemeMode';
import lightLogo from '../assets/mst_logo_no_bg.png';
import darkLogo from '../assets/mst_logo_dark_no_bg.png';

/**
 * The enhanced Register page with client-side validation and terms agreement.
 */
const Register = () => {
  // --- Hook Initialization ---
  const navigate = useNavigate();
  const { register } = useAuth();
  const { showSnackbar } = useSnackbar();
  const { mode } = useThemeMode();

  // --- Local State Management ---
  const [formData, setFormData] = useState({ fullName: '', email: '', password: '' });
  const [agreedToTerms, setAgreedToTerms] = useState(false);
  const [errors, setErrors] = useState({});
  const [isLoading, setIsLoading] = useState(false);
  const [serverError, setServerError] = useState('');

  // --- Real-time Validation Logic ---
  const validateField = (name, value) => {
    let errorMsg = '';
    if (name === 'fullName' && value.trim().length > 0 && value.trim().length < 3) {
      errorMsg = 'Full name must be at least 3 characters.';
    }
    if (name === 'email' && value.trim().length > 0 && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
      errorMsg = 'Please enter a valid email address.';
    }
    if (name === 'password' && value.length > 0 && value.length < 8) {
      errorMsg = 'Password must be at least 8 characters.';
    }
    return errorMsg;
  };

  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    // Validate on change and clear the error if the input becomes valid
    const validationError = validateField(name, value);
    setErrors(prev => ({ ...prev, [name]: validationError }));
  };
  
  // --- Form Submission Handler ---
  const handleSubmit = async (event) => {
    event.preventDefault();
    setServerError('');
    setIsLoading(true);

    try {
      // Final validation before submitting
      const finalErrors = {};
      Object.keys(formData).forEach(key => {
        const error = validateField(key, formData[key]);
        if (error) finalErrors[key] = error;
      });

      if (Object.keys(finalErrors).length > 0) {
        setErrors(finalErrors);
        throw new Error("Please correct the errors before submitting.");
      }

      await register(formData.fullName, formData.email, formData.password);
      showSnackbar('Account created successfully! Please sign in.', 'success');
      navigate('/login');
    } catch (err) {
      // Errors from the validate function will be caught here,
      // as well as errors from the backend.
      setServerError(err.message || 'An unexpected error occurred.');
    } finally {
      setIsLoading(false);
    }
  };

  // Check if the form is valid and terms are agreed to for enabling the submit button.
  const canSubmit = 
    !Object.values(errors).some(error => error !== '') &&
    formData.fullName.trim().length >= 3 &&
    /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email) &&
    formData.password.length >= 8 &&
    agreedToTerms;

  return (
    <Box
      sx={{
        display: 'flex', flexDirection: 'column', alignItems: 'center',
        justifyContent: 'center', minHeight: '100vh', py: 4,
        backgroundColor: (theme) => theme.palette.mode === 'light' ? theme.palette.grey[100] : theme.palette.background.default,
      }}
    >
      <Paper
        elevation={3}
        sx={{
          padding: { xs: 3, sm: 4 }, display: 'flex', flexDirection: 'column',
          alignItems: 'center', maxWidth: '400px', width: '100%',
        }}
      >
        <Box
          component="img"
          src={mode === 'light' ? lightLogo : darkLogo}
          sx={{ height: 60, mb: 2 }}
          alt="My Smart Teach Logo"
        />
        <Typography component="h1" variant="h2" sx={{ mb: 3 }}>
          Create Account
        </Typography>

        {serverError && (
          <Alert severity="error" sx={{ width: '100%', mb: 2 }}>
            {serverError}
          </Alert>
        )}

        <Box component="form" onSubmit={handleSubmit} noValidate sx={{ width: '100%' }}>
          <Stack spacing={2}>
            <TextField
              required fullWidth id="fullName" label="Full Name" name="fullName"
              autoComplete="name" autoFocus value={formData.fullName} onChange={handleChange}
              disabled={isLoading} error={!!errors.fullName} helperText={errors.fullName}
            />
            <TextField
              required fullWidth id="email" label="Email Address" name="email"
              autoComplete="email" value={formData.email} onChange={handleChange}
              disabled={isLoading} error={!!errors.email} helperText={errors.email}
            />
            <TextField
              required fullWidth name="password" label="Password" type="password"
              id="password" autoComplete="new-password" value={formData.password} onChange={handleChange}
              disabled={isLoading} error={!!errors.password} 
              helperText={errors.password || "Must be at least 8 characters long."}
            />
            
            <FormControlLabel
              control={
                <Checkbox
                  checked={agreedToTerms}
                  onChange={(e) => setAgreedToTerms(e.target.checked)}
                  name="terms"
                  color="primary"
                  disabled={isLoading}
                />
              }
              label={
                <Typography variant="body2" color="text.secondary">
                  I agree to the{' '}
                  <Link href="https://www.mysmartteach.com/terms" target="_blank" rel="noopener noreferrer">
                    Terms of Service
                  </Link>{' '}
                  and{' '}
                  <Link href="https://www.mysmartteach.com/privacy" target="_blank" rel="noopener noreferrer">
                    Privacy Policy
                  </Link>.
                </Typography>
              }
            />

            <Button
              type="submit" fullWidth variant="contained"
              disabled={isLoading || !canSubmit}
              sx={{ mt: 1, mb: 2, py: 1.5 }}
            >
              {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Create Account'}
            </Button>
          </Stack>
        </Box>

        <Typography variant="body2" color="text.secondary" align="center" sx={{ mt: 3 }}>
          {"Already have an account? "}
          <Link component={RouterLink} to="/login" variant="body2">
            Sign In
          </Link>
        </Typography>
      </Paper>
    </Box>
  );
};

export default Register;

--- File: .\ata-frontend\src\pages\StudentProfile.jsx ---

import React, { useState, useEffect } from 'react';
import { useParams, Link as RouterLink } from 'react-router-dom';
import { Box, Typography, Paper, CircularProgress, Alert, Button, Chip, Card, CardContent, Breadcrumbs, Link, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, useTheme } from '@mui/material';
import { useAuth } from '../hooks/useAuth';
import studentService from '../services/studentService';
import reviewService from '../services/reviewService';

const StudentProfile = () => {
    const { student_id } = useParams();
    const { user } = useAuth();
    const theme = useTheme();
    const [studentData, setStudentData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const fetchStudentData = async () => {
            if (!student_id || !user) return;
            try {
                setLoading(true);
                const data = await studentService.getStudentTranscript(student_id);
                setStudentData(data);
                setError(null);
            } catch (err) {
                setError(err.response?.data?.detail || 'Failed to fetch student data.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };

        fetchStudentData();
    }, [student_id, user]);

    const handleDownloadReport = async (jobId) => {
        try {
            await reviewService.downloadReport(jobId, student_id);
        } catch (downloadError) {
            console.error('Failed to download report', downloadError);
        }
    };

    const renderMarkCell = (assessment) => {
        if (assessment.status === 'ABSENT') {
            return <Chip label="Absent" color="default" size="small" />;
        }
        if (assessment.status === 'PENDING_REVIEW') {
            return <Chip label="Pending" color="warning" size="small" />;
        }
        if (assessment.totalScore !== null && assessment.maxTotalScore) {
            const percentage = Math.round((assessment.totalScore / assessment.maxTotalScore) * 100);
            return `${assessment.totalScore} / ${assessment.maxTotalScore} (${percentage}%)`;
        }
        return 'N/A';
    };

    if (loading) {
        return <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}><CircularProgress /></Box>;
    }

    if (error) {
        return <Alert severity="error">{error}</Alert>;
    }

    if (!studentData) {
        return <Alert severity="info">No student data found.</Alert>;
    }

    return (
        <Box>
            <Breadcrumbs aria-label="breadcrumb" sx={{ mb: 2 }}>
                <Link component={RouterLink} underline="hover" color="inherit" to="/classes">
                    Classes
                </Link>
                <Typography color="text.primary">{studentData.name}</Typography>
            </Breadcrumbs>

            <Paper sx={{ p: 3, mb: 3 }}>
                <Typography variant="h4" gutterBottom>{studentData.name}</Typography>
                <Typography variant="body1" color="text.secondary" gutterBottom>
                    Student ID: {studentData.studentId}
                </Typography>
                <Typography variant="h5" color="primary" sx={{ mt: 2 }}>
                    Overall Average: {studentData.overallAveragePercent !== null
                        ? `${studentData.overallAveragePercent.toFixed(2)}%`
                        : 'N/A'}
                </Typography>
            </Paper>

            {studentData.classSummaries.length === 0 ? (
                <Alert severity="info">No classes or assessments found for this student.</Alert>
            ) : (
                studentData.classSummaries.map((classData) => (
                    <Card key={classData.classId} sx={{ mb: 3 }}>
                        <CardContent>
                            <Typography variant="h5" gutterBottom>
                                {classData.className}
                            </Typography>
                            <Typography variant="h6" color="secondary" sx={{ mb: 2 }}>
                                Class Average: {classData.averagePercent !== null
                                    ? `${classData.averagePercent.toFixed(2)}%`
                                    : 'N/A'}
                            </Typography>

                            {classData.assessments.length === 0 ? (
                                <Alert severity="info">No assessments for this class yet.</Alert>
                            ) : (
                                <TableContainer>
                                    <Table aria-label="assessments table">
                                        <TableHead sx={{ backgroundColor: theme.palette.grey[100] }}>
                                            <TableRow>
                                                <TableCell sx={{ fontWeight: 600 }}>Assessment</TableCell>
                                                <TableCell sx={{ fontWeight: 600 }}>Date</TableCell>
                                                <TableCell sx={{ fontWeight: 600 }}>Mark</TableCell>
                                                <TableCell sx={{ fontWeight: 600 }} align="right">Report</TableCell>
                                            </TableRow>
                                        </TableHead>
                                        <TableBody>
                                            {classData.assessments.map((assessment) => (
                                                <TableRow
                                                    key={assessment.jobId}
                                                    hover
                                                    sx={{ '&:last-child td, &:last-child th': { border: 0 } }}
                                                >
                                                    <TableCell component="th" scope="row">
                                                        <Typography variant="body1">{assessment.assessmentName}</Typography>
                                                    </TableCell>
                                                    <TableCell>
                                                        <Typography variant="body2" color="text.secondary">
                                                            {assessment.createdAt
                                                                ? new Date(assessment.createdAt).toLocaleDateString()
                                                                : 'N/A'}
                                                        </Typography>
                                                    </TableCell>
                                                    <TableCell>
                                                        <Typography variant="body1">
                                                            {renderMarkCell(assessment)}
                                                        </Typography>
                                                    </TableCell>
                                                    <TableCell align="right">
                                                        {assessment.jobId && assessment.status !== 'ABSENT' && assessment.status !== 'PENDING_REVIEW' && (
                                                            <Button
                                                                size="small"
                                                                variant="outlined"
                                                                onClick={() => handleDownloadReport(assessment.jobId)}
                                                            >
                                                                Download
                                                            </Button>
                                                        )}
                                                    </TableCell>
                                                </TableRow>
                                            ))}
                                        </TableBody>
                                    </Table>
                                </TableContainer>
                            )}
                        </CardContent>
                    </Card>
                ))
            )}
        </Box>
    );
};

export default StudentProfile;

--- File: .\ata-frontend\src\pages\assessments\AssessmentCard.jsx ---

// /src/components/assessments/AssessmentCard.jsx (Corrected and Hardened)

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box, Card, CardActionArea, Typography, Grid, Menu, MenuItem, IconButton, Tooltip, ListItemIcon
} from '@mui/material';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import FileCopyOutlined from '@mui/icons-material/FileCopyOutlined';

import StatusChip from './StatusChip';
import CompletedStats from './CompletedStats';

const AssessmentCard = ({ job }) => {
    const navigate = useNavigate();
    const [anchorEl, setAnchorEl] = useState(null);
    const isMenuOpen = Boolean(anchorEl);

    const isClickable = ['Pending Review', 'Completed'].includes(job.status);

    const handleCardClick = () => {
        // Always land on the Results page first, regardless of status.
        navigate(`/assessments/${job.id}/results`);
    };

    const handleMenuClick = (event) => {
        event.stopPropagation();
        setAnchorEl(event.currentTarget);
    };

    const handleMenuClose = () => {
        setAnchorEl(null);
    };

    const handleClone = () => {
        navigate(`/assessments/new?cloneFromJobId=${job.id}`);
        handleMenuClose();
    };
    
    // --- FIX: Create a formatted date string safely ---
    const formattedDate = job.createdAt ? new Date(job.createdAt).toLocaleDateString() : 'N/A';

    return (
        <Card>
            <CardActionArea onClick={handleCardClick} disabled={!isClickable} sx={{ p: 3 }}>
                <Grid container spacing={2} alignItems="center">
                    <Grid item xs={12} md={5}>
                        <Typography variant="h3" gutterBottom>{job.assessmentName}</Typography>
                        <Typography color="text.secondary">For: {job.className}</Typography>
                        <Typography variant="caption" color="text.secondary">
                            {/* --- FIX: Use the safe, formatted date --- */}
                            Created on: {formattedDate}
                        </Typography>
                    </Grid>
                    <Grid item xs={12} md={3}>
                        <StatusChip status={job.status} progress={job.progress} />
                    </Grid>
                    <Grid item xs={12} md={4} sx={{ display: 'flex', justifyContent: 'flex-end', alignItems: 'center' }}>
                        {job.status === 'Completed' ? (
                            <CompletedStats results={job.results} />
                        ) : (
                            <Box sx={{ flexGrow: 1 }} />
                        )}
                        {job.status === 'Completed' && (
                            <Box sx={{ ml: 2, alignSelf: 'flex-start' }}>
                                <Tooltip title="Assessment Options">
                                    <IconButton onClick={handleMenuClick} aria-label="assessment options">
                                        <MoreVertIcon />
                                    </IconButton>
                                </Tooltip>
                                <Menu anchorEl={anchorEl} open={isMenuOpen} onClose={handleMenuClose}>
                                    <MenuItem onClick={handleClone}>
                                        <ListItemIcon>
                                            <FileCopyOutlined fontSize="small" />
                                        </ListItemIcon>
                                        Clone Assessment
                                    </MenuItem>
                                </Menu>
                            </Box>
                        )}
                    </Grid>
                </Grid>
            </CardActionArea>
        </Card>
    );
};

export default AssessmentCard;

--- File: .\ata-frontend\src\pages\assessments\AssessmentResultsPage.jsx ---

import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { Container, Typography, Box, CircularProgress, Alert, Grid } from '@mui/material';
import reviewService from '../../services/reviewService';
import ResultsTable from '../../components/assessments/ResultsTable';
import StatusChip from '../../components/assessments/StatusChip';

const AssessmentResultsPage = () => {
  const { job_id } = useParams();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [results, setResults] = useState(null);

  useEffect(() => {
    if (!job_id) {
      setLoading(false);
      return;
    }
    const fetchResults = async () => {
      try {
        setLoading(true);
        const data = await reviewService.getResultsOverview(job_id);
        setResults(data);
      } catch (err) {
        setError(err.message || 'An error occurred while fetching results.');
      } finally {
        setLoading(false);
      }
    };
    fetchResults();
  }, [job_id]);

  if (loading) {
    return <Container sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Container>;
  }

  if (error) {
    return <Container sx={{ mt: 4 }}><Alert severity="error">{error}</Alert></Container>;
  }

  return (
    <Container maxWidth="lg" sx={{ mt: 4 }}>
      <Grid container justifyContent="space-between" alignItems="flex-start" spacing={2} sx={{ mb: 2 }}>
        <Grid item>
          <Typography variant="h4" gutterBottom>{results?.assessmentName || 'Assessment Results'}</Typography>
        </Grid>
        <Grid item>
          {results?.status && <StatusChip status={results.status} />}
        </Grid>
      </Grid>

      <Box mt={2}>
        <ResultsTable rows={results?.students ?? []} />
      </Box>
    </Container>
  );
};

export default AssessmentResultsPage;

--- File: .\ata-frontend\src\pages\assessments\AssessmentReviewPage.jsx ---

import React, { useState, useEffect } from 'react';
import { useParams, useNavigate, useSearchParams } from 'react-router-dom';
import {
  Container, Typography, Box, Paper, CircularProgress, Alert, TextField, Button,
  Divider, Grid
} from '@mui/material';
import { ArrowBack as ArrowBackIcon } from '@mui/icons-material';
import reviewService from '../../services/reviewService';
import { useSnackbar } from '../../hooks/useSnackbar';
import StatusChip from '../../components/assessments/StatusChip';

const AssessmentReviewPage = () => {
  const navigate = useNavigate();
  const { job_id, entity_id } = useParams();

  const { showSnackbar } = useSnackbar();

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [data, setData] = useState(null);

  useEffect(() => {
    if (!job_id || !entity_id) {
        setError("Job ID or Entity ID is missing from the URL.");
        setLoading(false);
        return;
    };

    const fetchReviewData = async () => {
      try {
        setLoading(true);
        const fetchedData = await reviewService.getStudentReview(job_id, entity_id);
        setData(fetchedData);
      } catch (err) {
        setError(err.message || 'An error occurred.');
      } finally {
        setLoading(false);
      }
    };
    fetchReviewData();
  }, [job_id, entity_id]);

  const handleLocalChange = (questionId, field, value) => {
    setData(prev => {
        if (!prev) return null;
        const updatedPerQuestion = prev.perQuestion.map(q =>
            q.questionId === questionId ? { ...q, [field]: value } : q
        );
        return { ...prev, perQuestion: updatedPerQuestion };
    });
  };

  const handleSaveQuestion = async (questionId) => {
    const questionToSave = data.perQuestion.find(q => q.questionId === questionId);
    if (!questionToSave) {
        showSnackbar('Error: Could not find the question to save.', 'error');
        return;
    }

    const payload = {
      grade: Number(questionToSave.grade ?? 0),
      feedback: questionToSave.feedback ?? '',
    };

    const maxScore = questionToSave.maxScore || 100;
    if (payload.grade < 0 || payload.grade > maxScore) {
        showSnackbar(`Grade must be between 0 and ${maxScore}.`, 'error');
        return;
    }

    try {
      // Use the entity_id from the URL for the API call.
      await reviewService.saveQuestion(job_id, entity_id, questionId, payload);
      showSnackbar('Changes saved successfully!', 'success');
      // Optimistically update the status of the question in the UI
      setData(prev => {
        if (!prev) return null;
        const updatedPerQuestion = prev.perQuestion.map(q =>
            q.questionId === questionId ? { ...q, status: 'TEACHER_GRADED' } : q
        );
        return { ...prev, perQuestion: updatedPerQuestion };
      });
    } catch (err) {
      showSnackbar(err.message || 'Failed to save changes.', 'error');
    }
  };

  const perQ = data?.perQuestion ?? [];

  // Separate pending and non-pending questions
  const pendingQuestions = perQ.filter(q => q.status === 'PENDING_REVIEW');
  const allQuestions = perQ;

  // Render a single question card
  const renderQuestionCard = (q, index) => (
    <Paper key={q.questionId} sx={{ p: 3, mb: 3 }}>
      <Grid container spacing={2}>
        <Grid item xs={12} sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Typography variant="h6">Question {index + 1}</Typography>
          <StatusChip status={q.status} />
        </Grid>
        <Grid item xs={12}>
          <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>{q.questionText}</Typography>
        </Grid>
        <Grid item xs={12}>
          <Typography variant="subtitle2" color="text.secondary">Student's Answer:</Typography>
          <Box sx={{ p: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1, minHeight: 80, whiteSpace: 'pre-wrap', bgcolor: '#f9f9f9' }}>
            <Typography variant="body2">{q.studentAnswer || "No answer extracted."}</Typography>
          </Box>
        </Grid>
        <Grid item xs={4}>
          <TextField
            fullWidth
            label={`Grade (out of ${q.maxScore})`}
            type="number"
            value={q.grade ?? ''}
            onChange={(e) => handleLocalChange(q.questionId, 'grade', e.target.value)}
            InputProps={{ inputProps: { min: 0, max: q.maxScore } }}
          />
        </Grid>
        <Grid item xs={8}>
          <TextField
            fullWidth
            label="Feedback"
            multiline
            rows={3}
            value={q.feedback ?? ''}
            onChange={(e) => handleLocalChange(q.questionId, 'feedback', e.target.value)}
          />
        </Grid>
        <Grid item xs={12} sx={{ display: 'flex', justifyContent: 'flex-end' }}>
          <Button variant="contained" onClick={() => handleSaveQuestion(q.questionId)}>
            Save Question
          </Button>
        </Grid>
      </Grid>
    </Paper>
  );

  if (loading) {
    return <Container sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Container>;
  }

  if (error) {
    return <Container sx={{ mt: 4 }}><Alert severity="error">{error}</Alert></Container>;
  }

  if (!data) {
    return <Container sx={{ mt: 4 }}><Typography>No review data found for this student.</Typography></Container>;
  }

  return (
    <Box sx={{ flexGrow: 1, mb: 8 }}>
      <Container maxWidth="md" sx={{ mt: 4 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <Button variant="outlined" startIcon={<ArrowBackIcon />} onClick={() => navigate(`/assessments/${job_id}/results`)}>
            Back to Results
          </Button>
        </Box>

        <Typography variant="h4">{data?.assessmentName}</Typography>
        <Typography variant="h6" color="text.secondary">Reviewing: {data?.studentName} ({data?.studentId})</Typography>
        <Divider sx={{ my: 2 }} />

        {/* Pending Questions Section */}
        {pendingQuestions.length > 0 && (
          <Box sx={{ mb: 4 }}>
            <Box
              sx={{
                mb: 3,
                p: 2,
                bgcolor: '#FFF4E5',
                borderLeft: '4px solid #FF9800',
                borderRadius: 1
              }}
            >
              <Typography variant="subtitle1" sx={{ fontWeight: 600, color: '#663C00', mb: 0.5 }}>
                Pending Review
              </Typography>
              <Typography variant="body2" sx={{ color: '#8D6708' }}>
                The following {pendingQuestions.length} {pendingQuestions.length === 1 ? 'question requires' : 'questions require'} your attention and grading.
              </Typography>
            </Box>
            {pendingQuestions.map((q, idx) => {
              // Find the original index for correct question numbering
              const originalIndex = perQ.findIndex(pq => pq.questionId === q.questionId);
              return renderQuestionCard(q, originalIndex);
            })}
          </Box>
        )}

        {/* All Questions Section */}
        <Box>
          <Box
            sx={{
              mb: 3,
              p: 2,
              bgcolor: '#E3F2FD',
              borderLeft: '4px solid #2196F3',
              borderRadius: 1
            }}
          >
            <Typography variant="subtitle1" sx={{ fontWeight: 600, color: '#0D47A1', mb: 0.5 }}>
              All Questions
            </Typography>
            <Typography variant="body2" sx={{ color: '#1565C0' }}>
              Complete overview of all {allQuestions.length} questions with their grades and feedback.
            </Typography>
          </Box>
          {allQuestions.map((q, idx) => renderQuestionCard(q, idx))}
        </Box>
      </Container>
    </Box>
  );
};

export default AssessmentReviewPage;

--- File: .\ata-frontend\src\pages\assessments\CompletedStats.jsx ---

import React from 'react';
import { Box, Stack, Typography } from '@mui/material';

const CompletedStats = ({ results }) => {
    if (!results) return null;

    return (
        <Stack direction="row" spacing={4} alignItems="center">
            <Box>
                <Typography variant="h3">{results.classAverage}%</Typography>
                <Typography variant="body2" color="text.secondary">Class Average</Typography>
            </Box>
            <Box>
                <Typography variant="h3">#{results.hardestQuestion || 'N/A'}</Typography>
                <Typography variant="body2" color="text.secondary">Hardest Question</Typography>
            </Box>
        </Stack>
    );
};

export default CompletedStats;

--- File: .\ata-frontend\src\pages\assessments\FinalResultsPage.jsx ---

// /src/pages/assessments/FinalResultsPage.jsx (FULL, MERGED VERSION)

import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react'; // Import useRef and useCallback
import { useParams, Link as RouterLink } from 'react-router-dom';
import { 
  Box, Typography, Button, CircularProgress, Alert, Grid, Card, 
  CardContent, CardHeader, Breadcrumbs, Link as MuiLink, Collapse, Stack // Import Collapse and Stack
} from '@mui/material';
import FileDownloadOutlined from '@mui/icons-material/FileDownloadOutlined';
import AssessmentOutlined from '@mui/icons-material/AssessmentOutlined'; // New Icon
import Close from '@mui/icons-material/Close'; // New Icon
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { toPng } from 'html-to-image'; // Import the new library

import assessmentService from '../../services/assessmentService';
import ResultsTable from '../../components/assessments/ResultsTable';
import { useSnackbar } from '../../hooks/useSnackbar';

const AISummaryCard = ({ summary }) => (
    // This component is unchanged and correct
    <Card sx={{mb: 4, backgroundColor: 'secondary.light'}}>
        <CardHeader title="AI-Powered Summary" />
        <CardContent>
            <Typography whiteSpace="pre-wrap">{summary}</Typography>
        </CardContent>
    </Card>
);

const FinalResultsPage = () => {
  const { job_id } = useParams();
  const { showSnackbar } = useSnackbar();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [resultsData, setResultsData] = useState(null);
  const [isDownloading, setIsDownloading] = useState(false);

  // --- [Part 1 - State & Refs] ---
  const [analyticsOpen, setAnalyticsOpen] = useState(false);
  const [isCapturing, setIsCapturing] = useState(false);
  const chartsContainerRef = useRef(null); // Create a ref to target the charts container DOM node
  // --- [END OF PART 1] ---

  useEffect(() => {
    // This data fetching logic is unchanged and correct
    assessmentService.getJobResults(job_id)
      .then(data => setResultsData(data))
      .catch(err => setError("Could not load results. The job may still be processing or an error occurred."))
      .finally(() => setIsLoading(false));
  }, [job_id]);

  const handleDownloadAll = async () => {
    setIsDownloading(true);
    try {
      await assessmentService.downloadAllReports(job_id);
    } catch (err) { 
      showSnackbar(err.message, 'error'); 
    } finally { 
      setIsDownloading(false); 
    }
  };

  // All useMemo hooks for data transformation are now filled in
  const tableData = useMemo(() => {
    if (!resultsData) return [];
    
    const findReportTokenForStudent = (studentId) => {
        const studentResult = resultsData.results[studentId];
        if (!studentResult) return null;
        const firstQuestionId = Object.keys(studentResult)[0];
        return studentResult[firstQuestionId]?.reportToken || null;
    };
      
    return resultsData.students.map(student => {
        const studentResults = resultsData.results[student.id] || {};
        const grades = Object.values(studentResults).map(q => q.grade).filter(g => g !== null);
        const finalGrade = grades.length > 0 ? grades.reduce((acc, g) => acc + g, 0) : 0;
        const isEdited = Object.values(studentResults).some(q => q.status === 'edited_by_teacher');
        
        return {
            studentId: student.id,
            studentName: student.name,
            finalGrade,
            status: isEdited ? 'Edited' : 'AI-Graded',
            reportToken: findReportTokenForStudent(student.id),
        };
    });
  }, [resultsData]);

  const gradeDistributionData = useMemo(() => {
    if (!tableData) return [];
    const distribution = { 'A (90+)': 0, 'B (80-89)': 0, 'C (70-79)': 0, 'D (60-69)': 0, 'F (<60)': 0 };
    tableData.forEach(s => {
        if (s.finalGrade >= 90) distribution['A (90+)']++;
        else if (s.finalGrade >= 80) distribution['B (80-89)']++;
        else if (s.finalGrade >= 70) distribution['C (70-79)']++;
        else if (s.finalGrade >= 60) distribution['D (60-69)']++;
        else distribution['F (<60)']++;
    });
    return Object.entries(distribution).map(([name, count]) => ({ name, count }));
  }, [tableData]);

  const questionPerformanceData = useMemo(() => {
    if (!resultsData || !resultsData.analytics) return [];
    return Object.entries(resultsData.analytics.performanceByQuestion).map(([qId, avg]) => ({
        name: `Question ${qId.replace('q','')}`,
        averageScore: avg,
    }));
  }, [resultsData]);


  // --- [Part 2 - New Handler Functions] ---
  const handleToggleAnalytics = () => {
    setAnalyticsOpen(prev => !prev);
  };

  const handleDownloadCharts = useCallback(async () => {
    if (!chartsContainerRef.current) {
      showSnackbar('Could not find charts to download.', 'error');
      return;
    }
    setIsCapturing(true);
    try {
      // Use the html-to-image library to convert the referenced DOM node to a PNG data URL
      const dataUrl = await toPng(chartsContainerRef.current, { quality: 0.95, backgroundColor: '#ffffff' });
      // Use a simple link-click trick to trigger the browser download
      const link = document.createElement('a');
      link.download = `Analytics_${resultsData?.assessmentName.replace(/ /g, '_') || job_id}.png`;
      link.href = dataUrl;
      link.click();
    } catch (err) {
      console.error('Chart capture failed:', err);
      showSnackbar('Failed to download charts as image.', 'error');
    } finally {
      setIsCapturing(false);
    }
  }, [resultsData, job_id, showSnackbar]);
  // --- [END OF PART 2] ---

  if (isLoading) {
    return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>;
  }
  if (error) {
    return <Alert severity="error">{error}</Alert>;
  }
  if (!resultsData) {
    return <Typography>No results data found for this job.</Typography>;
  }

  const { assessmentName, aiSummary } = resultsData;

  return (
    <Box>
      <Breadcrumbs sx={{ mb: 2 }}>
        <MuiLink component={RouterLink} underline="hover" color="inherit" to="/assessments">
          Assessments
        </MuiLink>
        <Typography color="text.primary">{assessmentName}</Typography>
      </Breadcrumbs>

      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
        <Typography variant="h2">{assessmentName} - Results</Typography>
        <Button 
          variant="contained" 
          startIcon={isDownloading ? <CircularProgress size={20} color="inherit" /> : <FileDownloadOutlined />} 
          onClick={handleDownloadAll} 
          disabled={isDownloading}
        >
          {isDownloading ? 'Preparing...' : 'Download All Reports'}
        </Button>
      </Box>

      {aiSummary && <AISummaryCard summary={aiSummary} />}

      {/* --- [Part 3 - New UI Controls & Collapsible Section] --- */}
      <Box sx={{ border: '1px solid', borderColor: 'divider', borderRadius: 2, p: 2, mb: 4 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Typography variant="h5">Analytics Dashboard</Typography>
          <Button
            variant="outlined"
            onClick={handleToggleAnalytics}
            startIcon={analyticsOpen ? <Close /> : <AssessmentOutlined />}
          >
            {analyticsOpen ? 'Hide Analytics' : 'Show Analytics'}
          </Button>
        </Box>
        
        <Collapse in={analyticsOpen}>
          <Box ref={chartsContainerRef} sx={{ pt: 3 }}>
            <Stack direction="row" spacing={2} sx={{ mb: 2, justifyContent: 'flex-end' }}>
                <Button 
                    onClick={handleDownloadCharts}
                    disabled={isCapturing}
                    startIcon={isCapturing ? <CircularProgress size={20} /> : <FileDownloadOutlined />}
                >
                    {isCapturing ? 'Capturing...' : 'Download Charts as PNG'}
                </Button>
            </Stack>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                  <Card>
                      <CardHeader title="Grade Distribution" />
                      <CardContent>
                          <ResponsiveContainer width="100%" height={300}>
                              <BarChart data={gradeDistributionData} margin={{ top: 5, right: 20, left: -10, bottom: 5 }}>
                                  <CartesianGrid strokeDasharray="3 3" />
                                  <XAxis dataKey="name" />
                                  <YAxis allowDecimals={false} label={{ value: 'Students', angle: -90, position: 'insideLeft' }} />
                                  <Tooltip />
                                  <Bar dataKey="count" name="Number of Students" fill="#8884d8" />
                              </BarChart>
                          </ResponsiveContainer>
                      </CardContent>
                  </Card>
              </Grid>
              <Grid item xs={12} md={6}>
                   <Card>
                      <CardHeader title="Performance by Question" />
                      <CardContent>
                          <ResponsiveContainer width="100%" height={300}>
                              {/* --- [THE FIX IS APPLIED HERE] --- */}
                              <BarChart data={questionPerformanceData} layout="vertical" margin={{ top: 5, right: 30, left: 5, bottom: 5 }}>
                                  <CartesianGrid strokeDasharray="3 3" />
                                  <XAxis type="number" domain={[0, 100]} />
                                  <YAxis type="category" dataKey="name" />
                                  <Tooltip formatter={(value) => `${value}%`} />
                                  <Bar dataKey="averageScore" name="Average Score" fill="#82ca9d" />
                              </BarChart>
                              {/* --- [END OF FIX] --- */}
                          </ResponsiveContainer>
                      </CardContent>
                  </Card>
              </Grid>
            </Grid>
          </Box>
        </Collapse>
      </Box>
      {/* --- [END OF PART 3] --- */}

      <ResultsTable 
        tableData={tableData} 
        onDownloadReport={(studentId) => assessmentService.downloadStudentReport(job_id, studentId)} 
      />
    </Box>
  );
};
export default FinalResultsPage;

--- File: .\ata-frontend\src\pages\assessments\NewAssessment.jsx ---

// /src/pages/assessments/NewAssessmentV2.jsx (FINAL, DUAL-UPLOAD VERSION)

import React, { useState, useReducer, useCallback, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Box, Stepper, Step, StepLabel, Button, Typography, Paper, Alert, CircularProgress, Grid } from '@mui/material';

// Import our full suite of components
import DocumentUploader from '../../components/assessments/uploader/DocumentUploader';
import StructureReviewer from '../../components/assessments/uploader/StructureReviewer';
import GradingModeSelector from '../../components/assessments/uploader/GradingModeSelector';
import ScoringConfigurator from '../../components/assessments/uploader/ScoringConfigurator';
import Step1Setup from '../../components/assessments/wizard/Step1Setup';
import Step3Upload from '../../components/assessments/wizard/Step3Upload';
import WizardStep from '../../components/assessments/WizardStep';

import assessmentService from '../../services/assessmentService';
import classService from '../../services/classService';
import { useSnackbar } from '../../hooks/useSnackbar';
import { wizardReducer, initialState } from './NewAssessment.state';

const steps = ['Setup', 'Define Assessment', 'Upload Answers', 'Submit'];

const stepDescriptions = [
  'Define the name of this assessment and select the class it belongs to.',
  'Upload the question paper and the answer key for the AI to analyze.',
  'Upload all student answer sheets for the AI to grade.',
  'Review your configuration and begin the grading process.'
];

const NewAssessment = () => {
  const navigate = useNavigate();
  const { showSnackbar } = useSnackbar();
  const [state, dispatch] = useReducer(wizardReducer, initialState);
  const [activeStep, setActiveStep] = useState(0);
  const [classes, setClasses] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  // Load class list on mount (unchanged)
  useEffect(() => {
    classService.getAllClasses()
      .then(setClasses)
      .catch(err => showSnackbar(err.message || 'Failed to load class list.', 'error'))
      .finally(() => setIsLoading(false));
  }, [showSnackbar]);

  // NEW Handler for structuring documents
  const handleStructure = useCallback(async () => {
    if (!state.questionFile || !state.answerKeyFile) {
      showSnackbar('Please upload both the Question Document and the Answer Key.', 'error');
      return;
    }
    dispatch({ type: 'START_PARSING' });
    try {
      const parsedConfig = await assessmentService.parseDocument(
        state.questionFile,
        state.answerKeyFile,
        state.classId,
        state.assessmentName,
        state.scoringMethod
      );
      dispatch({ type: 'PARSE_SUCCESS', payload: parsedConfig });
      showSnackbar('Document(s) analyzed successfully!', 'success');
    } catch (error) {
      dispatch({ type: 'PARSE_FAILURE', payload: error.message || 'Failed to parse document.' });
    }
  }, [state.questionFile, state.answerKeyFile, state.classId, state.assessmentName, showSnackbar]);

  // handleSubmit is now simpler, as the config is already in state (unchanged)
  const handleSubmit = async () => {
    dispatch({ type: 'START_SUBMITTING' });
    try {
      const formData = new FormData();
      formData.append('config', JSON.stringify(state.config));
      state.answerSheetFiles.forEach(file => formData.append('answer_sheets', file));

      await assessmentService.createAssessmentJob(formData);
      showSnackbar('Assessment job created! Grading has begun.', 'success');
      navigate('/assessments');
    } catch (error) {
      const errorMessage = error.message || 'An unexpected error occurred.';
      dispatch({ type: 'SUBMIT_FAILURE', payload: errorMessage });
      showSnackbar(errorMessage, 'error');
    }
  };

  const isStepValid = useCallback(() => {
    switch (activeStep) {
      case 0:
        return !!state.assessmentName.trim() && !!state.classId;
      case 1:
        return !!state.config && state.config.sections.every(s => s.questions.every(q => q.text.trim() && q.rubric.trim() && q.maxScore != null && q.maxScore >= 0));
      case 2:
        return state.answerSheetFiles.length > 0;
      case 3:
        return true;
      default:
        return true;
    }
  }, [activeStep, state]);

  const handleNext = () => {
    if (activeStep === steps.length - 1) {
      handleSubmit();
    } else {
      setActiveStep((prev) => prev + 1);
    }
  };

  const handleBack = () => {
    setActiveStep((prev) => prev - 1);
  };

  const getStepContent = (step) => {
    const isProcessing = state.status === 'parsing' || state.status === 'submitting';
    switch (step) {
      case 0:
        return <Step1Setup state={state} handleUpdateField={(field, value) => dispatch({ type: 'UPDATE_FIELD', payload: { field, value } })} classes={classes} disabled={isProcessing} />;
      case 1:
        return (
          <Box>
            <ScoringConfigurator
              scoringMethod={state.scoringMethod}
              dispatch={dispatch}
              disabled={isProcessing}
            />
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <DocumentUploader
                  title="Question Document"
                  onFileSelect={(file) => dispatch({ type: 'SET_QUESTION_FILE', payload: file })}
                  selectedFile={state.questionFile}
                  disabled={isProcessing}
                />
              </Grid>
              <Grid item xs={12} md={6}>
                <DocumentUploader
                  title="Answer Key"
                  onFileSelect={(file) => dispatch({ type: 'SET_ANSWER_KEY_FILE', payload: file })}
                  selectedFile={state.answerKeyFile}
                  disabled={isProcessing}
                />
              </Grid>
            </Grid>

            <Button variant="contained" onClick={handleStructure} disabled={!state.questionFile || !state.answerKeyFile || isProcessing} sx={{ mt: 2 }}>
              {isProcessing ? <CircularProgress size={24} /> : 'Analyze Document(s)'}
            </Button>

            {state.error && <Alert severity="error" sx={{ mt: 2 }}>{state.error}</Alert>}

            {state.config && (
              <Box mt={4}>
                <Typography variant="h6" gutterBottom>Review & Configure</Typography>
                <StructureReviewer config={state.config} dispatch={dispatch} disabled={isProcessing} />
                <GradingModeSelector config={state.config} dispatch={dispatch} disabled={isProcessing} />
              </Box>
            )}
          </Box>
        );
      case 2:
        return <Step3Upload state={state} dispatch={dispatch} disabled={isProcessing} />;
      case 3:
        // A simple review step for the end
        return <Typography>Review your settings and click 'Start Grading' to begin.</Typography>;
      default:
        return 'Unknown step';
    }
  };

  if (isLoading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>;

  return (
    <Paper sx={{ p: { xs: 2, md: 4 }, mx: 'auto', maxWidth: '900px' }}>
      <Typography variant="h2" sx={{ mb: 4 }}>New Assessment</Typography>
      {state.error && <Alert severity="error" sx={{ mb: 2 }}>{state.error}</Alert>}
      <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
        {steps.map((label) => <Step key={label}><StepLabel>{label}</StepLabel></Step>)}
      </Stepper>
      <WizardStep title={steps[activeStep]} description={stepDescriptions[activeStep]}>
        {getStepContent(activeStep)}
      </WizardStep>
      <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 4 }}>
        <Button disabled={activeStep === 0 || state.status === 'parsing' || state.status === 'submitting'} onClick={handleBack} sx={{ mr: 1 }}>Back</Button>
        <Button variant="contained" onClick={handleNext} disabled={!isStepValid() || state.status === 'parsing' || state.status === 'submitting'}>
          {activeStep === steps.length - 1 ? 'Start Grading' : 'Next'}
        </Button>
      </Box>
    </Paper>
  );
};

export default NewAssessment;

--- File: .\ata-frontend\src\pages\assessments\NewAssessment.state.js ---

// /src/pages/assessments/NewAssessmentV2.state.js

// This helper creates a blank V2 question object for the review UI.
export const initialQuestionV2 = () => ({
  id: `q_${Math.random().toString(36).substr(2, 9)}`,
  text: '',
  rubric: '',
  maxScore: 10,
  answer: '',
});

// This is the initial state for our new V2 wizard.
export const initialState = {
  assessmentName: '',
  classId: '',
  // --- [NEW STATE FIELDS] ---
  questionFile: null,
  answerKeyFile: null,
  scoringMethod: 'per_question', // 'per_question' or 'total_score'
  // --- [END NEW STATE FIELDS] ---
  config: null, // Will hold the AI-parsed V2 config object
  answerSheetFiles: [],
  status: 'setup', // 'setup', 'parsing', 'reviewing', 'submitting'
  error: null,
};

// This reducer function manages all state transitions for the V2 wizard.
export function wizardReducer(state, action) {
  switch (action.type) {
    // --- [NEW ACTIONS] ---
    case 'SET_QUESTION_FILE':
      return { ...state, questionFile: action.payload, config: null, error: null }; // Reset config on new file
    case 'SET_ANSWER_KEY_FILE':
      return { ...state, answerKeyFile: action.payload, config: null, error: null };
    // --- [END NEW ACTIONS] ---

    case 'UPDATE_FIELD':
      return { ...state, [action.payload.field]: action.payload.value };
    case 'START_PARSING':
      return { ...state, status: 'parsing', error: null, config: null };
    case 'PARSE_SUCCESS':
      // When parsing succeeds, we populate the config and move to the 'reviewing' state.
      return { ...state, status: 'reviewing', config: action.payload };
    case 'PARSE_FAILURE':
      return { ...state, status: 'setup', error: action.payload, questionFile: null, answerKeyFile: null };
    case 'START_SUBMITTING':
      return { ...state, status: 'submitting', error: null };
    case 'SUBMIT_FAILURE':
      return { ...state, status: 'reviewing', error: action.payload };
    
    // Actions for managing the student answer sheets
    case 'ADD_ANSWER_SHEETS':
      const newFiles = action.payload.filter(nf => !state.answerSheetFiles.some(ef => ef.name === nf.name && ef.size === nf.size));
      return { ...state, answerSheetFiles: [...state.answerSheetFiles, ...newFiles] };
    case 'REMOVE_ANSWER_SHEET':
      return { ...state, answerSheetFiles: state.answerSheetFiles.filter(f => f.name !== action.payload) };
    
    // --- New V2-specific actions for editing the config ---
    case 'UPDATE_CONFIG_FIELD': {
        const { field, value } = action.payload;
        if (!state.config) return state;
        return { ...state, config: { ...state.config, [field]: value } };
    }
    case 'UPDATE_SECTION_FIELD': {
      if (!state.config) return state;
      const { sectionId, field, value } = action.payload;
      const newSections = state.config.sections.map(s => s.id === sectionId ? { ...s, [field]: value } : s);
      return { ...state, config: { ...state.config, sections: newSections } };
    }
    case 'UPDATE_QUESTION_FIELD': {
      if (!state.config) return state;
      const { sectionId, questionId, field, value } = action.payload;
      const newSections = state.config.sections.map(s => {
        if (s.id !== sectionId) return s;
        const newQuestions = s.questions.map(q => q.id === questionId ? { ...q, [field]: value } : q);
        return { ...s, questions: newQuestions };
      });
      return { ...state, config: { ...state.config, sections: newSections } };
    }
    case 'ADD_QUESTION': {
        if (!state.config) return state;
        const { sectionId } = action.payload;
        const newSections = state.config.sections.map(s => {
            if (s.id !== sectionId) return s;
            return { ...s, questions: [...s.questions, initialQuestionV2()] };
        });
        return { ...state, config: { ...state.config, sections: newSections } };
    }
    case 'REMOVE_QUESTION': {
        if (!state.config) return state;
        const { sectionId, questionId } = action.payload;
        const newSections = state.config.sections.map(s => {
            if (s.id !== sectionId) return s;
            if (s.questions.length <= 1) return s; // Prevent removing the last question
            const newQuestions = s.questions.filter(q => q.id !== questionId);
            return { ...s, questions: newQuestions };
        });
        return { ...state, config: { ...state.config, sections: newSections } };
    }
    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }
}

--- File: .\ata-frontend\src\pages\assessments\NewAssessmentV2.jsx ---

// /src/pages/assessments/NewAssessmentV2.jsx (FINAL, DUAL-UPLOAD VERSION)

import React, { useState, useReducer, useCallback, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Box, Stepper, Step, StepLabel, Button, Typography, Paper, Alert, CircularProgress, Grid, FormControl, FormLabel, RadioGroup, FormControlLabel, Radio, TextField, Stack, useMediaQuery, useTheme } from '@mui/material';

// Import our full suite of components
import DocumentUploader from '../../components/assessments/uploader/DocumentUploader';
import StructureReviewer from '../../components/assessments/uploader/StructureReviewer';
import GradingModeSelector from '../../components/assessments/uploader/GradingModeSelector';
import Step1Setup from '../../components/assessments/wizard/Step1Setup';
import Step3Upload from '../../components/assessments/wizard/Step3Upload';
import ManualUploader from '../../components/assessments/uploader/ManualUploader';
import WizardStep from '../../components/assessments/WizardStep';

import assessmentService from '../../services/assessmentService';
import classService from '../../services/classService';
import { useSnackbar } from '../../hooks/useSnackbar';
import { wizardReducerV2, initialStateV2 } from './NewAssessmentV2.state';

const steps = ['Setup', 'Define Assessment', 'Upload Answers', 'Submit'];

const stepDescriptions = [
  'Define the name of this assessment and select the class it belongs to.',
  'Upload the question paper and an optional answer key for the AI to analyze.',
  'Upload all student answer sheets for the AI to grade.',
  'Review your configuration and begin the grading process.'
];

const NewAssessmentV2 = () => {
  const navigate = useNavigate();
  const { showSnackbar } = useSnackbar();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const [state, dispatch] = useReducer(wizardReducerV2, initialStateV2);
  const [activeStep, setActiveStep] = useState(0);
  const [classes, setClasses] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  // Load class list on mount (unchanged)
  useEffect(() => {
    classService.getAllClasses()
      .then(setClasses)
      .catch(err => showSnackbar(err.message || 'Failed to load class list.', 'error'))
      .finally(() => setIsLoading(false));
  }, [showSnackbar]);

  // Count pages when question and answer key files are selected
  useEffect(() => {
    const countPages = async () => {
      if (state.questionFile && state.answerKeyFile) {
        try {
          const files = [state.questionFile, state.answerKeyFile];
          const result = await assessmentService.countPages(files);
          dispatch({ type: 'SET_ESTIMATED_TIME', payload: result.estimated_seconds });
        } catch (error) {
          console.error('Failed to count pages:', error);
          // Set a default estimate if page counting fails
          dispatch({ type: 'SET_ESTIMATED_TIME', payload: 30 });
        }
      }
    };
    countPages();
  }, [state.questionFile, state.answerKeyFile]);

  // Countdown timer effect during parsing
  useEffect(() => {
    if (state.status === 'parsing' && state.countdownSeconds > 0) {
      const timer = setInterval(() => {
        dispatch({ type: 'UPDATE_COUNTDOWN', payload: state.countdownSeconds - 1 });
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [state.status, state.countdownSeconds]);

  // NEW Handler for structuring documents
  const handleStructure = useCallback(async () => {
    if (!state.questionFile || !state.answerKeyFile) {
      showSnackbar('Please upload both the question paper and the answer key.', 'error');
      return;
    }
    dispatch({ type: 'START_PARSING' });
    try {
      // Step 1: Always parse the documents first to get the structure.
      let parsedConfig = await assessmentService.parseDocument(
        state.questionFile,
        state.answerKeyFile,
        state.classId,
        state.assessmentName
      );

      // Step 2: If AI marking is selected, make a second call to distribute scores.
      if (state.markingStrategy === 'ai') {
        showSnackbar('Documents analyzed. Now, asking AI to assign marks...', 'info');
        parsedConfig = await assessmentService.distributeScoresWithAI(parsedConfig, state.totalMarks);
      }

      dispatch({ type: 'PARSE_SUCCESS', payload: parsedConfig });
      showSnackbar('Assessment structure is ready for review!', 'success');
    } catch (error) {
      dispatch({ type: 'PARSE_FAILURE', payload: error.message || 'Failed to process documents.' });
    }
  }, [state.questionFile, state.answerKeyFile, state.classId, state.assessmentName, state.markingStrategy, state.totalMarks, showSnackbar]);

  // handleSubmit is now simpler, as the config is already in state (unchanged)
  const handleSubmit = async () => {
    dispatch({ type: 'START_SUBMITTING' });

    try {
      // The service call is now chosen based on the upload mode.
      if (state.uploadMode === 'manual') {
        await assessmentService.createAssessmentJobWithManualUploads({
          config: state.config,
          manualStudentFiles: state.manualStudentFiles,
          outsiders: state.outsiders,
        });
      } else {
        const formData = new FormData();
        formData.append('config', JSON.stringify(state.config));
        state.answerSheetFiles.forEach(file => formData.append('answer_sheets', file));
        await assessmentService.createAssessmentJobV2(formData);
      }
      
      showSnackbar('Assessment job created! Grading has begun.', 'success');
      navigate('/assessments');

    } catch (error) {
      const errorMessage = error.message || 'An unexpected error occurred.';
      dispatch({ type: 'SUBMIT_FAILURE', payload: errorMessage });
      showSnackbar(errorMessage, 'error');
    }
  };

  const isStepValid = useCallback(() => {
    switch (activeStep) {
      case 0:
        return !!state.assessmentName.trim() && !!state.classId;
      case 1:
        return !!state.config && state.config.sections.every(s => s.questions.every(q => q.text.trim() && q.rubric.trim() && q.maxScore > 0));
      case 2:
        if (state.uploadMode === 'batch') {
          return state.answerSheetFiles.length > 0;
        }
        if (state.uploadMode === 'manual') {
          // Valid if at least one student/outsider has at least one file staged.
          return Object.values(state.manualStudentFiles).some(fileList => fileList.length > 0);
        }
        return false; // Should not happen
      case 3:
        return true;
      default:
        return true;
    }
  }, [activeStep, state]);

  const handleNext = () => {
    if (activeStep === steps.length - 1) {
      handleSubmit();
    } else {
      setActiveStep((prev) => prev + 1);
    }
  };

  const handleBack = () => {
    setActiveStep((prev) => prev - 1);
  };

  const getStepContent = (step) => {
    const isProcessing = state.status === 'parsing' || state.status === 'submitting';
    switch (step) {
      case 0:
        return <Step1Setup state={state} handleUpdateField={(field, value) => dispatch({ type: 'UPDATE_FIELD', payload: { field, value } })} classes={classes} disabled={isProcessing} />;
      case 1:
        return (
          <Box>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <DocumentUploader
                  title="Question Document"
                  onFileSelect={(file) => dispatch({ type: 'SET_QUESTION_FILE', payload: file })}
                  selectedFile={state.questionFile}
                  disabled={isProcessing}
                />
              </Grid>
              <Grid item xs={12} md={6}>
                <DocumentUploader
                  title="Answer Key"
                  onFileSelect={(file) => dispatch({ type: 'SET_ANSWER_KEY_FILE', payload: file })}
                  selectedFile={state.answerKeyFile}
                  disabled={isProcessing}
                />
              </Grid>
            </Grid>

            <FormControl component="fieldset" sx={{ mt: 3 }}>
              <FormLabel component="legend">Marking Strategy</FormLabel>
              <RadioGroup
                row
                aria-label="marking strategy"
                name="marking-strategy-group"
                value={state.markingStrategy}
                onChange={(e) => dispatch({ type: 'UPDATE_FIELD', payload: { field: 'markingStrategy', value: e.target.value } })}
              >
                <FormControlLabel value="document" control={<Radio />} label="Find marks in document" />
                <FormControlLabel value="ai" control={<Radio />} label="Use AI to assign marks" />
              </RadioGroup>
              {state.markingStrategy === 'ai' && (
                <TextField
                  fullWidth
                  type="number"
                  label="Maximum marks for this exam"
                  value={state.totalMarks}
                  onChange={(e) => dispatch({ type: 'UPDATE_FIELD', payload: { field: 'totalMarks', value: parseInt(e.target.value, 10) || 0 } })}
                  sx={{ mt: 1, ml: 1, maxWidth: '280px' }}
                  variant="outlined"
                  size="small"
                />
              )}
            </FormControl>
            
            <Button variant="contained" onClick={handleStructure} disabled={!state.questionFile || !state.answerKeyFile || isProcessing} sx={{ mt: 2, display: 'block' }}>
              {isProcessing ? (
                <Stack direction="row" spacing={2} alignItems="center">
                  <CircularProgress size={24} color="inherit" />
                  <Typography variant="body2">
                    Analyzing Document... {state.countdownSeconds > 0 ? `(~${Math.floor(state.countdownSeconds / 60)}:${String(state.countdownSeconds % 60).padStart(2, '0')})` : ''}
                  </Typography>
                </Stack>
              ) : (
                'Structure Assessment'
              )}
            </Button>

            {state.error && <Alert severity="error" sx={{ mt: 2 }}>{state.error}</Alert>}
            
            {state.config && (
              <Box mt={4}>
                <Typography variant="h6" gutterBottom>Review & Configure</Typography>
                <StructureReviewer config={state.config} dispatch={dispatch} disabled={isProcessing} />
                <GradingModeSelector config={state.config} dispatch={dispatch} disabled={isProcessing} />
              </Box>
            )}
          </Box>
        );
      case 2:
        return (
          <Box>
            <FormControl component="fieldset" sx={{ mb: 2 }}>
              <FormLabel component="legend">Upload Method</FormLabel>
              <RadioGroup
                row
                value={state.uploadMode}
                onChange={(e) => dispatch({ type: 'UPDATE_FIELD', payload: { field: 'uploadMode', value: e.target.value } })}
              >
                <FormControlLabel value="batch" control={<Radio />} label="Batch Upload" />
                <FormControlLabel value="manual" control={<Radio />} label="Manual Upload per Student" />
              </RadioGroup>
            </FormControl>

            {state.uploadMode === 'batch' && (
              <Step3Upload state={state} dispatch={dispatch} disabled={isProcessing} />
            )}
            {state.uploadMode === 'manual' && (
              <ManualUploader
                classId={state.classId}
                stagedFiles={state.manualStudentFiles}
                outsiders={state.outsiders}
                onFilesStaged={(payload) => dispatch({ type: 'STAGE_MANUAL_FILES', payload })}
                onAddOutsider={(name) => dispatch({ type: 'ADD_OUTSIDER', payload: name })}
                disabled={isProcessing}
              />
            )}
          </Box>
        );
      case 3:
        // A simple review step for the end
        return <Typography>Review your settings and click 'Start Grading' to begin.</Typography>;
      default:
        return 'Unknown step';
    }
  };

  if (isLoading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>;

  return (
    <Paper sx={{ p: { xs: 2, md: 4 }, mx: 'auto', maxWidth: '900px' }}>
      <Typography variant="h2" sx={{ mb: 4 }}>New Assessment</Typography>
      {state.error && <Alert severity="error" sx={{ mb: 2 }}>{state.error}</Alert>}
      <Stepper
        activeStep={activeStep}
        sx={{ mb: 4 }}
        orientation={isMobile ? 'vertical' : 'horizontal'}
      >
        {steps.map((label) => <Step key={label}><StepLabel>{label}</StepLabel></Step>)}
      </Stepper>
      <WizardStep title={steps[activeStep]} description={stepDescriptions[activeStep]}>
        {getStepContent(activeStep)}
      </WizardStep>
      <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 4 }}>
        <Button disabled={activeStep === 0 || state.status === 'parsing' || state.status === 'submitting'} onClick={handleBack} sx={{ mr: 1 }}>Back</Button>
        <Button variant="contained" onClick={handleNext} disabled={!isStepValid() || state.status === 'parsing' || state.status === 'submitting'}>
          {activeStep === steps.length - 1 ? 'Start Grading' : 'Next'}
        </Button>
      </Box>
    </Paper>
  );
};

export default NewAssessmentV2;

--- File: .\ata-frontend\src\pages\assessments\NewAssessmentV2.state.js ---

// /src/pages/assessments/NewAssessmentV2.state.js

// This helper creates a blank V2 question object for the review UI.
export const initialQuestionV2 = () => ({
  id: `q_${Math.random().toString(36).substr(2, 9)}`,
  text: '',
  rubric: '',
  maxScore: 10,
  answer: '',
});

// This is the initial state for our new V2 wizard.
export const initialStateV2 = {
  assessmentName: '',
  classId: '',
  questionFile: null,
  answerKeyFile: null,
  markingStrategy: 'document', // 'document' or 'ai'
  totalMarks: 100,
  uploadMode: 'batch', // 'batch' or 'manual'
  config: null, // Will hold the AI-parsed V2 config object
  answerSheetFiles: [],
  manualStudentFiles: {}, // New state: { [entityId]: File[] }
  outsiders: [], // New state: { id: string, name: string }[]
  status: 'setup', // 'setup', 'parsing', 'reviewing', 'submitting'
  error: null,
  estimatedSeconds: 0, // Estimated processing time
  countdownSeconds: 0, // Current countdown value
};

// This reducer function manages all state transitions for the V2 wizard.
export function wizardReducerV2(state, action) {
  switch (action.type) {
    // --- [NEW ACTIONS] ---
    case 'SET_QUESTION_FILE':
      return { ...state, questionFile: action.payload, config: null, error: null }; // Reset config on new file
    case 'SET_ANSWER_KEY_FILE':
      return { ...state, answerKeyFile: action.payload, config: null, error: null };
    // --- [END NEW ACTIONS] ---

    case 'UPDATE_FIELD':
      // When switching upload modes, reset all file states to prevent conflicts.
      if (action.payload.field === 'uploadMode' && action.payload.value !== state.uploadMode) {
        return {
          ...state,
          [action.payload.field]: action.payload.value,
          answerSheetFiles: [],
          manualStudentFiles: {},
          outsiders: [],
        };
      }
      return { ...state, [action.payload.field]: action.payload.value };
    case 'START_PARSING':
      return { ...state, status: 'parsing', error: null, config: null, countdownSeconds: state.estimatedSeconds };
    case 'PARSE_SUCCESS':
      // When parsing succeeds, we populate the config and move to the 'reviewing' state.
      return { ...state, status: 'reviewing', config: action.payload, countdownSeconds: 0 };
    case 'PARSE_FAILURE':
      return { ...state, status: 'setup', error: action.payload, questionFile: null, answerKeyFile: null, countdownSeconds: 0 };
    case 'SET_ESTIMATED_TIME':
      return { ...state, estimatedSeconds: action.payload };
    case 'UPDATE_COUNTDOWN':
      return { ...state, countdownSeconds: Math.max(0, action.payload) };
    case 'START_SUBMITTING':
      return { ...state, status: 'submitting', error: null };
    case 'SUBMIT_FAILURE':
      return { ...state, status: 'reviewing', error: action.payload };
    
    // Actions for managing the student answer sheets
    case 'ADD_ANSWER_SHEETS':
      const newFiles = action.payload.filter(nf => !state.answerSheetFiles.some(ef => ef.name === nf.name && ef.size === nf.size));
      return { ...state, answerSheetFiles: [...state.answerSheetFiles, ...newFiles] };
    case 'REMOVE_ANSWER_SHEET':
      return { ...state, answerSheetFiles: state.answerSheetFiles.filter(f => f.name !== action.payload) };
    
    // --- Actions for manual per-student uploads ---
    case 'ADD_OUTSIDER': {
      const newOutsider = {
        id: `outsider_${new Date().getTime()}`, // Temp ID for the UI
        name: action.payload,
      };
      return { ...state, outsiders: [...state.outsiders, newOutsider] };
    }
    case 'STAGE_MANUAL_FILES': {
      const { entityId, files } = action.payload;
      const existingFiles = state.manualStudentFiles[entityId] || [];
      const newFiles = files.filter(nf => !existingFiles.some(ef => ef.name === nf.name && ef.size === nf.size));
      return {
        ...state,
        manualStudentFiles: {
          ...state.manualStudentFiles,
          [entityId]: [...existingFiles, ...newFiles]
        }
      };
    }

    // --- New V2-specific actions for editing the config ---
    case 'UPDATE_CONFIG_FIELD': {
        const { field, value } = action.payload;
        if (!state.config) return state;
        return { ...state, config: { ...state.config, [field]: value } };
    }
    case 'UPDATE_SECTION_FIELD': {
      if (!state.config) return state;
      const { sectionId, field, value } = action.payload;
      const newSections = state.config.sections.map(s => s.id === sectionId ? { ...s, [field]: value } : s);
      return { ...state, config: { ...state.config, sections: newSections } };
    }
    case 'UPDATE_QUESTION_FIELD': {
      if (!state.config) return state;
      const { sectionId, questionId, field, value } = action.payload;
      const newSections = state.config.sections.map(s => {
        if (s.id !== sectionId) return s;
        const newQuestions = s.questions.map(q => q.id === questionId ? { ...q, [field]: value } : q);
        return { ...s, questions: newQuestions };
      });
      return { ...state, config: { ...state.config, sections: newSections } };
    }
    case 'ADD_QUESTION': {
        if (!state.config) return state;
        const { sectionId } = action.payload;
        const newSections = state.config.sections.map(s => {
            if (s.id !== sectionId) return s;
            return { ...s, questions: [...s.questions, initialQuestionV2()] };
        });
        return { ...state, config: { ...state.config, sections: newSections } };
    }
    case 'REMOVE_QUESTION': {
        if (!state.config) return state;
        const { sectionId, questionId } = action.payload;
        const newSections = state.config.sections.map(s => {
            if (s.id !== sectionId) return s;
            if (s.questions.length <= 1) return s; // Prevent removing the last question
            const newQuestions = s.questions.filter(q => q.id !== questionId);
            return { ...s, questions: newQuestions };
        });
        return { ...state, config: { ...state.config, sections: newSections } };
    }
    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }
}

--- File: .\ata-frontend\src\pages\assessments\RedirectReviewToFirstStudent.jsx ---

import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Container, CircularProgress, Alert } from '@mui/material';
import reviewService from '../../services/reviewService';

const RedirectReviewToFirstStudent = () => {
  const { job_id } = useParams();
  const navigate = useNavigate();
  const [error, setError] = useState(null);

  useEffect(() => {
    const getFirstStudent = async () => {
      try {
        const overview = await reviewService.getResultsOverview(job_id);
        const firstPending = overview.studentsPending?.[0]?.studentId;
        const firstGraded = overview.studentsAiGraded?.[0]?.studentId;
        const studentId = firstPending || firstGraded;

        if (studentId) {
          navigate(`/assessments/${job_id}/review/${studentId}`, { replace: true });
        } else {
          setError('No students found for this assessment.');
        }
      } catch (err) {
        setError(err.message || 'Could not load assessment overview.');
      }
    };

    if (job_id) {
      getFirstStudent();
    }
  }, [job_id, navigate]);

  if (error) {
    return <Container sx={{ mt: 4 }}><Alert severity="error">{error}</Alert></Container>;
  }

  return (
    <Container sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
      <CircularProgress />
    </Container>
  );
};

export default RedirectReviewToFirstStudent;

--- File: .\ata-frontend\src\pages\assessments\ReviewPage.jsx ---

// /src/pages/assessments/ReviewPage.jsx (FINAL, FLAWLESS IMPLEMENTATION)

// --- Core React & Router Imports ---
import React, { useEffect, useReducer, useMemo, useCallback } from 'react';
import { useParams, useNavigate, Link as RouterLink } from 'react-router-dom';

// --- MUI Component Imports ---
import {
  Box, Typography, Button, CircularProgress, Alert, AlertTitle,
  Breadcrumbs, Link as MuiLink, Stack, Paper
} from '@mui/material';
import SaveOutlined from '@mui/icons-material/SaveOutlined';
import FactCheckOutlined from '@mui/icons-material/FactCheckOutlined';

// --- Custom Component & Service Imports ---
import assessmentService from '../../services/assessmentService';
import { useSnackbar } from '../../hooks/useSnackbar';
import QuestionReviewCard from '../../components/assessments/QuestionReviewCard'; // NEW: Import child component
import ConfirmationModal from '../../components/common/ConfirmationModal';

// --- State Management (useReducer for Complex State) ---

const initialState = {
  isLoading: true,
  error: null,
  reviewData: null,       // Will hold the entire payload from the backend
  overrides: {},          // Tracks teacher edits: { resultId: { grade, feedback } }
  isSaving: false,
  isFinalizing: false,
};

function reviewReducer(state, action) {
  switch (action.type) {
    case 'FETCH_SUCCESS':
      return { ...state, isLoading: false, reviewData: action.payload, error: null };
    case 'FETCH_ERROR':
      return { ...state, isLoading: false, error: action.payload };
    case 'UPDATE_OVERRIDE': {
      const { resultId, field, value } = action.payload;
      return {
        ...state,
        overrides: {
          ...state.overrides,
          [resultId]: { ...state.overrides[resultId], [field]: value },
        },
      };
    }
    case 'SAVE_START':
      return { ...state, isSaving: true };
    case 'SAVE_SUCCESS':
      // After saving, optimistically update main data and clear the overrides
      return { ...state, isSaving: false, teacherOverrides: {}, reviewData: action.payload };
    case 'SAVE_FAILURE':
      return { ...state, isSaving: false };
    case 'FINALIZE_START':
      return { ...state, isFinalizing: true };
    case 'FINALIZE_FINISH':
      return { ...state, isFinalizing: false };
    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }
}

// --- The Main Page Component ---

const ReviewPage = () => {
  const { job_id, student_id } = useParams();
  const navigate = useNavigate();
  const { showSnackbar } = useSnackbar();
  const [state, dispatch] = useReducer(reviewReducer, initialState);
  const [isConfirmOpen, setConfirmOpen] = React.useState(false);

  // --- Data Fetching Effect ---
  const fetchDetails = useCallback(async () => {
    try {
      const data = await assessmentService.getStudentReviewDetails(job_id, student_id);
      dispatch({ type: 'FETCH_SUCCESS', payload: data });
    } catch (err) {
      dispatch({ type: 'FETCH_ERROR', payload: err.message || "Could not load review session." });
    }
  }, [job_id, student_id]);

  useEffect(() => {
    fetchDetails();
  }, [fetchDetails]);

  // --- Memoized Selectors for Derived State ---
  const studentData = useMemo(() => state.reviewData?.student, [state.reviewData]);
  const hasUnsavedChanges = useMemo(() => Object.keys(state.overrides).length > 0, [state.overrides]);

  const questionsWithOverrides = useMemo(() => {
    if (!studentData?.questions) return [];
    // This is the core logic for our optimistic UI. It merges the server data with
    // any local, unsaved changes from the teacher.
    return studentData.questions.map(q => {
      const overrideData = state.overrides[q.resultId];
      return overrideData ? { ...q, ...overrideData } : q;
    });
  }, [studentData, state.overrides]);
  
  const isFinalizable = useMemo(() => {
    // A job is finalizable only if EVERY question has a valid grade and is not pending.
    if (!questionsWithOverrides.length) return false;
    return questionsWithOverrides.every(q => 
        q.status !== 'pending_review' && 
        q.grade !== null && 
        q.grade !== ''
    );
  }, [questionsWithOverrides]);


  // --- Event Handlers ---

  // Lifts state from QuestionReviewCard up to our reducer
  const handleUpdateOverride = (resultId, field, value) => {
    dispatch({ type: 'UPDATE_OVERRIDE', payload: { resultId, field, value } });
  };

  // Handles saving all changed questions to the backend
  const handleSaveChanges = async () => {
    if (!hasUnsavedChanges) return;
    dispatch({ type: 'SAVE_START' });

    // Create an array of promises for each pending save operation.
    const savePromises = Object.entries(state.overrides).map(([resultId, data]) => {
      const grade = parseFloat(data.grade);
      // Construct a payload that matches the TeacherOverrideRequest Pydantic model
      const payload = { ...data, grade: isNaN(grade) ? null : grade };
      return assessmentService.saveTeacherOverride(resultId, payload);
    });

    try {
      await Promise.all(savePromises);
      // For the best user experience and data consistency, we re-fetch the
      // entire dataset from the server after a successful save.
      await fetchDetails();
      showSnackbar('Your changes have been saved!', 'success');
    } catch (err) {
      dispatch({ type: 'SAVE_FAILURE' });
      showSnackbar(err.message || 'An error occurred while saving.', 'error');
    }
  };

  // Handles the final submission of the reviewed job
  const handleFinalize = async () => {
    setConfirmOpen(false); // Close confirmation modal first.
    dispatch({ type: 'FINALIZE_START' });
    try {
      await assessmentService.finalizeJobReview(job_id);
      showSnackbar('Assessment finalized! Analytics are now updated.', 'success');
      navigate(`/assessments/${job_id}/results`);
    } catch (err) {
      showSnackbar(err.message || 'Failed to finalize assessment.', 'error');
      dispatch({ type: 'FINALIZE_FINISH' });
    }
  };

  // --- Render Logic ---

  if (state.isLoading) {
    return <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}><CircularProgress /></Box>;
  }
  if (state.error) {
    return <Alert severity="error" sx={{ m: 3 }}><AlertTitle>Error</AlertTitle>{state.error}</Alert>;
  }
  if (!state.reviewData || !studentData) {
    return <Alert severity="info" sx={{ m: 3 }}>No review data found.</Alert>;
  }

  return (
    <>
      <Breadcrumbs aria-label="breadcrumb" sx={{ mb: 2 }}>
        <MuiLink component={RouterLink} underline="hover" color="inherit" to="/assessments">Assessments</MuiLink>
        <MuiLink component={RouterLink} underline="hover" color="inherit" to={`/assessments/${job_id}/results`}>{state.reviewData.assessmentName}</MuiLink>
        <Typography color="text.primary">Review: {studentData.name}</Typography>
      </Breadcrumbs>
      
      {/* Top action bar */}
      <Paper elevation={3} sx={{ p: { xs: 2, md: 3 }, mb: 3, position: 'sticky', top: '72px', zIndex: 1100 }}>
        <Stack direction={{ xs: 'column', md: 'row' }} justifyContent="space-between" alignItems="center" spacing={2}>
          <Box>
            <Typography variant="h2">Reviewing: {studentData.name}</Typography>
            <Typography color="text.secondary">{state.reviewData.assessmentName} - {questionsWithOverrides.length} Questions</Typography>
          </Box>
          <Stack direction="row" spacing={1.5}>
            <Button
              variant="outlined"
              onClick={handleSaveChanges}
              disabled={!hasUnsavedChanges || state.isSaving || state.isFinalizing}
              startIcon={state.isSaving ? <CircularProgress size={20} /> : <SaveOutlined />}
            >
              {state.isSaving ? 'Saving...' : 'Save Changes'}
            </Button>
            <Button
              variant="contained"
              onClick={() => setConfirmOpen(true)}
              disabled={!isFinalizable || hasUnsavedChanges || state.isFinalizing || state.isSaving}
              startIcon={state.isFinalizing ? <CircularProgress size={20} /> : <FactCheckOutlined />}
            >
              {state.isFinalizing ? 'Finalizing...' : 'Finalize & View Results'}
            </Button>
          </Stack>
        </Stack>
        {/* Conditional alerts to guide the user */}
        {hasUnsavedChanges && (
          <Alert severity="info" sx={{ mt: 2 }}>
            You have unsaved changes. Click "Save Changes" to persist them.
          </Alert>
        )}
        {!isFinalizable && !hasUnsavedChanges && (
          <Alert severity="warning" sx={{ mt: 2 }}>
            This job cannot be finalized until all questions have been graded.
          </Alert>
        )}
      </Paper>
      
      {/* List of question review cards */}
      <Stack spacing={3}>
        {questionsWithOverrides.map((q, index) => (
          <QuestionReviewCard
            key={q.resultId || q.questionId}
            questionData={q}
            questionNumber={index + 1}
            onUpdate={handleUpdateOverride}
            disabled={state.isSaving || state.isFinalizing}
          />
        ))}
      </Stack>

      <ConfirmationModal
          open={isConfirmOpen}
          onClose={() => setConfirmOpen(false)}
          onConfirm={handleFinalize}
          title="Finalize Assessment Review?"
          description="This action will lock all grades for this job, recalculate analytics, and mark it as 'Completed'. You will no longer be able to make changes. Are you sure you wish to proceed?"
      />
    </>
  );
};

export default ReviewPage;

--- File: .\ata-frontend\src\pages\assessments\StatusChip.jsx ---

import React from 'react';
import { Box, Chip, LinearProgress, Typography } from '@mui/material';
import RotateRightOutlined from '@mui/icons-material/RotateRightOutlined';
import RateReviewOutlined from '@mui/icons-material/RateReviewOutlined';
import CheckCircleOutlineOutlined from '@mui/icons-material/CheckCircleOutlineOutlined';
import ErrorOutlineOutlined from '@mui/icons-material/ErrorOutlineOutlined';

const statusConfig = {
    Processing: { label: "Processing", color: "secondary", icon: <RotateRightOutlined /> },
    "Pending Review": { label: "Pending Review", color: "warning", icon: <RateReviewOutlined /> },
    Completed: { label: "Completed", color: "success", icon: <CheckCircleOutlineOutlined /> },
    Failed: { label: "Failed", color: "error", icon: <ErrorOutlineOutlined /> },
    Queued: { label: "Queued", color: "info", icon: <RotateRightOutlined /> },
};

const StatusChip = ({ status, progress }) => {
    const config = statusConfig[status] || { label: status, color: "default", icon: null };
    const progressPercent = progress ? (progress.total > 0 ? (progress.processed / progress.total) * 100 : 0) : 0;

    return (
        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start', minHeight: '32px', width: '100%' }}>
            <Chip label={config.label} color={config.color} icon={config.icon} />
            {status === 'Processing' && progress && (
                <Box sx={{ width: '100%', mt: 1 }}>
                    <LinearProgress variant="determinate" value={progressPercent} sx={{ mb: 0.5 }} />
                    <Typography variant="caption" color="text.secondary">
                        {progress.processed} / {progress.total} graded
                    </Typography>
                </Box>
            )}
        </Box>
    );
};

export default StatusChip;

--- File: .\ata-frontend\src\pages\grading\GradingWorkflow.jsx ---

// /src/pages/grading/GradingWorkflow.jsx

import React, { useEffect, useReducer, useMemo } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box, Grid, AppBar, Toolbar, Button, IconButton, Typography,
  CircularProgress, Alert, AlertTitle
} from '@mui/material';
import ChevronLeft from '@mui/icons-material/ChevronLeft';
import ChevronRight from '@mui/icons-material/ChevronRight';

import RubricPanel from '../../components/assessments/RubricPanel';
import AnswerSheetViewer from '../../components/assessments/AnswerSheetViewer';
import AIGradingPanel from '../../components/assessments/AIGradingPanel';
import assessmentService from '../../services/assessmentService';
import { useSnackbar } from '../../hooks/useSnackbar';

const initialState = {
  isLoading: true,
  error: null,
  jobData: null,
  currentStudentIndex: 0,
  currentQuestionIndex: 0,
  teacherOverrides: {}, // Shape: { studentId: { questionId: { grade, feedback } } }
  isSubmitting: false,
};

function gradingReducer(state, action) {
  switch (action.type) {
    case 'FETCH_SUCCESS':
      return { ...state, isLoading: false, jobData: action.payload };
    case 'FETCH_ERROR':
      return { ...state, isLoading: false, error: action.payload };
    case 'CHANGE_STUDENT': {
      const newIndex = state.currentStudentIndex + action.payload;
      if (newIndex >= 0 && newIndex < state.jobData.students.length) {
        return { ...state, currentStudentIndex: newIndex, currentQuestionIndex: 0 };
      }
      return state;
    }
    case 'UPDATE_OVERRIDE': {
      const { studentId, questionId, field, value } = action.payload;
      return {
        ...state,
        teacherOverrides: {
          ...state.teacherOverrides,
          [studentId]: {
            ...state.teacherOverrides[studentId],
            [questionId]: {
              ...state.teacherOverrides[studentId]?.[questionId],
              [field]: value,
            },
          },
        },
      };
    }
    case 'SUBMIT_START':
      return { ...state, isSubmitting: true };
    case 'SUBMIT_FINISH':
      return { ...state, isSubmitting: false };
    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }
}

const GradingWorkflow = () => {
  const { job_id } = useParams();
  const navigate = useNavigate();
  const { showSnackbar } = useSnackbar();
  const [state, dispatch] = useReducer(gradingReducer, initialState);

  useEffect(() => {
    assessmentService.getJobResults(job_id)
      .then(data => dispatch({ type: 'FETCH_SUCCESS', payload: data }))
      .catch(err => dispatch({ type: 'FETCH_ERROR', payload: "Could not load grading session." }));
  }, [job_id]);

  const currentStudent = useMemo(() => state.jobData?.students[state.currentStudentIndex], [state.jobData, state.currentStudentIndex]);
  const currentQuestion = useMemo(() => state.jobData?.questions[state.currentQuestionIndex], [state.jobData, state.currentQuestionIndex]);
  
  const aiResultForCurrent = useMemo(() => {
    if (!currentStudent || !currentQuestion) return null;
    return state.jobData.results[currentStudent.id]?.[currentQuestion.id] ?? { grade: '', feedback: 'AI could not grade this question.' };
  }, [state.jobData, currentStudent, currentQuestion]);

  const overrideForCurrent = useMemo(() => {
    if (!currentStudent || !currentQuestion) return {};
    return state.teacherOverrides[currentStudent.id]?.[currentQuestion.id] ?? {};
  }, [state.teacherOverrides, currentStudent, currentQuestion]);

  const handleUpdateOverride = (field, value) => {
    dispatch({ type: 'UPDATE_OVERRIDE', payload: { studentId: currentStudent.id, questionId: currentQuestion.id, field, value }});
  };

  const handleApproveAndNext = async () => {
    dispatch({ type: 'SUBMIT_START' });
    try {
      // For V1, we will patch on every "next" click. V2 might have a single "Save All" button.
      await assessmentService.saveOverrides(job_id, currentStudent.id, state.teacherOverrides[currentStudent.id] || {});
      showSnackbar(`Grades for ${currentStudent.name} approved!`, 'success');
      
      if (state.currentStudentIndex === state.jobData.students.length - 1) {
        showSnackbar('All students have been reviewed!', 'info');
        navigate(`/assessments/${job_id}/results`);
      } else {
        dispatch({ type: 'CHANGE_STUDENT', payload: 1 });
      }
    } catch (err) {
      showSnackbar(err.message, 'error');
    } finally {
      dispatch({ type: 'SUBMIT_FINISH' });
    }
  };

  if (state.isLoading) {
    return <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}><CircularProgress /></Box>;
  }
  if (state.error) {
    return <Box sx={{ p: 4 }}><Alert severity="error"><AlertTitle>Error</AlertTitle>{state.error}</Alert></Box>;
  }
  if (!state.jobData || !currentStudent || !currentQuestion) {
    return <Box sx={{ p: 4 }}><Alert severity="info">No data available for this grading session.</Alert></Box>;
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 64px)' }}>
      <AppBar position="sticky" color="default" sx={{ boxShadow: 'none', borderBottom: 1, borderColor: 'divider' }}>
        <Toolbar>
          <IconButton onClick={() => dispatch({ type: 'CHANGE_STUDENT', payload: -1 })} disabled={state.currentStudentIndex === 0 || state.isSubmitting}><ChevronLeft /></IconButton>
          <Typography sx={{ textAlign: 'center', minWidth: '250px' }}>
            Student {state.currentStudentIndex + 1} of {state.jobData.students.length}: <strong>{currentStudent.name}</strong>
          </Typography>
          <IconButton onClick={() => dispatch({ type: 'CHANGE_STUDENT', payload: 1 })} disabled={state.currentStudentIndex >= state.jobData.students.length - 1 || state.isSubmitting}><ChevronRight /></IconButton>
          <Box sx={{ flexGrow: 1 }} />
          <Button variant="contained" onClick={handleApproveAndNext} disabled={state.isSubmitting}>
            {state.isSubmitting ? <CircularProgress size={24} /> : 'Approve & Next'}
          </Button>
        </Toolbar>
      </AppBar>

      <Grid container spacing={2} sx={{ flexGrow: 1, p: 2, overflow: 'hidden' }}>
        <Grid item xs={12} md={3} sx={{ height: '100%' }}>
          <RubricPanel question={currentQuestion} rubric={state.jobData.rubric} />
        </Grid>
        <Grid item xs={12} md={5} sx={{ height: '100%' }}>
          <AnswerSheetViewer fileUrl={currentStudent.answerSheetUrl} studentName={currentStudent.name} />
        </Grid>
        <Grid item xs={12} md={4} sx={{ height: '100%' }}>
          <AIGradingPanel
            suggestedGrade={aiResultForCurrent.grade}
            suggestedFeedback={aiResultForCurrent.feedback}
            overrideGrade={overrideForCurrent.grade}
            overrideFeedback={overrideForCurrent.feedback}
            onGradeChange={(val) => handleUpdateOverride('grade', val)}
            onFeedbackChange={(val) => handleUpdateOverride('feedback', val)}
            maxScore={JSON.parse(state.jobData.config || '{}').maxScore}
            disabled={state.isSubmitting}
          />
        </Grid>
      </Grid>
    </Box>
  );
};

export default GradingWorkflow;

--- File: .\ata-frontend\src\pages\public\ReportView.jsx ---

import React from 'react';
import { Typography } from '@mui/material';
const PublicReportView = () => <Typography variant="h2">Public Report View (WIP)</Typography>;
export default PublicReportView;

--- File: .\ata-frontend\src\pages\tools\QuestionGenerator.jsx ---

import React, { useState, useEffect, useMemo } from 'react';

// MUI Component Imports
import {
  Card, CardContent, CardHeader, Divider, Box, Button, Stack, TextField,
  FormControl, InputLabel, Select, MenuItem, CircularProgress, CardActions,
  List, ListItem, ListItemText, Typography, Tabs, Tab, Autocomplete
} from '@mui/material';

// Custom Component Imports
import ToolPageLayout from '../../components/tools/ToolPageLayout';
import OutputPanel from '../../components/tools/OutputPanel';
import QuestionSettingsModal from '../../components/tools/QuestionSettingsModal';
import FileUploadZone from '../../components/tools/FileUploadZone';

// MUI Icon Imports
import QuestionAnswerOutlined from '@mui/icons-material/QuestionAnswerOutlined';
import TuneOutlined from '@mui/icons-material/TuneOutlined';

// Service Imports
import toolService from '../../services/toolService';
import libraryService from '../../services/libraryService';
import historyService from '../../services/historyService';

// Custom Hook Imports
import { useSnackbar } from '../../hooks/useSnackbar';

// --- Sub-Component: The final, 3-tab SettingsPanel (Refactored for snake_case) ---
const SettingsPanel = ({
    formState, setFormState, onSubmit, isLoading, onOpenModal, libraryTree, libraryLoading
}) => {
    // Local state for which of the three source material tabs is active
    const [activeTab, setActiveTab] = useState(0);

    // Generic handler for simple text/select inputs
    const handleInputChange = (event) => {
        const { name, value } = event.target;
        setFormState(prev => ({ ...prev, [name]: value }));
    };
    
    // --- START: CASCADING DROPDOWN LOGIC for the Library Tab ---
    const handleLibraryChange = (field, value) => {
        const newState = { ...formState, [field]: value };
        
        // When a parent dropdown changes, reset all child dropdowns to prevent invalid state
        if (field === 'selected_level') {
            newState.selected_year = null;
            newState.selected_subject = null;
            newState.selected_book = null;
            newState.selected_chapters = [];
            // Auto-update the main Grade Level dropdown to match the library selection for convenience
            if (value) {
                newState.grade_level = value.name;
            }
        }
        if (field === 'selected_year') {
            newState.selected_subject = null;
            newState.selected_book = null;
            newState.selected_chapters = [];
        }
        if (field === 'selected_subject') {
            newState.selected_book = null;
            newState.selected_chapters = [];
        }
        if (field === 'selected_book') {
            newState.selected_chapters = [];
        }
        setFormState(newState);
    };

    // useMemo optimizes performance by only recalculating lists when a parent selection changes
    const yearOptions = useMemo(() => formState.selected_level?.children || [], [formState.selected_level]);
    const subjectOptions = useMemo(() => formState.selected_year?.children || [], [formState.selected_year]);
    const bookOptions = useMemo(() => formState.selected_subject?.children || [], [formState.selected_subject]);
    const chapterOptions = useMemo(() => formState.selected_book?.children || [], [formState.selected_book]);
    // --- END: CASCADING DROPDOWN LOGIC ---

    // When switching tabs, clear the state of the other source types to ensure only one is sent
    const handleTabChange = (event, newValue) => {
        setActiveTab(newValue);
        // Clear state from other tabs to ensure only one source type is used
        setFormState(prev => ({
            ...prev,
            source_text: '',
            source_file: null,
            selected_level: null,
            selected_year: null,
            selected_subject: null,
            selected_book: null,
            selected_chapters: [],
        }));
    };
    
    const setFile = (file) => setFormState(prev => ({...prev, source_file: file}));

    // Form is valid if question configs exist AND one of the three source types has content.
    const isFormValid = (formState.source_text.trim().length > 10 || formState.source_file !== null || formState.selected_chapters.length > 0) && formState.question_configs.length > 0;

    return (
        <Card variant="outlined" sx={{ borderColor: 'divider' }}>
            <form onSubmit={onSubmit}>
                <CardHeader avatar={<TuneOutlined color="primary" />} title="Settings" titleTypographyProps={{ variant: 'h3' }} />
                <Divider />
                <CardContent>
                    <Stack spacing={3}>
                        <FormControl fullWidth disabled={isLoading || activeTab === 2}>
                            <InputLabel id="grade-level-label">Grade Level</InputLabel>
                            <Select name="grade_level" value={formState.grade_level} label="Grade Level" onChange={handleInputChange}>
                                <MenuItem value="Primary School">Primary School</MenuItem>
                                <MenuItem value="Secondary School">Secondary School</MenuItem>
                                <MenuItem value="Years 10 & 11 (GCSE)">Years 10 & 11 (GCSE)</MenuItem>
                                <MenuItem value="Sixth Form - College">Sixth Form - College</MenuItem>
                            </Select>
                        </FormControl>

                        <Box>
                            <Button variant="outlined" onClick={onOpenModal} fullWidth disabled={isLoading}>
                                Configure Question Settings ({formState.question_configs.length} selected)
                            </Button>
                            {formState.question_configs.length > 0 && (
                                <List dense sx={{bgcolor: 'background.paper', mt: 1, borderRadius: 1, border: '1px solid', borderColor: 'divider'}}>
                                    {formState.question_configs.map(config => (
                                        <ListItem key={config.type} disableGutters sx={{px: 2}}>
                                            <ListItemText 
                                                primary={config.label}
                                                secondary={`Count: ${config.count}, Difficulty: ${config.difficulty}`}
                                            />
                                        </ListItem>
                                    ))}
                                </List>
                            )}
                        </Box>

                        <Box>
                            <Typography variant="overline" color="text.secondary">Source Material</Typography>
                            <Tabs value={activeTab} onChange={handleTabChange} variant="fullWidth" sx={{ borderBottom: 1, borderColor: 'divider' }}>
                                <Tab label="Type Text" disabled={isLoading} />
                                <Tab label="Upload File" disabled={isLoading} />
                                <Tab label="From Library" disabled={isLoading || libraryLoading} />
                            </Tabs>
                            <Box sx={{ pt: 2, minHeight: 290 }}>
                                {activeTab === 0 && <TextField name="source_text" label="Topic or Source Text" multiline rows={10} fullWidth value={formState.source_text} onChange={handleInputChange} disabled={isLoading} />}
                                {activeTab === 1 && <FileUploadZone file={formState.source_file} setFile={setFile} isLoading={isLoading} />}
                                {activeTab === 2 && (
                                    libraryLoading ? <Box sx={{display: 'flex', justifyContent: 'center', pt: 4}}><CircularProgress /></Box> :
                                    <Stack spacing={2}>
                                        <Autocomplete options={libraryTree} getOptionLabel={(option) => option.name} value={formState.selected_level} onChange={(e, val) => handleLibraryChange('selected_level', val)} renderInput={(params) => <TextField {...params} label="Select Level" />} />
                                        <Autocomplete options={yearOptions} getOptionLabel={(option) => option.name} value={formState.selected_year} onChange={(e, val) => handleLibraryChange('selected_year', val)} disabled={!formState.selected_level} renderInput={(params) => <TextField {...params} label="Select Year" />} />
                                        <Autocomplete options={subjectOptions} getOptionLabel={(option) => option.name} value={formState.selected_subject} onChange={(e, val) => handleLibraryChange('selected_subject', val)} disabled={!formState.selected_year} renderInput={(params) => <TextField {...params} label="Select Subject" />} />
                                        <Autocomplete options={bookOptions} getOptionLabel={(option) => option.name} value={formState.selected_book} onChange={(e, val) => handleLibraryChange('selected_book', val)} disabled={!formState.selected_subject} renderInput={(params) => <TextField {...params} label="Select Book" />} />
                                        <Autocomplete multiple options={chapterOptions} getOptionLabel={(option) => option.name} value={formState.selected_chapters} onChange={(e, val) => handleLibraryChange('selected_chapters', val)} disabled={!formState.selected_book} renderInput={(params) => <TextField {...params} label="Select Chapters (up to 5)" />} limitTags={3} />
                                    </Stack>
                                )}
                            </Box>
                        </Box>
                    </Stack>
                </CardContent>
                <Divider />
                <CardActions sx={{ p: 2, justifyContent: 'flex-end' }}>
                    <Button type="submit" variant="contained" disabled={!isFormValid || isLoading} startIcon={isLoading ? <CircularProgress size={20} color="inherit" /> : null}>
                        {isLoading ? 'Generating...' : 'Generate Questions'}
                    </Button>
                </CardActions>
            </form>
        </Card>
    );
};

// --- Main Page Component ---
const QuestionGenerator = () => {
  const { showSnackbar } = useSnackbar();

  // State for the fetched library data
  const [libraryTree, setLibraryTree] = useState([]);
  const [libraryLoading, setLibraryLoading] = useState(true);
  
  // Effect to fetch the library tree data once on component mount
  useEffect(() => {
    libraryService.getTree()
      .then(data => setLibraryTree(data))
      .catch(err => {
        console.error("Failed to load library tree", err);
        showSnackbar("Could not load curriculum library.", "error");
      })
      .finally(() => setLibraryLoading(false));
  }, [showSnackbar]);

  // The complete form state, using snake_case for backend alignment
  const [formState, setFormState] = useState({
    grade_level: 'Years 10 & 11 (GCSE)',
    source_text: '',
    source_file: null,
    question_configs: [{ type: 'mcq', label: 'Multiple-choice questions', count: 5, difficulty: 'medium' }],
    selected_level: null,
    selected_year: null,
    selected_subject: null,
    selected_book: null,
    selected_chapters: [],
  });

  // State for the Question Settings modal
  const [isModalOpen, setIsModalOpen] = useState(false);
  
  // State for the API call and output
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [generatedContent, setGeneratedContent] = useState(null);
  
  // State for the save action
  const [isSaving, setIsSaving] = useState(false);
  const [lastUsedSettings, setLastUsedSettings] = useState(null);
  const [savedGenerationId, setSavedGenerationId] = useState(null);

  // Handler to receive the new question configurations from the modal
  const handleSaveSettings = (newConfigs) => {
    setFormState(prev => ({...prev, question_configs: newConfigs }));
    setIsModalOpen(false); // Close modal on save
  };

  // Handler for the main "Generate" button submission
  const handleSubmit = async (event) => {
    event.preventDefault();
    setIsLoading(true);
    setError(null);
    setGeneratedContent(null);
    setSavedGenerationId(null); // Reset the save status on new generation

    // Snapshot the settings that are being used for this specific generation
    const settingsForApi = {
      grade_level: formState.grade_level,
      source_text: formState.source_text,
      selected_chapter_paths: formState.selected_chapters.map(c => c.path),
      question_configs: formState.question_configs,
    };
    // Remember these settings so the "Save" button knows what to save
    setLastUsedSettings(settingsForApi);

    try {
      const requestPayload = {
        tool_id: 'question-generator',
        settings: settingsForApi,
      };
      
      const response = await toolService.generateContent(requestPayload, formState.source_file);
      setGeneratedContent(response.content);
    } catch (err) {
      console.error("Failed to generate questions:", err);
      const errorMessage = err.message || "An unexpected error occurred. Please try again.";
      setError(errorMessage);
      showSnackbar(errorMessage, "error");
    } finally {
      setIsLoading(false);
    }
  };
  
  // Handler for the "Save" button in the output panel
  const handleSave = async () => {
    // Guard against trying to save nothing
    if (!generatedContent || !lastUsedSettings) {
        showSnackbar("There is no content to save.", 'warning');
        return;
    }
    // Guard against saving the same content multiple times
    if (savedGenerationId) {
        showSnackbar("This generation has already been saved.", 'info');
        return;
    }

    setIsSaving(true);
    try {
        // The payload MUST EXACTLY match the Pydantic model on the backend.
        const payload = {
            tool_id: 'question-generator',
            settings: lastUsedSettings,
            generated_content: generatedContent,
        };
        const savedRecord = await historyService.saveGeneration(payload);
        setSavedGenerationId(savedRecord.id); // Store the ID of the saved record
        showSnackbar('Generation saved successfully!', 'success');
    } catch (err) {
        showSnackbar(err.message, 'error');
    } finally {
        setIsSaving(false);
    }
  };
  
  // Handler for the OutputPanel's "Clear" button
  const handleClear = () => {
    setGeneratedContent(null);
    setError(null);
    setLastUsedSettings(null);
    setSavedGenerationId(null); // Also reset the saved status
  };

  return (
    <>
      <ToolPageLayout
        title="Question Generator"
        icon={<QuestionAnswerOutlined />}
        settingsPanel={
          <SettingsPanel
            formState={formState}
            setFormState={setFormState}
            onSubmit={handleSubmit}
            isLoading={isLoading}
            onOpenModal={() => setIsModalOpen(true)}
            libraryTree={libraryTree}
            libraryLoading={libraryLoading}
          />
        }
        outputPanel={
          <OutputPanel
            isLoading={isLoading}
            error={error}
            generatedContent={generatedContent}
            onClear={handleClear}
            onSave={handleSave}
            isSaving={isSaving}
            isSaved={!!savedGenerationId} // Pass the derived saved status
          />
        }
      />
      <QuestionSettingsModal 
        open={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onSave={handleSaveSettings}
        initialConfigs={formState.question_configs}
      />
    </>
  );
};

export default QuestionGenerator;

--- File: .\ata-frontend\src\pages\tools\RubricGenerator.jsx ---

// /src/pages/tools/RubricGenerator.jsx

import React, { useState, useEffect, useMemo } from 'react';

// MUI Component Imports
import {
  Card, CardContent, CardHeader, Divider, Box, Button, Stack, TextField,
  FormControl, InputLabel, Select, MenuItem, CircularProgress, CardActions,
  Typography, Chip
} from '@mui/material';

// Custom Component Imports
import ToolPageLayout from '../../components/tools/ToolPageLayout';
import OutputPanel from '../../components/tools/OutputPanel';
import SourceInputBlock from '../../components/tools/SourceInputBlock'; // <<< Using our new reusable component

// MUI Icon Imports
import RuleOutlined from '@mui/icons-material/RuleOutlined';
import TuneOutlined from '@mui/icons-material/TuneOutlined';

// Service Imports
import toolService from '../../services/toolService';
import libraryService from '../../services/libraryService';
import historyService from '../../services/historyService';

// Custom Hook Imports
import { useSnackbar } from '../../hooks/useSnackbar';

// --- Sub-Component: A specialized input for managing a list of Chips ---
const ChipInput = ({ label, items, setItems, disabled }) => {
  const [inputValue, setInputValue] = useState('');

  const handleAdd = () => {
    if (inputValue && !items.includes(inputValue)) {
      setItems([...items, inputValue]);
      setInputValue('');
    }
  };

  const handleDelete = (itemToDelete) => {
    setItems(items.filter((item) => item !== itemToDelete));
  };

  const handleKeyPress = (event) => {
    if (event.key === 'Enter') {
      event.preventDefault(); // Prevent form submission
      handleAdd();
    }
  };

  return (
    <Box>
        <Typography variant="overline" color="text.secondary">{label}</Typography>
        <Stack direction="row" spacing={1}>
            <TextField
                fullWidth
                size="small"
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder={`Type and press Enter to add...`}
                disabled={disabled}
            />
            <Button variant="outlined" onClick={handleAdd} disabled={disabled}>Add</Button>
        </Stack>
        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1, minHeight: '40px' }}>
            {items.map((item) => (
                <Chip
                    key={item}
                    label={item}
                    onDelete={() => handleDelete(item)}
                    disabled={disabled}
                />
            ))}
        </Box>
    </Box>
  );
};


// --- Sub-Component: The specialized SettingsPanel for the Rubric Generator ---
const SettingsPanel = ({
    formState, setFormState, onSubmit, isLoading, libraryTree, libraryLoading
}) => {
    
    // --- Handlers for the Dual Source Input Blocks ---
    const handleAssignmentText = (value) => setFormState(prev => ({...prev, assignment_text: value}));
    const handleAssignmentFile = (file) => setFormState(prev => ({...prev, assignment_file: file}));
    const handleAssignmentLibrary = (field, value) => {
        const newState = { ...formState, assignment_library: {...formState.assignment_library, [field]: value }};
        // Reset child dropdowns on parent change
        if (field === 'selected_level') { newState.assignment_library.selected_year = null; /* etc. */ }
        setFormState(newState);
    };
    
    // For the second source block, we need separate handlers
    const handleGuidanceText = (value) => setFormState(prev => ({...prev, guidance_text: value}));
    // Note: In V1, we will not implement file/library for the guidance source to simplify the UI and backend logic.
    // This can be added later by creating guidance_file and guidance_library state.

    // --- Handlers for Chip Inputs ---
    const setCriteria = (newCriteria) => setFormState(prev => ({ ...prev, criteria: newCriteria }));
    const setLevels = (newLevels) => setFormState(prev => ({ ...prev, levels: newLevels }));

    // Form is valid if the primary source is provided and there are criteria/levels.
    const isFormValid = (formState.assignment_text.trim().length > 10 || formState.assignment_file !== null || formState.assignment_library.selected_chapters.length > 0) && formState.criteria.length > 1 && formState.levels.length > 1;

    return (
        <Card variant="outlined" sx={{ borderColor: 'divider' }}>
            <form onSubmit={onSubmit}>
                <CardHeader avatar={<TuneOutlined color="primary" />} title="Settings" titleTypographyProps={{ variant: 'h3' }} />
                <Divider />
                <CardContent>
                    <Stack spacing={4}>
                        <FormControl fullWidth disabled={isLoading}>
                            <InputLabel>Grade Level</InputLabel>
                            <Select name="grade_level" value={formState.grade_level} label="Grade Level" onChange={(e) => setFormState({...formState, grade_level: e.target.value})}>
                                <MenuItem value="Primary School">Primary School</MenuItem>
                                <MenuItem value="Secondary School">Secondary School</MenuItem>
                                <MenuItem value="Years 10 & 11 (GCSE)">Years 10 & 11 (GCSE)</MenuItem>
                                <MenuItem value="Sixth Form - College">Sixth Form - College</MenuItem>
                            </Select>
                        </FormControl>
                        
                        {/* --- Render the first SourceInputBlock for the Assignment Context --- */}
                        <SourceInputBlock
                            label="Assignment Context (The 'What' to Grade)"
                            textValue={formState.assignment_text}
                            fileValue={formState.assignment_file}
                            librarySelection={formState.assignment_library}
                            onTextChange={handleAssignmentText}
                            onFileChange={handleAssignmentFile}
                            onLibraryChange={handleAssignmentLibrary}
                            libraryTree={libraryTree}
                            libraryLoading={libraryLoading}
                            disabled={isLoading}
                        />

                        {/* --- Render a simplified input for the Rubric Guidance --- */}
                        <Box>
                            <Typography variant="overline" color="text.secondary">
                                Optional: Rubric Guidance (The 'How' to Grade)
                            </Typography>
                            <TextField
                                label="Paste a sample rubric or grading notes here"
                                multiline
                                rows={6}
                                fullWidth
                                value={formState.guidance_text}
                                onChange={(e) => handleGuidanceText(e.target.value)}
                                disabled={isLoading}
                            />
                        </Box>

                        {/* --- Render Chip Inputs for Criteria and Levels --- */}
                        <ChipInput label="Criteria (Rows)" items={formState.criteria} setItems={setCriteria} disabled={isLoading} />
                        <ChipInput label="Performance Levels (Columns)" items={formState.levels} setItems={setLevels} disabled={isLoading} />
                        
                    </Stack>
                </CardContent>
                <Divider />
                <CardActions sx={{ p: 2, justifyContent: 'flex-end' }}>
                    <Button type="submit" variant="contained" disabled={!isFormValid || isLoading} startIcon={isLoading ? <CircularProgress size={20} color="inherit" /> : null}>
                        {isLoading ? 'Generating...' : 'Generate Rubric'}
                    </Button>
                </CardActions>
            </form>
        </Card>
    );
};


// --- The Main Page Component ---
const RubricGenerator = () => {
  const { showSnackbar } = useSnackbar();

  // --- State for Library Data ---
  const [libraryTree, setLibraryTree] = useState([]);
  const [libraryLoading, setLibraryLoading] = useState(true);
  useEffect(() => {
    libraryService.getTree().then(data => setLibraryTree(data)).catch(err => {
        showSnackbar("Could not load curriculum library.", "error");
    }).finally(() => setLibraryLoading(false));
  }, [showSnackbar]);

  // --- The Comprehensive Form State for this Tool ---
  const [formState, setFormState] = useState({
    grade_level: 'Years 10 & 11 (GCSE)',
    // State for the primary (Assignment) source
    assignment_text: '',
    assignment_file: null,
    assignment_library: {
      selected_level: null, selected_year: null, selected_subject: null,
      selected_book: null, selected_chapters: [],
    },
    // State for the secondary (Guidance) source
    guidance_text: '',
    // State for rubric structure
    criteria: ['Thesis Statement', 'Evidence and Analysis', 'Organization'],
    levels: ['Exemplary', 'Proficient', 'Developing', 'Needs Improvement'],
  });

  // State for API calls and output
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [generatedContent, setGeneratedContent] = useState(null);
  
  // State for save/history logic
  const [isSaving, setIsSaving] = useState(false);
  const [lastUsedSettings, setLastUsedSettings] = useState(null);
  const [savedGenerationId, setSavedGenerationId] = useState(null);

  // --- Submit Handler ---
  const handleSubmit = async (event) => {
    event.preventDefault();
    setIsLoading(true);
    setError(null);
    setGeneratedContent(null);
    setSavedGenerationId(null);

    // Assemble the settings object that matches the Pydantic model
    const settingsForApi = {
      grade_level: formState.grade_level,
      assignment_text: formState.assignment_text,
      assignment_chapter_paths: formState.assignment_library.selected_chapters.map(c => c.path),
      guidance_text: formState.guidance_text,
      criteria: formState.criteria,
      levels: formState.levels,
    };
    setLastUsedSettings(settingsForApi);

    try {
      const requestPayload = {
        tool_id: 'rubric-generator', // <<< CRITICAL CHANGE
        settings: settingsForApi,
      };
      
      // The assignment_file is the primary file for this tool
      const response = await toolService.generateContent(requestPayload, formState.assignment_file);
      setGeneratedContent(response.content);
    } catch (err) {
      setError(err.message || "An unexpected error occurred.");
    } finally {
      setIsLoading(false);
    }
  };

  // --- Save Handler (identical pattern) ---
  const handleSave = async () => {
    if (!generatedContent || !lastUsedSettings) return;
    if (savedGenerationId) {
        showSnackbar("This generation has already been saved.", 'info');
        return;
    }
    setIsSaving(true);
    try {
        const payload = {
            tool_id: 'rubric-generator', // <<< CRITICAL CHANGE
            settings: lastUsedSettings,
            generated_content: generatedContent,
        };
        const savedRecord = await historyService.saveGeneration(payload);
        setSavedGenerationId(savedRecord.id);
        showSnackbar('Generation saved successfully!', 'success');
    } catch (err) {
        showSnackbar(err.message, 'error');
    } finally {
        setIsSaving(false);
    }
  };
  
  // --- Clear Handler (identical pattern) ---
  const handleClear = () => {
    setGeneratedContent(null);
    setError(null);
    setLastUsedSettings(null);
    setSavedGenerationId(null);
  };

  return (
    <ToolPageLayout
      title="Rubric Generator"
      icon={<RuleOutlined />}
      settingsPanel={
        <SettingsPanel
          formState={formState}
          setFormState={setFormState}
          onSubmit={handleSubmit}
          isLoading={isLoading}
          libraryTree={libraryTree}
          libraryLoading={libraryLoading}
        />
      }
      outputPanel={
        <OutputPanel
          isLoading={isLoading}
          error={error}
          generatedContent={generatedContent}
          onClear={handleClear}
          onSave={handleSave}
          isSaving={isSaving}
          isSaved={!!savedGenerationId}
        />
      }
    />
  );
};

export default RubricGenerator;

--- File: .\ata-frontend\src\pages\tools\SlideGenerator.jsx ---

// /src/pages/tools/SlideGenerator.jsx

import React, { useState, useEffect, useMemo } from 'react';

// MUI Component Imports
import {
  Card, CardContent, CardHeader, Divider, Box, Button, Stack, TextField,
  FormControl, InputLabel, Select, MenuItem, CircularProgress, CardActions,
  Typography, Tabs, Tab, Autocomplete, Switch, FormControlLabel
} from '@mui/material';

// Custom Component Imports
import ToolPageLayout from '../../components/tools/ToolPageLayout';
import OutputPanel from '../../components/tools/OutputPanel';
import FileUploadZone from '../../components/tools/FileUploadZone';

// MUI Icon Imports
import SlideshowOutlined from '@mui/icons-material/SlideshowOutlined';
import TuneOutlined from '@mui/icons-material/TuneOutlined';

// Service Imports
import toolService from '../../services/toolService';
import libraryService from '../../services/libraryService';
import historyService from '../../services/historyService';

// Custom Hook Imports
import { useSnackbar } from '../../hooks/useSnackbar';

// --- Sub-Component: The specialized SettingsPanel for the Slide Generator ---
const SettingsPanel = ({
    formState, setFormState, onSubmit, isLoading, libraryTree, libraryLoading
}) => {
    const [activeTab, setActiveTab] = useState(0);

    // Generic handler for form inputs, including text, select, and switches/checkboxes
    const handleInputChange = (event) => {
        const { name, value, checked, type } = event.target;
        setFormState(prev => ({ ...prev, [name]: type === 'checkbox' ? checked : value }));
    };
    
    // Handler for the cascading dropdowns in the Library tab
    const handleLibraryChange = (field, value) => {
        const newState = { ...formState, [field]: value };
        
        // When a parent dropdown changes, reset all children to prevent invalid state
        if (field === 'selected_level') {
            newState.selected_year = null;
            newState.selected_subject = null;
            newState.selected_book = null;
            newState.selected_chapters = [];
            // Auto-update the main Grade Level dropdown for convenience
            if (value) { newState.grade_level = value.name; }
        }
        if (field === 'selected_year') {
            newState.selected_subject = null;
            newState.selected_book = null;
            newState.selected_chapters = [];
        }
        if (field === 'selected_subject') {
            newState.selected_book = null;
            newState.selected_chapters = [];
        }
        if (field === 'selected_book') {
            newState.selected_chapters = [];
        }
        setFormState(newState);
    };

    // Memoized selectors to optimize performance of the cascading dropdowns
    const yearOptions = useMemo(() => formState.selected_level?.children || [], [formState.selected_level]);
    const subjectOptions = useMemo(() => formState.selected_year?.children || [], [formState.selected_year]);
    const bookOptions = useMemo(() => formState.selected_subject?.children || [], [formState.selected_subject]);
    const chapterOptions = useMemo(() => formState.selected_book?.children || [], [formState.selected_book]);

    // Handler for switching between source material tabs
    const handleTabChange = (event, newValue) => {
        setActiveTab(newValue);
        // Clear state from other tabs to ensure only one source type is used
        setFormState(prev => ({ 
            ...prev, 
            source_text: '', 
            source_file: null, 
            selected_level: null, 
            selected_year: null, 
            selected_subject: null, 
            selected_book: null, 
            selected_chapters: [], 
        }));
    };
    
    // Callback for the FileUploadZone component to update state
    const setFile = (file) => setFormState(prev => ({...prev, source_file: file}));

    // Form is valid if at least one source material has been provided
    const isFormValid = (formState.source_text.trim().length > 10 || formState.source_file !== null || formState.selected_chapters.length > 0);

    return (
        <Card variant="outlined" sx={{ borderColor: 'divider' }}>
            <form onSubmit={onSubmit}>
                <CardHeader avatar={<TuneOutlined color="primary" />} title="Settings" titleTypographyProps={{ variant: 'h3' }} />
                <Divider />
                <CardContent>
                    <Stack spacing={3}>
                        {/* --- SLIDE-SPECIFIC SETTINGS --- */}
                        <FormControl fullWidth disabled={isLoading || activeTab === 2}>
                            <InputLabel id="grade-level-label">Grade Level</InputLabel>
                            <Select name="grade_level" value={formState.grade_level} label="Grade Level" onChange={handleInputChange}>
                                <MenuItem value="Primary School">Primary School</MenuItem>
                                <MenuItem value="Secondary School">Secondary School</MenuItem>
                                <MenuItem value="Years 10 & 11 (GCSE)">Years 10 & 11 (GCSE)</MenuItem>
                                <MenuItem value="Sixth Form - College">Sixth Form - College</MenuItem>
                            </Select>
                        </FormControl>
                        
                        <TextField
                            name="num_slides"
                            type="number"
                            label="Number of Slides (3-20)"
                            value={formState.num_slides}
                            onChange={handleInputChange}
                            disabled={isLoading}
                            InputProps={{ inputProps: { min: 3, max: 20 } }}
                        />

                        <FormControl fullWidth disabled={isLoading}>
                            <InputLabel id="slide-style-label">Slide Style</InputLabel>
                            <Select name="slide_style" value={formState.slide_style} label="Slide Style" onChange={handleInputChange}>
                                <MenuItem value="informative">Informative</MenuItem>
                                <MenuItem value="engaging">Engaging</MenuItem>
                                <MenuItem value="professional">Professional</MenuItem>
                            </Select>
                        </FormControl>

                        <FormControlLabel
                            control={<Switch checked={formState.include_speaker_notes} onChange={handleInputChange} name="include_speaker_notes" />}
                            label="Include Speaker Notes"
                            disabled={isLoading}
                        />
                        {/* --- END SLIDE-SPECIFIC SETTINGS --- */}

                        <Box>
                            <Typography variant="overline" color="text.secondary">Source Material</Typography>
                            <Tabs value={activeTab} onChange={handleTabChange} variant="fullWidth" sx={{ borderBottom: 1, borderColor: 'divider' }}>
                                <Tab label="Type Text" disabled={isLoading} />
                                <Tab label="Upload File" disabled={isLoading} />
                                <Tab label="From Library" disabled={isLoading || libraryLoading} />
                            </Tabs>
                            {/* --- CORRECTED AND COMPLETED TAB CONTENT --- */}
                            <Box sx={{ pt: 2, minHeight: 290 }}>
                                {activeTab === 0 && <TextField name="source_text" label="Topic or Source Text" multiline rows={10} fullWidth value={formState.source_text} onChange={handleInputChange} disabled={isLoading} />}
                                {activeTab === 1 && <FileUploadZone file={formState.source_file} setFile={setFile} isLoading={isLoading} />}
                                {activeTab === 2 && (
                                    libraryLoading ? <Box sx={{display: 'flex', justifyContent: 'center', pt: 4}}><CircularProgress /></Box> :
                                    <Stack spacing={2}>
                                        <Autocomplete options={libraryTree} getOptionLabel={(option) => option.name} value={formState.selected_level} onChange={(e, val) => handleLibraryChange('selected_level', val)} renderInput={(params) => <TextField {...params} label="Select Level" />} />
                                        <Autocomplete options={yearOptions} getOptionLabel={(option) => option.name} value={formState.selected_year} onChange={(e, val) => handleLibraryChange('selected_year', val)} disabled={!formState.selected_level} renderInput={(params) => <TextField {...params} label="Select Year" />} />
                                        <Autocomplete options={subjectOptions} getOptionLabel={(option) => option.name} value={formState.selected_subject} onChange={(e, val) => handleLibraryChange('selected_subject', val)} disabled={!formState.selected_year} renderInput={(params) => <TextField {...params} label="Select Subject" />} />
                                        <Autocomplete options={bookOptions} getOptionLabel={(option) => option.name} value={formState.selected_book} onChange={(e, val) => handleLibraryChange('selected_book', val)} disabled={!formState.selected_subject} renderInput={(params) => <TextField {...params} label="Select Book" />} />
                                        <Autocomplete multiple options={chapterOptions} getOptionLabel={(option) => option.name} value={formState.selected_chapters} onChange={(e, val) => handleLibraryChange('selected_chapters', val)} disabled={!formState.selected_book} renderInput={(params) => <TextField {...params} label="Select Chapters (up to 5)" />} limitTags={3} />
                                    </Stack>
                                )}
                            </Box>
                        </Box>
                    </Stack>
                </CardContent>
                <Divider />
                <CardActions sx={{ p: 2, justifyContent: 'flex-end' }}>
                    <Button type="submit" variant="contained" disabled={!isFormValid || isLoading} startIcon={isLoading ? <CircularProgress size={20} color="inherit" /> : null}>
                        {isLoading ? 'Generating...' : 'Generate Slides'}
                    </Button>
                </CardActions>
            </form>
        </Card>
    );
};

// --- Main Page Component ---
const SlideGenerator = () => {
  const { showSnackbar } = useSnackbar();

  // State for the fetched library data
  const [libraryTree, setLibraryTree] = useState([]);
  const [libraryLoading, setLibraryLoading] = useState(true);
  
  // Effect to fetch the library tree data once on component mount
  useEffect(() => {
    libraryService.getTree()
      .then(data => setLibraryTree(data))
      .catch(err => {
        console.error("Failed to load library tree", err);
        showSnackbar("Could not load curriculum library.", "error");
      })
      .finally(() => setLibraryLoading(false));
  }, [showSnackbar]);

  // The complete form state, specific to the Slide Generator
  const [formState, setFormState] = useState({
    grade_level: 'Years 10 & 11 (GCSE)',
    source_text: '',
    source_file: null,
    num_slides: 7,
    slide_style: 'informative',
    include_speaker_notes: true,
    selected_level: null,
    selected_year: null,
    selected_subject: null,
    selected_book: null,
    selected_chapters: [],
  });

  // State for the API call and output
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [generatedContent, setGeneratedContent] = useState(null);

  // State for the save action
  const [isSaving, setIsSaving] = useState(false);
  const [lastUsedSettings, setLastUsedSettings] = useState(null);
  const [savedGenerationId, setSavedGenerationId] = useState(null);

  // Handler for the main "Generate" button submission
  const handleSubmit = async (event) => {
    event.preventDefault();
    setIsLoading(true);
    setError(null);
    setGeneratedContent(null);
    setSavedGenerationId(null); // Reset save status on new generation

    // Snapshot the settings being used for this specific generation
    const settingsForApi = {
      grade_level: formState.grade_level,
      source_text: formState.source_text,
      selected_chapter_paths: formState.selected_chapters.map(c => c.path),
      num_slides: Number(formState.num_slides),
      slide_style: formState.slide_style,
      include_speaker_notes: formState.include_speaker_notes,
    };
    // Remember these settings so the "Save" button knows what to save
    setLastUsedSettings(settingsForApi);

    try {
      const requestPayload = {
        tool_id: 'slide-generator', // CRITICAL: Identifies which tool backend to use
        settings: settingsForApi,
      };
      const response = await toolService.generateContent(requestPayload, formState.source_file);
      setGeneratedContent(response.content);
    } catch (err) {
      console.error("Failed to generate slides:", err);
      const errorMessage = err.message || "An unexpected error occurred. Please try again.";
      setError(errorMessage);
      showSnackbar(errorMessage, "error"); // Use snackbar for user feedback
    } finally {
      setIsLoading(false);
    }
  };
  
  // Handler for the "Save" button in the output panel
  const handleSave = async () => {
    // Guard against trying to save nothing or saving multiple times
    if (!generatedContent || !lastUsedSettings) {
        showSnackbar("There is no content to save.", 'warning');
        return;
    }
    if (savedGenerationId) {
        showSnackbar("This generation has already been saved.", 'info');
        return;
    }

    setIsSaving(true);
    try {
        const payload = {
            tool_id: 'slide-generator', // CRITICAL: Associates the save with the correct tool
            settings: lastUsedSettings,
            generated_content: generatedContent,
        };
        const savedRecord = await historyService.saveGeneration(payload);
        setSavedGenerationId(savedRecord.id); // Store ID to prevent re-saving
        showSnackbar('Generation saved successfully!', 'success');
    } catch (err) {
        showSnackbar(err.message, 'error');
    } finally {
        setIsSaving(false);
    }
  };

  // Handler for the OutputPanel's "Clear" button
  const handleClear = () => {
    setGeneratedContent(null);
    setError(null);
    setLastUsedSettings(null);
    setSavedGenerationId(null); // Also reset the saved status
  };

  return (
    <ToolPageLayout
      title="Slide Generator"
      icon={<SlideshowOutlined />}
      settingsPanel={
        <SettingsPanel
          formState={formState}
          setFormState={setFormState}
          onSubmit={handleSubmit}
          isLoading={isLoading}
          libraryTree={libraryTree}
          libraryLoading={libraryLoading}
        />
      }
      outputPanel={
        <OutputPanel
          isLoading={isLoading}
          error={error}
          generatedContent={generatedContent}
          onClear={handleClear}
          onSave={handleSave}
          isSaving={isSaving}
          isSaved={!!savedGenerationId} // Pass derived saved status
        />
      }
    />
  );
};

export default SlideGenerator;

--- File: .\ata-frontend\src\services\adminService.js ---

// /src/services/adminService.js

import apiClient from './api';

/**
 * Service for admin dashboard operations
 */
const adminService = {
  /**
   * Fetches comprehensive dashboard data
   * @returns {Promise<object>} Dashboard data with all database statistics
   */
  getDashboardData: async () => {
    try {
      const response = await apiClient.get('/api/admin/dashboard');
      return response.data;
    } catch (error) {
      console.error("Error fetching admin dashboard data:", error);
      throw new Error(error.response?.data?.detail || "Failed to fetch dashboard data");
    }
  },
};

export default adminService;


--- File: .\ata-frontend\src\services\api.js ---


// /src/services/api.js (FINAL, SUPERVISOR-APPROVED - FLAWLESS VERSION)

// --- Core Imports ---
import axios from 'axios';

// --- Configuration ---
// 1. Get the base URL for our backend API from the environment variables.
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;

// 2. A critical check to ensure the environment variable is set.
if (!API_BASE_URL) {
  throw new Error("VITE_API_BASE_URL is not set. Please check your .env.local file.");
}

// 3. Create the single, pre-configured axios instance (the "Singleton").
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 150000, // 150 seconds
});


// --- [CRITICAL MODIFICATION 1/2: REQUEST INTERCEPTOR] ---
// This interceptor runs BEFORE every single request is sent by axios.
apiClient.interceptors.request.use(
  (config) => {
    // This is the logic that will be executed for every API call.
    
    // 1. Retrieve the authentication token from localStorage.
    // localStorage is synchronous, so this is a fast operation.
    const token = localStorage.getItem('authToken');
    
    // 2. If a token exists, attach it to the Authorization header.
    // The backend's `get_current_user` dependency is specifically looking for
    // this "Bearer <token>" format.
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    // 3. Return the modified config object for axios to continue with the request.
    return config;
  },
  (error) => {
    // This part of the interceptor handles errors that occur during the
    // setup of a request. It's rare but good practice to include.
    return Promise.reject(error);
  }
);


// --- [CRITICAL MODIFICATION 2/2: RESPONSE INTERCEPTOR] ---
// This interceptor runs AFTER a response is received from the backend, but
// BEFORE it is passed to the `catch` block of the original API call.
apiClient.interceptors.response.use(
  // The first argument is a pass-through for successful responses (status 2xx).
  (response) => response,
  
  // The second argument is the crucial error handler.
  (error) => {
    // This is the logic that will be executed for every FAILED API call.

    // 1. Check if the error is due to an authentication failure (401 Unauthorized).
    // The optional chaining `?.` prevents errors if the `response` object doesn't exist.
    if (error.response?.status === 401) {
      
      // 2. An authentication error means our stored token is invalid or expired.
      // We must perform a "hard logout" to clean up the invalid session.
      console.warn("Received 401 Unauthorized. Token is invalid or expired. Logging out.");
      
      // Remove the bad token from storage.
      localStorage.removeItem('authToken');
      
      // 3. Force a redirect to the login page.
      // We use `window.location.href` instead of React Router's `navigate` because
      // this is a low-level service file outside of the React component tree.
      // This is one of the few appropriate places to use a hard redirect.
      // It also has the benefit of clearing all application state.
      if (window.location.pathname !== '/login') {
        window.location.href = '/login';
      }
    }
    
    // 4. Regardless of the error type, we must re-throw it so that the original
    // calling function (e.g., in `classService.js`) can still catch it and
    // handle it as needed (e.g., to show a specific error message in the UI).
    return Promise.reject(error);
  }
);


// 4. Export the now-intelligent, configured instance as the default export.
export default apiClient;

--- File: .\ata-frontend\src\services\assessmentService.js ---

// /src/services/assessmentService.js (FINAL, WITH CORRECTED V2 API PATH)

import apiClient from './api';

// This helper function is correct and remains unchanged.
function triggerBrowserDownload(blob, defaultFilename, headers) {
  const url = window.URL.createObjectURL(blob);
  const link = document.createElement('a');
  const contentDisposition = headers['content-disposition'];
  let filename = defaultFilename;
  if (contentDisposition) {
    const filenameMatch = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
    if (filenameMatch && filenameMatch[1]) {
      filename = filenameMatch[1].replace(/['"]/g, '').trim();
    }
  }
  link.href = url;
  link.setAttribute('download', filename);
  document.body.appendChild(link);
  link.click();
  link.parentNode.removeChild(link);
  window.URL.revokeObjectURL(url);
}

const assessmentService = {
  // --- [V2 WORKFLOW METHODS] ---

  parseDocument: async (questionFile, answerKeyFile, classId, assessmentName) => {
    const formData = new FormData();
    formData.append('question_file', questionFile);
    if (answerKeyFile) {
      formData.append('answer_key_file', answerKeyFile);
    }
    formData.append('class_id', classId);
    formData.append('assessment_name', assessmentName);
    
    try {
      const response = await apiClient.post('/api/assessments/parse-document', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      return response.data;
    } catch (error) {
      console.error("Error parsing assessment document(s):", error);
      throw new Error(error.response?.data?.detail || "Failed to analyze document(s).");
    }
  },

  createAssessmentJobV2: async (formData) => {
    try {
      // --- [THE FIX IS HERE] ---
      // The URL path has been corrected to match the backend's registered route.
      // Incorrect: '/api/v2/assessments'
      // Correct:   '/api/assessments/v2'
      const response = await apiClient.post('/api/assessments/v2', formData, {
      // --- [END OF FIX] ---
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      return response.data;
    } catch (error) {
      console.error("Error creating V2 assessment job:", error);
      throw new Error(error.response?.data?.detail || "Failed to create V2 assessment job.");
    }
  },

  distributeScoresWithAI: async (config, totalMarks) => {
    try {
      const payload = { config, totalMarks };
      const response = await apiClient.post('/api/assessments/distribute-scores', payload);
      return response.data;
    } catch (error) {
      console.error("Error distributing scores with AI:", error);
      throw new Error(error.response?.data?.detail || "Failed to distribute scores.");
    }
  },

  createAssessmentJobWithManualUploads: async ({ config, manualStudentFiles, outsiders }) => {
    const formData = new FormData();

    // Append the main configuration and the list of any new outsider students.
    formData.append('config', JSON.stringify(config));
    formData.append('outsider_names', JSON.stringify(outsiders));

    // Create a Set of outsider IDs for quick lookup.
    const outsiderIds = new Set(outsiders.map(o => o.id));

    // Iterate over the staged files and append them to FormData with dynamic keys.
    // The key format 'student_<id>_files' or 'outsider_<id>_files' matches the backend expectation.
    for (const entityId in manualStudentFiles) {
      const fileList = manualStudentFiles[entityId];
      if (fileList && fileList.length > 0) {
        const entityType = outsiderIds.has(entityId) ? 'outsider' : 'student';
        const formKey = `${entityType}_${entityId}_files`;

        fileList.forEach(file => {
          formData.append(formKey, file, file.name);
        });
      }
    }

    try {
      const response = await apiClient.post('/api/assessments/v2/manual', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      return response.data;
    } catch (error) {
      console.error("Error creating job with manual uploads:", error);
      throw new Error(error.response?.data?.detail || "Failed to create job with manual uploads.");
    }
  },

  uploadManualSubmission: async (jobId, { studentId, outsiderName, images }) => {
    const formData = new FormData();
    formData.append('job_id', jobId);
    images.forEach(image => {
      formData.append('images', image, image.name);
    });

    if (studentId) {
      formData.append('student_id', studentId);
    } else if (outsiderName) {
      formData.append('outsider_name', outsiderName);
    }

    try {
      const response = await apiClient.post('/api/assessments/manual-submission', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      return response.data;
    } catch (error) {
      console.error("Error in manual submission:", error);
      throw new Error(error.response?.data?.detail || "Failed to upload manual submission.");
    }
  },

  manualMatchSubmissions: async (jobId, matches) => {
    try {
      const response = await apiClient.post(`/api/assessments/${jobId}/manual-match`, matches);
      return response.data;
    } catch (error) {
      console.error("Error submitting manual matches:", error);
      throw new Error(error.response?.data?.detail || "Failed to save manual matches.");
    }
  },

  // --- [EXISTING V1 & DATA FETCHING METHODS - UNCHANGED AND STABLE] ---

  getAssessments: async () => {
    try {
      const response = await apiClient.get('/api/assessments');
      return response.data.assessments || [];
    } catch (error) {
      console.error("Error fetching assessments:", error);
      throw new Error(error.response?.data?.detail || "Failed to load assessments.");
    }
  },

  createAssessmentJob: async (formData) => {
    try {
      const response = await apiClient.post('/api/assessments', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      return response.data;
    } catch (error) {
      console.error("Error creating assessment job:", error);
      throw new Error(error.response?.data?.detail || "Failed to create assessment job.");
    }
  },

  deleteAssessment: async (jobId) => {
    try {
      // A DELETE request typically doesn't have a response body on success.
      await apiClient.delete(`/api/assessments/${jobId}`);
    } catch (error) {
      console.error(`Error deleting assessment job ${jobId}:`, error);
      throw new Error(error.response?.data?.detail || "Failed to delete assessment.");
    }
  },

  getJobResults: async (jobId) => {
    try {
      const response = await apiClient.get(`/api/assessments/${jobId}/results`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching results for job ${jobId}:`, error);
      throw new Error(error.response?.data?.detail || "Failed to load job results.");
    }
  },
  
  getAssessmentConfig: async (jobId) => {
    try {
      const response = await apiClient.get(`/api/assessments/${jobId}/config`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching config for job ${jobId}:`, error);
      throw new Error(error.response?.data?.detail || "Failed to load assessment configuration.");
    }
  },

  saveOverrides: async (jobId, studentId, questionId, overrides) => {
    try {
      const response = await apiClient.patch(`/api/assessments/${jobId}/results/${studentId}/${questionId}`, overrides);
      return response.data;
    } catch (error) {
      console.error(`Error saving overrides for student ${studentId}, question ${questionId}:`, error);
      throw new Error(error.response?.data?.detail || "Could not save changes.");
    }
  },

  downloadStudentReport: async (jobId, studentId) => {
    try {
      const response = await apiClient.get(`/api/assessments/${jobId}/report/${studentId}`, { responseType: 'blob' });
      triggerBrowserDownload(response.data, `Report_${studentId}.docx`, response.headers);
    } catch (error) {
      console.error("Error downloading student report:", error);
      throw new Error(error.response?.data?.detail || "Failed to download report.");
    }
  },

  downloadAllReports: async (jobId) => {
    try {
      const response = await apiClient.get(`/api/assessments/${jobId}/reports/all`, { responseType: 'blob' });
      triggerBrowserDownload(response.data, `All_Reports_${jobId}.zip`, response.headers);
    } catch (error) {
      console.error("Error downloading all reports:", error);
      throw new Error(error.response?.data?.detail || "Failed to download all reports.");
    }
  },

  // --- [PAGE COUNTING FUNCTIONALITY] ---

  countPages: async (files) => {
    const formData = new FormData();
    files.forEach(file => {
      formData.append('files', file);
    });

    try {
      const response = await apiClient.post('/api/page-count/count-pages', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      return response.data;
    } catch (error) {
      console.error("Error counting pages:", error);
      throw new Error(error.response?.data?.detail || "Failed to count pages.");
    }
  },
};

export default assessmentService;

--- File: .\ata-frontend\src\services\authService.js ---


// /src/services/authService.js

// Import the single, pre-configured axios instance.
// All requests made through this client will automatically have the correct base URL
// and will eventually have interceptors for attaching the auth token.
import apiClient from './api';

/**
 * A dedicated service object that encapsulates all API calls related to user
 * authentication (registration, login, and session validation). This provides
 * a clean separation of concerns, keeping raw API call logic out of our React
 * hooks and components.
 */
const authService = {
  /**
   * Sends a registration request to the backend.
   *
   * @param {string} fullName - The user's full name.
   * @param {string} email - The user's email address.
   * @param {string} password - The user's plain-text password.
   * @returns {Promise<object>} A promise that resolves to the new user's public
   *                            data (id, email, fullName) on success.
   * @throws {Error} Throws an error with a user-friendly message on failure.
   */
  register: async (fullName, email, password) => {
    try {
      // The payload object uses standard JavaScript camelCase.
      // A future interceptor in `apiClient` can handle conversion to snake_case if needed.
      const payload = {
        fullName: fullName,
        email: email,
        password: password,
      };
      // Make a POST request to the /api/auth/register endpoint.
      const response = await apiClient.post('/api/auth/register', payload);
      // Return the data from the successful response.
      return response.data;
    } catch (error) {
      // Log the technical error for developer debugging.
      console.error("Error during registration:", error);
      // Extract a user-friendly message from the backend's structured error
      // response, or provide a generic fallback.
      const errorMessage = error.response?.data?.detail || "Registration failed. Please try again.";
      // Re-throw the error so the calling function can catch it and update the UI.
      throw new Error(errorMessage);
    }
  },

  /**
   * Sends a login request to the backend using the OAuth2 Password Flow.
   *
   * @param {string} email - The user's email.
   * @param {string} password - The user's password.
   * @returns {Promise<object>} A promise that resolves to the token object
   *                            (e.g., { access_token, token_type }) on success.
   * @throws {Error} Throws an error with a user-friendly message on failure.
   */
  login: async (email, password) => {
    try {
      // The OAuth2 Password Flow requires `application/x-www-form-urlencoded` data.
      // URLSearchParams is the standard browser API to create this format.
      const formData = new URLSearchParams();
      formData.append('username', email);    // The backend's form expects the email in the 'username' field.
      formData.append('password', password); // The password goes in the 'password' field.

      // Make a POST request, explicitly setting the Content-Type for maximum robustness.
      const response = await apiClient.post('/api/auth/token', formData, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      });

      // On success, return the data, which will be the token object.
      return response.data;
    } catch (error) {
      console.error("Error during login:", error);
      const errorMessage = error.response?.data?.detail || "Login failed. Please check your credentials.";
      throw new Error(errorMessage);
    }
  },

  /**
   * Fetches the profile of the currently authenticated user using their stored token.
   *
   * This function relies on the `apiClient`'s request interceptor to
   * automatically attach the necessary `Authorization: Bearer <token>` header.
   *
   * @returns {Promise<object>} A promise that resolves to the current user's
   *                            profile data on success.
   * @throws {Error} Throws an error if the token is invalid or the session has expired.
   */
  getMe: async () => {
    try {
      // Make a simple GET request to the protected /api/auth/me endpoint.
      const response = await apiClient.get('/api/auth/me');
      
      // Return the user profile data.
      return response.data;
    } catch (error) {
      // This error will be triggered if the token is invalid, expired, or missing.
      // The `useAuth` hook will handle this to log the user out.
      console.error("Error fetching current user profile (/me):", error);
      const errorMessage = error.response?.data?.detail || "Your session has expired. Please log in again.";
      throw new Error(errorMessage);
    }
  },
};

export default authService;

--- File: .\ata-frontend\src\services\chatService.js ---

// /ata-frontend/src/services/chatService.js

import apiClient from './api';

const chatService = {
  /**
   * Fetches the list of all past chat session summaries for the user.
   * @returns {Promise<Array>} A promise that resolves to an array of session summary objects.
   */
  getChatSessions: async () => {
    try {
      const response = await apiClient.get('/api/chatbot/sessions');
      return response.data;
    } catch (error) {
      console.error("Error fetching chat sessions:", error);
      throw new Error(error.response?.data?.detail || "Failed to load chat history.");
    }
  },

  /**
   * Creates a new chat session with an initial message.
   * @param {string} firstMessage - The user's first message in the new chat.
   * @param {string|null} fileId - An optional ID of a file to associate with the first message.
   * @returns {Promise<object>} A promise that resolves to an object containing the new sessionId.
   */
  createNewChatSession: async (firstMessage, fileId = null) => {
    try {
      // --- [THE FIX IS HERE] ---
      // The payload now uses camelCase keys, matching the Pydantic model.
      const payload = {
        firstMessage: firstMessage,
        fileId: fileId,
      };
      // --- [END OF FIX] ---
      const response = await apiClient.post('/api/chatbot/sessions', payload);
      return response.data; // Expected to be { sessionId: "..." }
    } catch (error) {
      console.error("Error creating new chat session:", error);
      throw new Error(error.response?.data?.detail || "Failed to start new chat.");
    }
  },

  /**
   * Uploads a file for use in the chat.
   * @param {File} fileObject - The file to upload.
   * @returns {Promise<object>} A promise that resolves to an object containing the fileId.
   */
  uploadFile: async (fileObject) => {
    const formData = new FormData();
    formData.append('file', fileObject);

    try {
      const response = await apiClient.post('/api/chatbot/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data; // Expected to be { file_id: "..." }
    } catch (error) {
      console.error("Error uploading file:", error);
      throw new Error(error.response?.data?.detail || "Failed to upload file.");
    }
  },


  // Add inside the chatService object
  deleteChatSession: async (sessionId) => {
    try {
      // A DELETE request returns no content on success (204)
      await apiClient.delete(`/api/chatbot/sessions/${sessionId}`);
    } catch (error) {
      console.error("Error deleting chat session:", error);
      throw new Error(error.response?.data?.detail || "Failed to delete chat.");
    }
  },


  getChatSessionDetails: async (sessionId) => {
    try {
      const response = await apiClient.get(`/api/chatbot/sessions/${sessionId}`);
      return response.data; // Expected to be the full ChatSessionDetail object
    } catch (error) {
      console.error("Error fetching chat session details:", error);
      throw new Error(error.response?.data?.detail || "Failed to load chat session.");
    }
  },
};





export default chatService;

--- File: .\ata-frontend\src\services\classService.js ---

// /src/services/classService.js (FINAL, COMPLETE VERSION)

import apiClient from './api';

const classService = {
  // --- CLASS CRUD METHODS ---
  getAllClasses: async () => {
    try {
      const response = await apiClient.get('/api/classes');
      // Ensure we always return an array, even if the API response is faulty.
      return response.data || [];
    } catch (error) {
      console.error("Error fetching classes:", error);
      const errorMessage = error.response?.data?.detail || "Could not load classes.";
      throw new Error(errorMessage);
    }
  },
  getClassById: async (classId) => {
    try {
      const response = await apiClient.get(`/api/classes/${classId}`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching class details for ID ${classId}:`, error);
      const errorMessage = error.response?.data?.detail || "Could not load class details.";
      throw new Error(errorMessage);
    }
  },
  createClass: async (classData) => {
    try {
      const response = await apiClient.post('/api/classes', classData);
      return response.data;
    } catch (error) {
      console.error("Error creating class:", error);
      const errorMessage = error.response?.data?.detail || "Failed to create the class.";
      throw new Error(errorMessage);
    }
  },
  createClassWithUpload: async (className, file) => {
    const formData = new FormData();
    formData.append('name', className);
    formData.append('file', file);
    try {
      const response = await apiClient.post('/api/classes/upload', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
        timeout: 60000,
      });
      return response.data;
    } catch (error) {
      console.error("Error uploading roster:", error);
      if (error.code === 'ECONNABORTED') {
        throw new Error("The upload is taking longer than expected and timed out. Please check the file or try again.");
      }
      const errorMessage = error.response?.data?.detail || "Failed to upload and process the roster file.";
      throw new Error(errorMessage);
    }
  },
  updateClass: async (classId, classData) => {
    try {
      const response = await apiClient.put(`/api/classes/${classId}`, classData);
      return response.data;
    } catch (error) {
      console.error(`Error updating class ${classId}:`, error);
      const errorMessage = error.response?.data?.detail || "Failed to update the class.";
      throw new Error(errorMessage);
    }
  },
  deleteClass: async (classId) => {
    try {
      await apiClient.delete(`/api/classes/${classId}`);
    } catch (error) {
      console.error(`Error deleting class ${classId}:`, error);
      const errorMessage = error.response?.data?.detail || "Failed to delete the class.";
      throw new Error(errorMessage);
    }
  },
  exportClassRoster: async (classId) => {
    try {
      const response = await apiClient.get(`/api/classes/${classId}/export`, { responseType: 'blob' });
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const contentDisposition = response.headers['content-disposition'];
      let fileName = `roster_${classId}.csv`;
      if (contentDisposition) {
        const fileNameMatch = contentDisposition.match(/filename="(.+)"/);
        if (fileNameMatch && fileNameMatch.length === 2) fileName = fileNameMatch[1];
      }
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', fileName);
      document.body.appendChild(link);
      link.click();
      link.parentNode.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error(`Error exporting roster for class ${classId}:`, error);
      throw new Error("Failed to export the roster. Please try again.");
    }
  },
  // --- STUDENT CRUD METHODS ---
  addStudentToClass: async (classId, studentData) => {
    try {
      const response = await apiClient.post(`/api/classes/${classId}/students`, studentData);
      return response.data;
    } catch (error) {
      console.error(`Error adding student to class ${classId}:`, error);
      const errorMessage = error.response?.data?.detail || "Failed to add the student.";
      throw new Error(errorMessage);
    }
  },
  updateStudent: async (classId, studentId, studentData) => {
    try {
      const response = await apiClient.put(`/api/classes/${classId}/students/${studentId}`, studentData);
      return response.data;
    } catch (error) {
      console.error(`Error updating student ${studentId}:`, error);
      const errorMessage = error.response?.data?.detail || "Failed to update student details.";
      throw new Error(errorMessage);
    }
  },
  removeStudent: async (classId, studentId) => {
    try {
      await apiClient.delete(`/api/classes/${classId}/students/${studentId}`);
    } catch (error) {
      console.error(`Error removing student ${studentId} from class ${classId}:`, error);
      const errorMessage = error.response?.data?.detail || "Failed to remove the student.";
      throw new Error(errorMessage);
    }
  },
};
export default classService;

--- File: .\ata-frontend\src\services\dashboardService.js ---

// /src/services/dashboardService.js

// --- Core Imports ---
// Import the single, configured apiClient instance.
// We do NOT import the raw 'axios' library here.
import apiClient from './api';

/**
 * A service object that encapsulates all API calls related to the main dashboard.
 * This is the abstraction layer between our components and the raw HTTP requests.
 */
const dashboardService = {
  /**
   * Fetches the summary of high-level statistics from the backend.
   *
   * @returns {Promise<object>} A promise that resolves to an object containing
   *                            the dashboard data (e.g., { classCount, studentCount }).
   */
  getSummary: async () => {
    try {
      // Use the apiClient to make a GET request to the specific endpoint.
      // The base URL ('http://localhost:8000') is already configured in apiClient.
      const response = await apiClient.get('/api/dashboard/summary');
      
      // Axios automatically parses the JSON, so we can directly return the data.
      return response.data;
    } catch (error) {
      // Log the technical error for developer debugging.
      console.error("Error fetching dashboard summary:", error);

      // Extract a user-friendly message from the backend's structured error response.
      // If none is available, provide a generic fallback message.
      const errorMessage = error.response?.data?.detail || "Could not connect to the server. Please try again later.";
      
      // CRITICAL: Re-throw the error with the user-friendly message so the calling
      // page component can catch it and update the UI state accordingly.
      throw new Error(errorMessage);
    }
  },
};

// Export the service object for use in our page components.
export default dashboardService;

--- File: .\ata-frontend\src\services\historyService.js ---

// /src/services/historyService.js

import apiClient from './api';

const historyService = {
  /**
   * Saves a completed AI generation to the user's history.
   * @param {object} payload - The data to save.
   * @returns {Promise<object>} The saved generation record.
   */
  saveGeneration: async (payload) => {
    try {
      const response = await apiClient.post('/api/history', payload);
      return response.data;
    } catch (error) {
      console.error("Error saving generation:", error);
      const errorMessage = error.response?.data?.detail || "Could not save the generation. Please try again.";
      throw new Error(errorMessage);
    }
  },

  /**
   * Fetches the AI generation history from the backend.
   * @param {object} params - Optional query parameters like { search, tool_id }.
   * @returns {Promise<object>} The history response object.
   */
  getHistory: async (params = {}) => {
    try {
      const response = await apiClient.get('/api/history', { params });
      return response.data;
    } catch (error) {
      console.error("Error fetching history:", error);
      const errorMessage = error.response?.data?.detail || "An error occurred while fetching your saved generations.";
      throw new Error(errorMessage);
    }
  },

  // --- [START] NEW DELETE FUNCTION ---
  /**
   * Deletes a specific generation record from the user's history.
   * @param {string} generationId - The ID of the history record to delete.
   * @returns {Promise<void>} A promise that resolves on successful deletion.
   */
  deleteGeneration: async (generationId) => {
    try {
      // The DELETE request is sent to the specific resource URL.
      // A successful 204 response from the backend will resolve this promise.
      await apiClient.delete(`/api/history/${generationId}`);
    } catch (error) {
      console.error(`Error deleting generation ${generationId}:`, error);
      const errorMessage = error.response?.data?.detail || "Could not delete the saved item. Please try again.";
      throw new Error(errorMessage);
    }
  },
  // --- [END] NEW DELETE FUNCTION ---
};

export default historyService;

--- File: .\ata-frontend\src\services\libraryService.js ---

// /src/services/libraryService.js

import apiClient from './api';

const libraryService = {
  /**
   * Fetches the entire book library structure from the backend.
   * This is designed to be called once and the result cached by the frontend.
   * @returns {Promise<Array>} A promise that resolves to the hierarchical library tree object.
   */
  getTree: async () => {
    try {
      const response = await apiClient.get('/api/library/tree');
      return response.data;
    } catch (error) {
      console.error("Error fetching library tree:", error);
      // For this critical data, we throw a more specific error.
      const errorMessage = error.response?.data?.detail || "Could not load the curriculum library. Please try again later.";
      throw new Error(errorMessage);
    }
  },
};

export default libraryService;

--- File: .\ata-frontend\src\services\reviewService.js ---

import apiClient from './api';

const reviewService = {
  async getResultsOverview(jobId) {
    try {
      const { data } = await apiClient.get(`/api/assessments/${jobId}/overview`);
      // Corrected to use camelCase keys from the API response
      return {
        jobId: data.jobId,
        assessmentName: data.assessmentName,
        status: data.status,
        studentsAiGraded: data.studentsAiGraded ?? [],
        studentsPending:  data.studentsPending  ?? [],
        students: data.students ?? [],
      };
    } catch (error) {
      console.error(`Error fetching results overview for job ${jobId}:`, error);
      throw new Error(error.response?.data?.detail || "Failed to load results overview.");
    }
  },

  async getStudentReview(jobId, studentId) {
    try {
      const { data } = await apiClient.get(`/api/assessments/${jobId}/students/${studentId}/review`);
      // Corrected to use camelCase keys from the API response
      return {
        jobId: data.jobId,
        studentId: data.studentId,
        studentName: data.studentName,
        assessmentName: data.assessmentName,
        config: data.config ?? {},
        perQuestion: data.perQuestion ?? [],
      };
    } catch (error) {
      console.error(`Error fetching review data for student ${studentId} in job ${jobId}:`, error);
      throw new Error(error.response?.data?.detail || "Failed to load student review data.");
    }
  },

  async saveQuestion(jobId, studentId, questionId, payload) {
    try {
      const { data } = await apiClient.patch(
        `/api/assessments/${jobId}/students/${studentId}/questions/${questionId}`,
        payload
      );
      return data;
    } catch (error) {
      console.error(`Error saving question review for student ${studentId} in job ${jobId}:`, error);
      throw new Error(error.response?.data?.detail || "Could not save changes.");
    }
  },

  async downloadReport(jobId, studentId) {
    try {
      const response = await apiClient.get(
        `/api/assessments/${jobId}/students/${studentId}/report.docx`,
        { responseType: 'blob' } // Important: request the data as a blob
      );

      // Create a URL for the blob
      const url = window.URL.createObjectURL(new Blob([response.data]));

      // Create a temporary link element to trigger the download
      const link = document.createElement('a');
      link.href = url;

      // Extract filename from Content-Disposition header if available
      // Note: Axios normalizes headers to lowercase
      let filename = `report_${studentId}.docx`; // fallback
      const contentDisposition = response.headers['content-disposition'] || response.headers['Content-Disposition'];
      if (contentDisposition) {
        // Match filename with or without quotes, handles: filename="name.docx" or filename=name.docx
        const filenameMatch = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
        if (filenameMatch && filenameMatch[1]) {
          filename = filenameMatch[1].replace(/['"]/g, ''); // Remove quotes
        }
      }
      link.setAttribute('download', filename);

      // Append to the document, click, and then remove
      document.body.appendChild(link);
      link.click();
      link.parentNode.removeChild(link);

      // Clean up the blob URL
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error(`Error downloading report for student ${studentId} in job ${jobId}:`, error);
      // Optionally, show a user-facing error message here
      throw new Error(error.response?.data?.detail || "Could not download the report.");
    }
  },
};

export default reviewService;

--- File: .\ata-frontend\src\services\studentService.js ---

// /ata-frontend/src/services/studentService.js

import api from './api';

/**
 * Service for student-related API operations.
 */
const studentService = {
  /**
   * Fetches the complete transcript for a student.
   *
   * @param {string} studentId - The ID of the student
   * @returns {Promise<Object>} Student transcript data
   */
  async getStudentTranscript(studentId) {
    const response = await api.get(`/api/students/${studentId}/transcript`);
    return response.data;
  },
};

export default studentService;


--- File: .\ata-frontend\src\services\toolService.js ---

// /src/services/toolService.js

import apiClient from './api';

const toolService = {
  /**
   * Sends a request to the AI to generate content.
   * This function intelligently chooses the correct endpoint based on whether a file is provided.
   * @param {object} settingsPayload - The full settings object from the form state.
   * @param {File | null} sourceFile - The optional file to upload for context.
   * @returns {Promise<object>} A promise that resolves to the generation response object from the API.
   */
  generateContent: async (settingsPayload, sourceFile) => {
    try {
      if (sourceFile) {
        const formData = new FormData();
        formData.append('settings', JSON.stringify(settingsPayload));
        formData.append('source_file', sourceFile);
        
        const config = { headers: { 'Content-Type': 'multipart/form-data' } };
        const response = await apiClient.post('/api/tools/generate/upload', formData, config);
        return response.data;
      } else {
        const response = await apiClient.post('/api/tools/generate/text', settingsPayload);
        return response.data;
      }
    } catch (error) {
      console.error("Error generating content:", error);
      const errorMessage = error.response?.data?.detail || "An unexpected server error occurred.";
      throw new Error(errorMessage);
    }
  },
};

export default toolService;

--- File: .\ata-frontend\src\theme\theme.js ---

// /src/theme/theme.js

import { createTheme } from '@mui/material/styles';
import { grey } from '@mui/material/colors'; // Import the grey color palette

const lightPalette = {
  mode: 'light',
  primary: {
    main: '#5403FF',
    light: '#7636FF',
    dark: '#3A02B2',
    contrastText: '#FFFFFF',
  },
  secondary: {
    main: '#D7D0F2',
    light: '#E9E4F8',
    dark: '#B9AEE0',
    contrastText: '#121926',
  },
  background: {
    default: '#F8FAFC',
    paper: '#FFFFFF',
  },
  text: {
    primary: '#121926',
    secondary: '#6C737F',
    disabled: '#A0A6AE',
  },
  error: { main: '#D32F2F', contrastText: '#FFFFFF' },
  warning: { main: '#FFAB00', contrastText: '#FFFFFF' },
  success: { main: '#00C853', contrastText: '#FFFFFF' },
  divider: '#E0E3E7',
};

const darkPalette = {
  mode: 'dark',
  primary: {
    main: '#9D78FF',
    light: '#B092FF',
    dark: '#8A5CFF',
    contrastText: '#121926',
  },
  secondary: {
    main: '#4A4458',
    light: '#635C74',
    dark: '#352F40',
    contrastText: '#E0E0E0',
  },
  background: {
    default: '#121212',
    paper: '#1E1E1E',
  },
  text: {
    primary: '#E0E0E0',
    secondary: '#B0B0B0',
    disabled: '#757575',
  },
  error: { main: '#EF5350', contrastText: '#121212' },
  warning: { main: '#FFCA28', contrastText: '#121212' },
  success: { main: '#66BB6A', contrastText: '#121212' },
  divider: 'rgba(255, 255, 255, 0.12)',
};

export const getTheme = (mode) => createTheme({
  palette: mode === 'light' ? lightPalette : darkPalette,
  
  typography: {
    fontFamily: '"Inter", -apple-system, sans-serif',
    h1: {
      fontWeight: 700,
      fontSize: '2.25rem',
      lineHeight: 1.2,
      '@media (max-width:600px)': { fontSize: '1.75rem' },
    },
    h2: {
      fontWeight: 700,
      fontSize: '1.75rem',
      lineHeight: 1.3,
    },
    h3: {
      fontWeight: 600,
      fontSize: '1.25rem',
      lineHeight: 1.4,
    },
    h4: {
      fontWeight: 600,
      fontSize: '1.0rem',
      lineHeight: 1.5,
    },
    body1: {
      fontWeight: 400,
      fontSize: '0.875rem',
      lineHeight: 1.57,
    },
    button: {
      fontWeight: 500,
      textTransform: 'none',
    },
  },
  
  components: {
    MuiButton: {
      defaultProps: {
        disableElevation: true,
      },
      styleOverrides: {
        root: {
          borderRadius: 8,
          padding: '8px 16px',
        },
        sizeLarge: {
          padding: '12px 24px',
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 16,
          // We will use the MuiPaper override for the default shadow now
          boxShadow: 'none', 
        },
      },
    },
    MuiTextField: {
      defaultProps: {
        variant: 'outlined',
        size: 'small',
      },
    },
    MuiOutlinedInput: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
    // --- [THE FIX IS APPLIED HERE] ---
    MuiTableCell: {
      styleOverrides: {
        head: {
          // In dark mode, MUI's gray scale is inverted, so a higher number is darker.
          backgroundColor: mode === 'light' ? grey[100] : grey[900], 
          fontWeight: 600,
        },
      },
    },
    // --- [END OF FIX] ---
    MuiPaper: {
        styleOverrides: {
            root: {
                // This applies a default shadow to all Paper components (Cards, Menus, etc.)
                boxShadow: '0px 4px 12px rgba(0, 0, 0, 0.05)',
            },
            // We use variants to apply specific styles. Dropdown menus use the 'elevation' variant.
            elevation: {
                // This will specifically target dropdowns from Selects, Autocompletes, and Menus
                border: '1px solid',
                borderColor: mode === 'light' ? lightPalette.divider : darkPalette.divider,
            }
        }
    }
  },
});

