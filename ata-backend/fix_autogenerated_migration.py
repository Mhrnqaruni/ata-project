"""
Post-Autogenerate Migration Fixer

This script runs after 'alembic revision --autogenerate' to fix table ordering.
It ensures quiz_session_roster is created BEFORE quiz_participants.

Usage:
    python fix_autogenerated_migration.py
"""

import os
import re
from pathlib import Path
from typing import Optional


def find_latest_migration(versions_dir: Path) -> Optional[Path]:
    """Find the most recently created migration file."""
    py_files = [f for f in versions_dir.glob("*.py") if f.name != "__init__.py"]
    if not py_files:
        return None

    # Sort by creation time
    return max(py_files, key=lambda f: f.stat().st_mtime)


def extract_table_creation(content: str, table_name: str) -> Optional[tuple[int, int, str]]:
    """Extract a table creation block from migration content.

    Returns: (start_pos, end_pos, table_block) or None
    """
    # Look for op.create_table('table_name',
    pattern = rf"op\.create_table\('{table_name}',"
    match = re.search(pattern, content)

    if not match:
        return None

    start = match.start()

    # Find the matching closing parenthesis
    depth = 0
    in_table = False
    end = start

    for i in range(start, len(content)):
        char = content[i]
        if char == '(' :
            depth += 1
            in_table = True
        elif char == ')':
            depth -= 1
            if in_table and depth == 0:
                end = i + 1
                break

    # Include any following create_index calls for this table
    remaining = content[end:]
    index_pattern = rf"op\.create_index\([^)]*'{table_name}'[^)]*\)"

    while True:
        index_match = re.search(index_pattern, remaining)
        if not index_match:
            break

        # Make sure it's right after (allow whitespace and comments)
        between = remaining[:index_match.start()]
        if re.match(r'^\s*(#[^\n]*)?\s*$', between, re.MULTILINE):
            end += index_match.end()
            remaining = content[end:]
        else:
            break

    table_block = content[start:end]
    return (start, end, table_block)


def fix_migration_order(migration_file: Path) -> bool:
    """Fix the order of table creation in a migration file.

    Ensures quiz_session_roster is created before quiz_participants.
    """
    print(f"\nüîç Analyzing migration: {migration_file.name}")

    with open(migration_file, 'r', encoding='utf-8') as f:
        content = f.read()

    # Check if this migration has the problematic tables
    if 'quiz_session_roster' not in content:
        print("   ‚ÑπÔ∏è  No roster tables found - skipping")
        return True

    if 'quiz_participants' not in content:
        print("   ‚ÑπÔ∏è  No quiz_participants table - skipping")
        return True

    # Extract table creation blocks
    roster_info = extract_table_creation(content, 'quiz_session_roster')
    participants_info = extract_table_creation(content, 'quiz_participants')

    if not roster_info:
        print("   ‚ö†Ô∏è  Could not extract quiz_session_roster table")
        return False

    if not participants_info:
        print("   ‚ö†Ô∏è  Could not extract quiz_participants table")
        return False

    roster_start, roster_end, roster_block = roster_info
    part_start, part_end, part_block = participants_info

    # Check if order is already correct
    if roster_start < part_start:
        print("   ‚úÖ Table order is already correct")
        return True

    print("   üîß Fixing table order (moving quiz_session_roster before quiz_participants)...")

    # Reconstruct content with correct order
    # Remove both blocks first
    before_first = content[:min(roster_start, part_start)]

    if roster_start < part_start:
        # roster comes first in file (correct order)
        between = content[roster_end:part_start]
        after_last = content[part_end:]
        new_content = before_first + roster_block + between + part_block + after_last
    else:
        # participants comes first in file (wrong order - fix it)
        between = content[part_end:roster_start]
        after_last = content[roster_end:]

        # Swap them: roster first, then participants
        new_content = before_first + roster_block + "\n\n" + part_block + between + after_last

    # Write back
    with open(migration_file, 'w', encoding='utf-8') as f:
        f.write(new_content)

    print("   ‚úÖ Migration fixed successfully!")
    return True


def check_foreign_key_issue(migration_file: Path) -> bool:
    """Check if quiz_participants has FK to quiz_session_roster."""
    with open(migration_file, 'r', encoding='utf-8') as f:
        content = f.read()

    # Look for foreign key in quiz_participants that references quiz_session_roster
    participants_block = extract_table_creation(content, 'quiz_participants')

    if not participants_block:
        return True

    _, _, block = participants_block

    if 'quiz_session_roster' in block and 'ForeignKeyConstraint' in block:
        return True  # Has FK to roster (this is expected after our fix)

    return True


def main():
    print("=" * 70)
    print("üîß Post-Autogenerate Migration Fixer")
    print("=" * 70)

    # Find versions directory
    script_dir = Path(__file__).parent
    versions_dir = script_dir / "alembic" / "versions"

    if not versions_dir.exists():
        print(f"‚ùå Error: {versions_dir} not found")
        return 1

    # Find latest migration
    latest = find_latest_migration(versions_dir)

    if not latest:
        print("‚ùå No migration files found")
        return 1

    # Fix the migration
    success = fix_migration_order(latest)

    if success:
        print("\n" + "=" * 70)
        print("‚úÖ Migration fixed successfully!")
        print("\nNext step:")
        print("   alembic upgrade head")
        return 0
    else:
        print("\n" + "=" * 70)
        print("‚ùå Failed to fix migration")
        print("\nPlease check the migration file manually:")
        print(f"   {latest}")
        return 1


if __name__ == "__main__":
    exit(main())
